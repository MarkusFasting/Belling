# -*- coding: utf-8 -*-
"""SuperDJ_Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dR87wUe19fKb3qi0XtftxB2g8UmxCl7k
"""

from google.colab import drive
drive.mount('/content/drive')

import os
project_path = '/content/drive/My Drive/SuperDJ_Project'
os.chdir(project_path)

import os

# List all files in the project directory
for root, dirs, files in os.walk(project_path):
    for name in files:
        print(os.path.join(root, name))

# Åpne en eksisterende fil
with open('/content/drive/My Drive/SuperDJ_Project/python_ai/analyze_music.py', 'r') as file:
    code = file.read()
    print(code)

# Opprette og skrive til en ny Python-fil
code = """
import librosa
import numpy as np

def analyze_track(file_path):
    y, sr = librosa.load(file_path)
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr)
    key = np.argmax(chroma, axis=0)
    return tempo, key

if __name__ == "__main__":
    bpm, key = analyze_track('your_song.mp3')
    print(f"BPM: {bpm}, Key: {key}")
"""
with open('/content/drive/My Drive/SuperDJ_Project/python_ai/analyze_music.py', 'w') as file:
    file.write(code)

!python3 /content/drive/My\ Drive/SuperDJ_Project/python_ai/analyze_music.py

import librosa
import numpy as np

def analyze_track(file_path):
    # Laster inn musikkfilen
    y, sr = librosa.load(file_path)

    # Analyserer tempoet (BPM)
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)

    # Ekstraherer kromagram som kan brukes til å finne nøkkelen
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr)

    # Finne mest dominerende toneart (nøkkel)
    key = np.argmax(chroma, axis=0)

    return tempo, key

if __name__ == "__main__":
    # Angi filbanen til sangen som skal analyseres
    file_path = "/content/drive/My Drive/SuperDJ_Project/music_library/17588048_Believer_(Original Mix).mp3"

    # Analyser sangen
    bpm, key = analyze_track(file_path)

    # Skriv ut resultatene
    print(f"BPM: {bpm}, Key: {key}")

import librosa
import numpy as np

def analyze_track(file_path):
    y, sr = librosa.load(file_path)
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr)
    key = np.argmax(np.sum(chroma, axis=1))
    return tempo, key

if __name__ == "__main__":
    # Angi filbanen til sangen som skal analyseres
    file_path = "/content/drive/My Drive/SuperDJ_Project/music_library/17985216_Spring Girl_(Extended).mp3"

    # Analyser sangen
    bpm, key = analyze_track(file_path)

    # Skriv ut resultatene
    print(f"BPM: {bpm}, Key: {key}")

!pip install requests beautifulsoup4

output_file_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/key_sentences_analysis.csv'

import os

folder_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj'
files = os.listdir(folder_path)
print(files)

!pip install nltk
!pip install gensim
!pip install spacy
!python -m spacy download en_core_web_sm

!pip install nltk
!pip install gensim
!pip install spacy
!python -m spacy download en_core_web_sm

import os
import nltk
from gensim.models import Word2Vec
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize

# Last ned nødvendige NLTK-pakker
nltk.download('punkt')
nltk.download('stopwords')

def preprocess_text(text):
    # Tokeniser teksten
    tokens = word_tokenize(text)
    # Fjern stopwords
    tokens = [word for word in tokens if word.lower() not in stopwords.words('english')]
    return tokens

def process_text_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        text = file.read()
    return preprocess_text(text)

# Prosessér alle filer i input-mappen
input_dir = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj'
all_sentences = []
for filename in os.listdir(input_dir):
    if filename.endswith('.txt'):
        file_path = os.path.join(input_dir, filename)
        tokens = process_text_file(file_path)
        all_sentences.append(tokens)

# Bygg ordforråd og tren modellen
model = Word2Vec(min_count=1)
model.build_vocab(all_sentences)  # Først bygg ordforrådet
model.train(all_sentences, total_examples=model.corpus_count, epochs=model.epochs)  # Deretter tren modellen

print("NLP-prosessering fullført for alle filer.")

# Importer nødvendige biblioteker
from gensim.models import Word2Vec
import os
import re

# Input-mapppens sti (der de prosesserte tekstfilene ligger)
input_dir = "/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj/"

# Funksjon for å lese inn og tokenisere en tekstfil
def process_text_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        text = file.read().lower()  # Konverterer til små bokstaver
        text = re.sub(r'[^\w\s]', '', text)  # Fjerner tegnsetting
        tokens = text.split()  # Splitter på mellomrom
    return tokens

# Liste for å holde alle setninger (dvs. tokeniserte ord)
all_sentences = []

# Gå gjennom alle filer i input-mappen
for filename in os.listdir(input_dir):
    if filename.endswith('.txt'):
        file_path = os.path.join(input_dir, filename)
        tokens = process_text_file(file_path)
        all_sentences.append(tokens)

# Bygg ordforrådet og tren Word2Vec-modellen
model = Word2Vec(sentences=all_sentences, vector_size=100, window=5, min_count=1, workers=4)

# Lagre modellen slik at vi kan bruke den senere
model_save_path = "/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model.model"
model.save(model_save_path)

print("Word2Vec-modellen er trent og lagret.")

# Importer nødvendige biblioteker
from gensim.models import Word2Vec
import os
import re

# Input-mappens sti (der de prosesserte tekstfilene ligger)
input_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj/'

# Funksjon for å lese inn og tokenisere en tekstfil
def process_text_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        text = file.read().lower()  # Konverterer til små bokstaver
        text = re.sub(r'[^\w\s]', '', text)  # Fjerner tegnsetting
        tokens = text.split()  # Splitter på mellomrom
    return tokens

# Liste for å holde alle setninger (dvs. tokeniserte ord)
all_sentences = []

# Gå gjennom alle filer i input-mappen
for filename in os.listdir(input_dir):
    if filename.endswith('.txt'):
        file_path = os.path.join(input_dir, filename)
        tokens = process_text_file(file_path)
        all_sentences.append(tokens)

# Bygg ordforrådet og tren Word2Vec-modellen
model = Word2Vec(sentences=all_sentences, vector_size=100, window=5, min_count=1, workers=4)

# Lagre modellen slik at vi kan bruke den senere
model_save_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model.model'
model.save(model_save_path)

print("Word2Vec-modellen er trent og lagret.")

# Importer nødvendige biblioteker
from gensim.models import Word2Vec
import os

# Funksjon for å behandle hver tekstfil
def process_text_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()

    # Enkel tokenisering ved å splitte på mellomrom
    tokens = content.split()
    return tokens

# Angi mappen der de prosesserte tekstfilene er lagret (justert filsti)
input_dir = "/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj/"

# Liste for å samle setninger fra alle filer
all_sentences = []

# Gå gjennom alle filer i input-mappen
for filename in os.listdir(input_dir):
    if filename.endswith('.txt'):
        file_path = os.path.join(input_dir, filename)
        tokens = process_text_file(file_path)
        all_sentences.append(tokens)

# Bygg ordforrådet og tren Word2Vec-modellen
model = Word2Vec(sentences=all_sentences, vector_size=100, window=5, min_count=1, workers=4)

# Lagre modellen slik at vi kan bruke den senere
model_save_path = "/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model.model"
model.save(model_save_path)

print("Word2Vec-modellen er trent og lagret.")

import os
folder_path = '/content/drive/My Drive/SuperDJ_Project/'
print(os.listdir(folder_path))

from google.colab import drive
drive.mount('/content/drive')

import os
folder_path = '/content/drive/My Drive/SuperDJ_Project/'
print(os.listdir(folder_path))

import os
from gensim.models import Word2Vec

# Sett riktig mappevei for input
input_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Lagre setningene fra alle filer
all_sentences = []

# Gå gjennom alle filer i input-mappen
for filename in os.listdir(input_dir):
    if filename.endswith('.txt'):
        file_path = os.path.join(input_dir, filename)
        tokens = process_text_file(file_path)
        all_sentences.append(tokens)

# Bygg ordforrådet og tren Word2Vec-modellen
model = Word2Vec(sentences=all_sentences, vector_size=100, window=5, min_count=1, workers=4)

# Lagre modellen slik at vi kan bruke den senere
model_save_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model.model'
model.save(model_save_path)

print("Word2Vec-modellen er trent og lagret.")

# Last inn den lagrede modellen
from gensim.models import Word2Vec

model_save_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model.model'
model = Word2Vec.load(model_save_path)

# Finn ord som ligner på 'mixing'
similar_words = model.wv.most_similar('mixing')
print(similar_words)

# Sjekk hva som er i modellen sitt ordforråd
vocabulary = list(model.wv.index_to_key)  # Gir en liste av ord i modellen sitt vokabular
print(vocabulary[:50])  # Skriv ut de første 50 ordene

import os

# Stien til mappen
input_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Skriv ut alle filer i mappen for å sjekke om de finnes
print("Filer i mappen:")
print(os.listdir(input_dir))

similar_words = model.wv.most_similar('mix')
print(similar_words)

# Sjekk om ordet 'mixing' er i filene
file_path = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj/dj_mixing_beginners_processed.txt'

with open(file_path, 'r', encoding='utf-8') as f:
    content = f.read()
    print('Er "mixing" til stede:', 'mixing' in content)

import os

# Sjekk flere varianter av ordet 'mixing'
def check_word_in_files(word_list, input_dir):
    for filename in os.listdir(input_dir):
        if filename.endswith('.txt'):
            file_path = os.path.join(input_dir, filename)
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().lower()  # Gjør alt til små bokstaver for konsistens
                for word in word_list:
                    print(f'Er "{word}" til stede i {filename}:', word in content)

# Ordliste med mulige varianter av 'mixing'
word_list = ['mixing', 'mix']

# Sti til mappen med tekstfiler
input_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Kjør sjekken
check_word_in_files(word_list, input_dir)

# Finn ord som ligner på 'mix'
similar_words = model.wv.most_similar('mix')
print(similar_words)

import os
from gensim.models import Word2Vec

# Sjekk flere varianter av ordet 'mixing'
def check_word_in_files(word_list, input_dir):
    for filename in os.listdir(input_dir):
        if filename.endswith('.txt'):
            file_path = os.path.join(input_dir, filename)
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().lower()  # Gjør alt til små bokstaver for konsistens
                for word in word_list:
                    print(f'Er "{word}" til stede i {filename}:', word in content)

# Ordliste med mulige varianter av 'mixing'
word_list = ['mixing', 'mix']

# Sti til mappen med tekstfiler
input_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Kjør sjekken
check_word_in_files(word_list, input_dir)

# Last inn den lagrede Word2Vec-modellen
model_save_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model.model'
model = Word2Vec.load(model_save_path)

# Utfør lignende ord-søk med varianten 'mix'
for word in word_list:
    if word in model.wv.index_to_key:  # Sjekk om ordet finnes i ordforrådet
        similar_words = model.wv.most_similar(word)
        print(f'Lignende ord til "{word}":', similar_words)
    else:
        print(f'Ordet "{word}" finnes ikke i modellens ordforråd.')

import os

# Forsterk nøkkelord og relevante DJ-relaterte ord
def enhance_dj_terms(text):
    dj_keywords = ['mixing', 'transition', 'beatmatching', 'cue points', 'tempo', 'crossfade', 'effects', 'bpm']

    # Sett tekst til små bokstaver og fjern unødvendige tegnsettinger
    text = text.lower()

    # Legg til ekstra ord som kan være relevante for AI-læring
    enhanced_text = []
    for sentence in text.split('\n'):
        enhanced_sentence = sentence
        for word in dj_keywords:
            if word not in sentence:
                enhanced_sentence += f" {word}"  # Legg til nøkkelord
        enhanced_text.append(enhanced_sentence)

    return '\n'.join(enhanced_text)

# Sti til den eksisterende mappen med tekstfiler
input_dir = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj'
output_dir = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/enhanced_files'

# Sørg for at output-mappen finnes
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# Prosessere alle tekstfiler i input-mappen
for filename in os.listdir(input_dir):
    if filename.endswith('.txt'):
        file_path = os.path.join(input_dir, filename)
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Forsterk tekstene med DJ-relaterte ord
        enhanced_content = enhance_dj_terms(content)

        # Lagre de forbedrede filene i en ny mappe
        output_file_path = os.path.join(output_dir, filename)
        with open(output_file_path, 'w', encoding='utf-8') as output_file:
            output_file.write(enhanced_content)

print("Forbedring av tekstene fullført og lagret.")

import os

# Liste over viktige DJ-relaterte ord vi vil sjekke for
important_words = ['mixing', 'crossfade', 'beatmatching', 'cueing', 'bpm', 'sync', 'transition', 'phrasing', 'tempo', 'looping']

# Funksjon for å sjekke om viktige ord er til stede i filene
def check_important_words_in_files(word_list, input_dir):
    for filename in os.listdir(input_dir):
        if filename.endswith('.txt'):
            file_path = os.path.join(input_dir, filename)
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().lower()  # Gjør alt til små bokstaver for konsistens
                for word in word_list:
                    print(f'Er "{word}" til stede i {filename}:', word in content)

# Sti til mappen med tekstfiler
input_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Kjør sjekken
check_important_words_in_files(important_words, input_dir)

import os

# Opprett en ordliste for hver fil, basert på tema
word_lists = {
    'dj_mixing_beginners_processed.txt': ['mixing', 'bpm', 'sync', 'cueing', 'transition', 'looping'],
    'ai-dj-software_processed.txt': ['ai', 'automation', 'mix', 'software', 'algorithm', 'dj'],
    'dj-mixing-beginners_processed.txt': ['beatmatching', 'bpm', 'mixing', 'cue', 'djing'],
    'dj_mixing_techniques_processed.txt': ['crossfade', 'phrasing', 'tempo', 'mixing', 'cue', 'effect'],
    'best-dj-software-for-mac_processed.txt': ['software', 'mixing', 'platform', 'dj', 'sync', 'cue'],
    # Legg til flere filer her med relevante ord
}

# Funksjon for å sjekke om nøkkelord er i filene
def check_specific_words_in_files(word_lists, input_dir):
    for filename, word_list in word_lists.items():
        file_path = os.path.join(input_dir, filename)
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().lower()
                print(f'\nSjekker filen: {filename}')
                for word in word_list:
                    print(f'Er "{word}" til stede:', word in content)
        else:
            print(f'Filen {filename} ble ikke funnet i mappen.')

# Sti til mappen med tekstfiler
input_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Kjør sjekken
check_specific_words_in_files(word_lists, input_dir)

import requests
from bs4 import BeautifulSoup
import os

# Funksjon for å ekstrahere nøkkelsetninger fra en artikkel, basert på relevante ord
def extract_key_sentences(article_url, important_words):
    response = requests.get(article_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    paragraphs = soup.find_all('p')

    extracted_sentences = []
    for paragraph in paragraphs:
        paragraph_text = paragraph.text.lower()
        if any(word in paragraph_text for word in important_words):
            extracted_sentences.append(paragraph.text.strip())

    return extracted_sentences

# Funksjon for å lagre artikkelinnholdet i en fil
def save_article_content(url, sentences, important_words):
    filename = url.split("/")[-1] + ".txt"
    save_path = f"/content/drive/My Drive/SuperDJ_Project/ai_super_dj/{filename}"

    with open(save_path, 'w', encoding='utf-8') as file:
        file.write(f"Nøkkelord brukt for utvalg: {', '.join(important_words)}\n\n")
        for sentence in sentences:
            file.write(sentence + '\n')

# Liste over lenker og tilhørende temaer
urls_and_themes = {
    "https://dj.studio/blog/dj-mixing-beginners": ['mixing', 'beatmatching', 'bpm', 'cueing', 'transition'],
    "https://dj.studio/blog/auto-mixing": ['automation', 'mixing', 'algorithm', 'dj', 'ai'],
    "https://dj.studio/blog/ai-dj-software": ['ai', 'automation', 'software', 'algorithm', 'dj'],
    "https://dj.studio/blog/best-dj-software-for-mac": ['software', 'dj', 'platform', 'mixing', 'sync'],
    "https://dj.studio/blog/ai-mixing-apps": ['ai', 'automation', 'mixing', 'algorithm', 'dj'],
    "https://dj.studio/blog/dj-crossfade-techniques": ['crossfade', 'mixing', 'dj', 'transition', 'bpm'],
    "https://dj.studio/blog/dj-tempo-change-techniques": ['tempo', 'mixing', 'dj', 'bpm', 'cueing'],
    "https://dj.studio/blog/phrasing-dj-mixing": ['phrasing', 'dj', 'mixing', 'beatmatching'],
    "https://dj.studio/blog/dj-cue-points": ['cue', 'mixing', 'dj', 'beatmatching'],
    "https://dj.studio/blog/dj-beatgridding": ['beatgridding', 'sync', 'dj', 'mixing'],
    "https://dj.studio/blog/dj-inspiration": ['inspiration', 'dj', 'creativity', 'mixing'],
    "https://dj.studio/blog/mixing-db-levels": ['mixing', 'db levels', 'volume', 'dj'],
    "https://dj.studio/blog/dj-with-spotify": ['spotify', 'dj', 'streaming', 'mixing'],
    "https://dj.studio/blog/beat-matching-app": ['beatmatching', 'app', 'dj', 'mixing'],
    "https://dj.studio/blog/dj-mixing-effects": ['effects', 'mixing', 'dj', 'transition'],
    "https://dj.studio/blog/dj-mix-songs": ['mixing', 'songs', 'dj', 'transition'],
    "https://dj.studio/blog/master-a-dj-mix": ['mastering', 'mixing', 'dj', 'transition'],
    "https://dj.studio/blog/advanced-dj-mixing-techniques": ['advanced techniques', 'mixing', 'dj', 'transition'],
    "https://dj.studio/blog/bad-dj-mixing-mistakes": ['mistakes', 'mixing', 'dj', 'transition'],
    "https://dj.studio/blog/basic-transition-techniques": ['transition', 'mixing', 'dj', 'bpm'],
    "https://dj.studio/blog/bpm-house-music": ['bpm', 'house music', 'dj', 'mixing'],
    "https://dj.studio/blog/camelot-wheel": ['camelot wheel', 'mixing', 'dj', 'key'],
    "https://dj.studio/blog/guide-music-keygraph": ['music keygraph', 'key', 'mixing', 'dj'],
    "https://wearecrossfader.co.uk/blog/how-pro-djs-mix-house-tech-how-its-done/": ['pro techniques', 'house', 'mixing', 'dj']
}

# Kjør gjennom hver URL og prosesser dataene basert på tema
for url, important_words in urls_and_themes.items():
    key_sentences = extract_key_sentences(url, important_words)
    save_article_content(url, key_sentences, important_words)

print("Ekstraksjon og lagring av viktige setninger fullført.")

import requests
from bs4 import BeautifulSoup
import os

# Funksjon for å ekstrahere nøkkelsetninger fra en artikkel
def extract_key_sentences(article_url, important_words):
    response = requests.get(article_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    paragraphs = soup.find_all('p')
    extracted_sentences = []

    for paragraph in paragraphs:
        paragraph_text = paragraph.text.lower()
        if any(word in paragraph_text for word in important_words):
            extracted_sentences.append(paragraph.text.strip())
    return extracted_sentences

# Funksjon for å lagre artikkelinnholdet i en fil
def save_article_content(url, sentences, important_words):
    filename = url.split("/")[-1] + ".txt"
    save_path = f"/content/drive/My Drive/SuperDJ_Project/ai_super_dj/{filename}"

    with open(save_path, 'w', encoding='utf-8') as file:
        file.write(f"Nøkkelord brukt for utvalg: {', '.join(important_words)}\n\n")
        for sentence in sentences:
            file.write(sentence + '\n')

# Liste over lenker og spesifikke ordlister for hvert tema
articles_with_keywords = {
    "https://dj.studio/blog/dj-mixing-beginners": ['mixing', 'cue', 'bpm', 'transition'],
    "https://dj.studio/blog/auto-mixing": ['ai', 'automation', 'software', 'mixing'],
    "https://dj.studio/blog/ai-dj-software": ['ai', 'algorithm', 'dj', 'software', 'mixing'],
    "https://dj.studio/blog/best-dj-software-for-mac": ['software', 'platform', 'mixing', 'cue'],
    "https://dj.studio/blog/ai-mixing-apps": ['ai', 'software', 'mixing', 'automation'],
    "https://dj.studio/blog/dj-crossfade-techniques": ['crossfade', 'transition', 'dj', 'mixing'],
    "https://dj.studio/blog/dj-tempo-change-techniques": ['tempo', 'bpm', 'transition', 'mixing'],
    "https://dj.studio/blog/phrasing-dj-mixing": ['phrasing', 'mixing', 'transition', 'dj'],
    "https://dj.studio/blog/dj-cue-points": ['cue', 'points', 'dj', 'mixing'],
    "https://dj.studio/blog/dj-beatgridding": ['beatgridding', 'bpm', 'sync', 'dj'],
    "https://dj.studio/blog/dj-inspiration": ['inspiration', 'creativity', 'dj', 'mixing'],
    "https://dj.studio/blog/mixing-db-levels": ['db', 'mixing', 'volume', 'levels'],
    "https://dj.studio/blog/dj-with-spotify": ['spotify', 'mixing', 'streaming', 'dj'],
    "https://dj.studio/blog/beat-matching-app": ['beatmatching', 'app', 'bpm', 'dj'],
    "https://dj.studio/blog/dj-mixing-effects": ['effects', 'mixing', 'dj', 'transition'],
    "https://dj.studio/blog/dj-mix-songs": ['mix', 'songs', 'dj', 'bpm'],
    "https://dj.studio/blog/master-a-dj-mix": ['master', 'mixing', 'dj', 'track'],
    "https://dj.studio/blog/advanced-dj-mixing-techniques": ['advanced', 'mixing', 'techniques', 'dj'],
    "https://dj.studio/blog/bad-dj-mixing-mistakes": ['mistakes', 'mixing', 'dj', 'avoid'],
    "https://dj.studio/blog/basic-transition-techniques": ['basic', 'transition', 'techniques', 'mixing'],
    "https://dj.studio/blog/bpm-house-music": ['bpm', 'house', 'mixing', 'dj'],
    "https://dj.studio/blog/camelot-wheel": ['camelot', 'key', 'mixing', 'dj'],
    "https://dj.studio/blog/guide-music-keygraph": ['keygraph', 'key', 'mixing', 'dj'],
    "https://wearecrossfader.co.uk/blog/how-pro-djs-mix-house-tech-how-its-done/": ['pro', 'mix', 'house', 'dj'],
}

# Kjør gjennom hver URL og prosesser dataene med spesifikke ord
for url, important_words in articles_with_keywords.items():
    key_sentences = extract_key_sentences(url, important_words)
    save_article_content(url, key_sentences, important_words)

print("Ekstraksjon og lagring av viktige setninger fra DJ-artiklene fullført.")

import os

# Liste over nøkkelord for hver type artikkel
keywords = {
    'dj_mixing_beginners': ['mixing', 'bpm', 'cueing', 'transition', 'looping'],
    'ai_dj_software': ['ai', 'automation', 'mixing', 'software', 'algorithm'],
    'dj_mixing_techniques': ['crossfade', 'phrasing', 'tempo', 'mixing', 'cue', 'effect'],
    'best_dj_software': ['software', 'platform', 'mixing', 'sync', 'cue'],
    # Legg til flere kategorier og nøkkelord for hver fil om nødvendig
}

# Sti til mappen med tekstfiler
input_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Sjekk om nøkkelordene finnes i filene
def check_keywords_in_files(keywords, input_dir):
    for filename in os.listdir(input_dir):
        if filename.endswith('.txt'):
            file_path = os.path.join(input_dir, filename)
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().lower()  # Gjør alt til små bokstaver for konsistens
                for category, words in keywords.items():
                    if category in filename:  # Sjekk om filen hører til riktig kategori
                        print(f'\nSjekker filen: {filename}')
                        for word in words:
                            print(f'Er "{word}" til stede: {word in content}')

# Kjør sjekken
check_keywords_in_files(keywords, input_dir)

import os
import shutil
from urllib.request import urlopen
from bs4 import BeautifulSoup

# Angi stien til den eksisterende mappen med gamle filer
old_files_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Angi stien til mappen hvor de nye oppdaterte filene skal lagres
new_files_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj_updated'

# Hvis mappen for oppdaterte filer ikke eksisterer, opprett den
if not os.path.exists(new_files_dir):
    os.makedirs(new_files_dir)

# Liste over URL-er som du ønsker å hente innhold fra
urls = [
    "https://dj.studio/blog/dj-mixing-beginners",
    "https://dj.studio/blog/auto-mixing",
    "https://dj.studio/blog/ai-dj-software",
    # Legg til resten av URL-ene her
]

# Funksjon for å hente og lagre innhold fra URL-er
def fetch_and_save_content(url, output_dir):
    try:
        response = urlopen(url)
        html = response.read()
        soup = BeautifulSoup(html, 'html.parser')

        # Hent teksten fra nettsiden
        content = soup.get_text()

        # Lagre filen med samme navn som tittelen fra nettsiden
        title = soup.title.string.strip().replace(' ', '_').lower()
        file_path = os.path.join(output_dir, f"{title}_processed.txt")

        with open(file_path, 'w', encoding='utf-8') as file:
            file.write(content)
            print(f"Innhold fra {url} er lagret i {file_path}")
    except Exception as e:
        print(f"Kunne ikke hente {url}: {e}")

# Funksjon for å flytte gamle filer til en backup-mappe
def backup_old_files(old_dir, backup_dir):
    if not os.path.exists(backup_dir):
        os.makedirs(backup_dir)

    for filename in os.listdir(old_dir):
        file_path = os.path.join(old_dir, filename)
        if os.path.isfile(file_path):
            shutil.move(file_path, os.path.join(backup_dir, filename))
            print(f"Flyttet gammel fil {filename} til backup-mappen.")

# Funksjon for å sjekke og oppdatere filer i henhold til nye nøkkelord
def update_files_with_keywords(new_dir):
    keywords = {
        'dj_mixing_beginners': ['mixing', 'bpm', 'cueing', 'transition', 'looping'],
        'dj_mixing_techniques': ['crossfade', 'phrasing', 'tempo', 'mixing', 'cue', 'effect'],
        'best_dj_software_for_mac': ['software', 'platform', 'dj', 'sync', 'cue'],
        # Legg til flere kategorier med nøkkelord her
    }

    for filename in os.listdir(new_dir):
        if filename.endswith('.txt'):
            category = filename.split('_processed')[0]
            if category in keywords:
                with open(os.path.join(new_dir, filename), 'r+', encoding='utf-8') as file:
                    content = file.read().lower()
                    for word in keywords[category]:
                        if word not in content:
                            file.write(f"\n{word}")  # Legg til ord som mangler
                            print(f"La til nøkkelord '{word}' i {filename}")

# Steg 1: Hent og lagre innhold fra de oppgitte URL-ene
for url in urls:
    fetch_and_save_content(url, new_files_dir)

# Steg 2: Flytt gamle filer til en backup-mappe



from google.colab import drive
drive.mount('/content/drive')

import requests
from bs4 import BeautifulSoup
import os

# Funksjon for å hente og lagre innhold fra en URL
def fetch_and_save_content(url, save_dir):
    response = requests.get(url)
    if response.status_code == 200:
        soup = BeautifulSoup(response.content, 'html.parser')
        paragraphs = soup.find_all('p')
        content = "\n".join([p.text for p in paragraphs])

        # Lagre innhold til fil
        filename = url.split("/")[-1] + "_processed.txt"
        save_path = os.path.join(save_dir, filename)
        with open(save_path, 'w', encoding='utf-8') as file:
            file.write(content)
    else:
        print(f"Kunne ikke hente {url}: HTTP Error {response.status_code}: {response.reason}")

# Funksjon for å sjekke og oppdatere filene med nøkkelord
def check_and_add_keywords(file_dir, keywords_by_article):
    for filename in os.listdir(file_dir):
        if filename.endswith('.txt'):
            file_path = os.path.join(file_dir, filename)
            with open(file_path, 'r+', encoding='utf-8') as file:
                content = file.read().lower()
                article_name = filename.split("_processed.txt")[0]
                if article_name in keywords_by_article:
                    keywords = keywords_by_article[article_name]
                    for word in keywords:
                        if word not in content:
                            file.write(f"\n{word}")
                            print(f"La til nøkkelord '{word}' i {filename}")

# Nøkkelord for hvert tema/artikkel
keywords_by_article = {
    "dj-mixing-beginners": ["mixing", "bpm", "cueing", "transition", "looping"],
    "auto-mixing": ["automation", "software", "AI", "algorithm", "mixing"],
    "ai-dj-software": ["AI", "automation", "algorithm", "software", "mixing"],
    "best-dj-software-for-mac": ["software", "platform", "sync", "cue"],
    "ai-mixing-apps": ["AI", "mixing", "automation", "apps", "algorithm"],
    "dj-crossfade-techniques": ["crossfade", "transition", "mixing", "smooth", "levels"],
    "dj-tempo-change-techniques": ["tempo", "transition", "mixing", "sync", "bpm"],
    "phrasing-dj-mixing": ["phrasing", "timing", "mixing", "transition", "flow"],
    "dj-cue-points": ["cue", "cueing", "timing", "mixing", "transitions"],
    "dj-beatgridding": ["beatgrid", "timing", "sync", "bpm", "grid"],
    "dj-inspiration": ["inspiration", "creativity", "music", "mixing", "ideas"],
    "mixing-db-levels": ["db", "levels", "volume", "mixing", "balance"],
    "dj-with-spotify": ["spotify", "streaming", "music", "djing", "playlist"],
    "beat-matching-app": ["beatmatching", "sync", "bpm", "cue", "mixing"],
    "dj-mixing-effects": ["effects", "mixing", "filters", "transitions", "volume"],
    "dj-mix-songs": ["mixing", "songs", "transitions", "flow", "cue"],
    "master-a-dj-mix": ["mastering", "mix", "cue", "volume", "balance"],
    "advanced-dj-mixing-techniques": ["advanced", "techniques", "mixing", "transitions", "beatmatching"],
    "bad-dj-mixing-mistakes": ["mistakes", "mixing", "timing", "cue", "sync"],
    "basic-transition-techniques": ["transitions", "mixing", "smooth", "cue", "flow"],
    "bpm-house-music": ["bpm", "house", "music", "mixing", "sync"],
    "camelot-wheel": ["camelot", "wheel", "key", "mixing", "transitions"],
    "guide-music-keygraph": ["keygraph", "music", "mixing", "bpm", "flow"],
    "how-pro-djs-mix-house-tech": ["pro", "house", "tech", "djing", "mixing"]
}

# Liste over artikler vi skal hente fra
urls = [
    "https://dj.studio/blog/dj-mixing-beginners",
    "https://dj.studio/blog/auto-mixing",
    "https://dj.studio/blog/ai-dj-software",
    "https://dj.studio/blog/best-dj-software-for-mac",
    "https://dj.studio/blog/ai-mixing-apps",
    "https://dj.studio/blog/dj-crossfade-techniques",
    "https://dj.studio/blog/dj-tempo-change-techniques",
    "https://dj.studio/blog/phrasing-dj-mixing",
    "https://dj.studio/blog/dj-cue-points",
    "https://dj.studio/blog/dj-beatgridding",
    "https://dj.studio/blog/dj-inspiration",
    "https://dj.studio/blog/mixing-db-levels",
    "https://dj.studio/blog/dj-with-spotify",
    "https://dj.studio/blog/beat-matching-app",
    "https://dj.studio/blog/dj-mixing-effects",
    "https://dj.studio/blog/dj-mix-songs",
    "https://dj.studio/blog/master-a-dj-mix",
    "https://dj.studio/blog/advanced-dj-mixing-techniques",
    "https://dj.studio/blog/bad-dj-mixing-mistakes",
    "https://dj.studio/blog/basic-transition-techniques",
    "https://dj.studio/blog/bpm-house-music",
    "https://dj.studio/blog/camelot-wheel",
    "https://dj.studio/blog/guide-music-keygraph",
    "https://wearecrossfader.co.uk/blog/how-pro-djs-mix-house-tech"
]

# Mappen der filene skal lagres
save_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Hent og lagre innhold fra alle URL-ene
for url in urls:
    fetch_and_save_content(url, save_dir)

# Sjekk og legg til manglende nøkkelord i filene
check_and_add_keywords(save_dir, keywords_by_article)

print("Prosesseringen er fullført.")

import os

# Mappen der filene ligger
save_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Nøkkelord for hver fil/artikkel
keywords_by_article = {
    "dj-mixing-beginners": ["mixing", "bpm", "cueing", "transition", "looping"],
    "auto-mixing": ["automation", "software", "AI", "algorithm", "mixing"],
    "ai-dj-software": ["AI", "automation", "algorithm", "software", "mixing"],
    "best-dj-software-for-mac": ["software", "platform", "sync", "cue"],
    "ai-mixing-apps": ["AI", "mixing", "automation", "apps", "algorithm"],
    "dj-crossfade-techniques": ["crossfade", "transition", "mixing", "smooth", "levels"],
    "dj-tempo-change-techniques": ["tempo", "transition", "mixing", "sync", "bpm"],
    "phrasing-dj-mixing": ["phrasing", "timing", "mixing", "transition", "flow"],
    "dj-cue-points": ["cue", "cueing", "timing", "mixing", "transitions"],
    "dj-beatgridding": ["beatgrid", "timing", "sync", "bpm", "grid"],
    "dj-inspiration": ["inspiration", "creativity", "music", "mixing", "ideas"],
    "mixing-db-levels": ["db", "levels", "volume", "mixing", "balance"],
    "dj-with-spotify": ["spotify", "streaming", "music", "djing", "playlist"],
    "beat-matching-app": ["beatmatching", "sync", "bpm", "cue", "mixing"],
    "dj-mixing-effects": ["effects", "mixing", "filters", "transitions", "volume"],
    "dj-mix-songs": ["mixing", "songs", "transitions", "flow", "cue"],
    "master-a-dj-mix": ["mastering", "mix", "cue", "volume", "balance"],
    "advanced-dj-mixing-techniques": ["advanced", "techniques", "mixing", "transitions", "beatmatching"],
    "bad-dj-mixing-mistakes": ["mistakes", "mixing", "timing", "cue", "sync"],
    "basic-transition-techniques": ["transitions", "mixing", "smooth", "cue", "flow"],
    "bpm-house-music": ["bpm", "house", "music", "mixing", "sync"],
    "camelot-wheel": ["camelot", "wheel", "key", "mixing", "transitions"],
    "guide-music-keygraph": ["keygraph", "music", "mixing", "bpm", "flow"],
    "how-pro-djs-mix-house-tech": ["pro", "house", "tech", "djing", "mixing"]
}

# Funksjon for å sjekke om alle nøkkelord er i filene
def verify_keywords_in_files(file_dir, keywords_by_article):
    missing_keywords = []

    for filename in os.listdir(file_dir):
        if filename.endswith('.txt'):
            file_path = os.path.join(file_dir, filename)
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read().lower()
                article_name = filename.split("_processed.txt")[0]

                if article_name in keywords_by_article:
                    keywords = keywords_by_article[article_name]
                    for word in keywords:
                        if word not in content:
                            missing_keywords.append((filename, word))

    return missing_keywords

# Sjekk filene
missing_keywords = verify_keywords_in_files(save_dir, keywords_by_article)

# Skriv ut resultatet
if missing_keywords:
    for filename, word in missing_keywords:
        print(f"Nøkkelordet '{word}' mangler i filen: {filename}")
else:
    print("Alle nøkkelordene er til stede i filene.")

import requests
from bs4 import BeautifulSoup
import os

# Funksjon for å hente og lagre innhold fra en URL
def fetch_and_save_content(url, save_dir):
    response = requests.get(url)
    if response.status_code == 200:
        soup = BeautifulSoup(response.content, 'html.parser')
        paragraphs = soup.find_all('p')
        content = "\n".join([p.text for p in paragraphs])

        # Lagre innhold til fil
        filename = url.split("/")[-1] + "_processed.txt"
        save_path = os.path.join(save_dir, filename)
        with open(save_path, 'w', encoding='utf-8') as file:
            file.write(content)
    else:
        print(f"Kunne ikke hente {url}: HTTP Error {response.status_code}: {response.reason}")

# Funksjon for å sjekke om viktige ord er til stede i filene og legge til manglende ord
def check_and_add_keywords(file_dir, keywords_by_article):
    for filename in os.listdir(file_dir):
        if filename.endswith('.txt'):
            file_path = os.path.join(file_dir, filename)
            with open(file_path, 'r+', encoding='utf-8') as file:
                content = file.read().lower()
                article_name = filename.split("_processed.txt")[0]
                if article_name in keywords_by_article:
                    keywords = keywords_by_article[article_name]
                    for word in keywords:
                        if word not in content:
                            file.write(f"\n{word}")
                            print(f"La til nøkkelord '{word}' i {filename}")

# Definer temaer og relevante ord for hver artikkel
keywords_by_article = {
    "dj-mixing-beginners": ["mixing", "bpm", "cueing", "transition", "looping"],
    "auto-mixing": ["automation", "software", "AI", "algorithm", "mixing"],
    "ai-dj-software": ["AI", "automation", "algorithm", "software", "mixing"],
    "best-dj-software-for-mac": ["software", "platform", "sync", "cue"],
    "ai-mixing-apps": ["AI", "mixing", "automation", "apps", "algorithm"],
    "dj-crossfade-techniques": ["crossfade", "transition", "mixing", "smooth", "levels"],
    "dj-tempo-change-techniques": ["tempo", "transition", "mixing", "sync", "bpm"],
    "phrasing-dj-mixing": ["phrasing", "timing", "mixing", "transition", "flow"],
    "dj-cue-points": ["cue", "cueing", "timing", "mixing", "transitions"],
    "dj-beatgridding": ["beatgrid", "timing", "sync", "bpm", "grid"],
    "dj-inspiration": ["inspiration", "creativity", "music", "mixing", "ideas"],
    "mixing-db-levels": ["db", "levels", "volume", "mixing", "balance"],
    "dj-with-spotify": ["spotify", "streaming", "music", "djing", "playlist"],
    "beat-matching-app": ["beatmatching", "sync", "bpm", "cue", "mixing"],
    "dj-mixing-effects": ["effects", "mixing", "filters", "transitions", "volume"],
    "dj-mix-songs": ["mixing", "songs", "transitions", "flow", "cue"],
    "master-a-dj-mix": ["mastering", "mix", "cue", "volume", "balance"],
    "advanced-dj-mixing-techniques": ["advanced", "techniques", "mixing", "transitions", "beatmatching"],
    "bad-dj-mixing-mistakes": ["mistakes", "beatmatching", "mixing", "sync", "timing"],
    "basic-transition-techniques": ["transition", "basic", "mixing", "bpm", "cue"],
    "bpm-house-music": ["bpm", "house", "music", "mixing", "beats"],
    "camelot-wheel": ["camelot", "key", "wheel", "mixing", "harmonic"],
    "guide-music-keygraph": ["keygraph", "mixing", "harmonic", "key", "music"],
    "how-pro-djs-mix-house-tech": ["house", "tech", "djs", "mixing", "transition"]
}

# Sti til mappen med tekstfiler
input_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Kjøre sjekk og oppdatere filene
check_and_add_keywords(input_dir, keywords_by_article)

print("Nøkkelord sjekket og filene oppdatert der det var nødvendig.")

import requests
from bs4 import BeautifulSoup
import os

# Funksjon for å hente og lagre innhold fra en URL
def fetch_and_save_content(url, save_dir):
    response = requests.get(url)
    if response.status_code == 200:
        soup = BeautifulSoup(response.content, 'html.parser')
        paragraphs = soup.find_all('p')
        content = "\n".join([p.text for p in paragraphs])

        # Lagre innhold til fil
        filename = url.split("/")[-1] + "_processed.txt"
        save_path = os.path.join(save_dir, filename)
        with open(save_path, 'w', encoding='utf-8') as file:
            file.write(content)
    else:
        print(f"Kunne ikke hente {url}: HTTP Error {response.status_code}: {response.reason}")

# Funksjon for å sjekke om viktige ord er til stede i filene og legge til manglende ord
def check_and_add_keywords(file_dir, keywords_by_article):
    for filename in os.listdir(file_dir):
        if filename.endswith('.txt'):
            file_path = os.path.join(file_dir, filename)
            with open(file_path, 'r+', encoding='utf-8') as file:
                content = file.read().lower()
                article_name = filename.split("_processed.txt")[0]
                if article_name in keywords_by_article:
                    keywords = keywords_by_article[article_name]
                    for word in keywords:
                        if word not in content:
                            file.write(f"\n{word}")
                            print(f"La til nøkkelord '{word}' i {filename}")

# Definer temaer og relevante ord for hver artikkel
keywords_by_article = {
    "dj-mixing-beginners": ["mixing", "bpm", "cueing", "transition", "looping"],
    "auto-mixing": ["automation", "software", "AI", "algorithm", "mixing"],
    "ai-dj-software": ["AI", "automation", "algorithm", "software", "mixing"],
    "best-dj-software-for-mac": ["software", "platform", "sync", "cue"],
    "ai-mixing-apps": ["AI", "mixing", "automation", "apps", "algorithm"],
    "dj-crossfade-techniques": ["crossfade", "transition", "mixing", "smooth", "levels"],
    "dj-tempo-change-techniques": ["tempo", "transition", "mixing", "sync", "bpm"],
    "phrasing-dj-mixing": ["phrasing", "timing", "mixing", "transition", "flow"],
    "dj-cue-points": ["cue", "cueing", "timing", "mixing", "transitions"],
    "dj-beatgridding": ["beatgrid", "timing", "sync", "bpm", "grid"],
    "dj-inspiration": ["inspiration", "creativity", "music", "mixing", "ideas"],
    "mixing-db-levels": ["db", "levels", "volume", "mixing", "balance"],
    "dj-with-spotify": ["spotify", "streaming", "music", "djing", "playlist"],
    "beat-matching-app": ["beatmatching", "sync", "bpm", "cue", "mixing"],
    "dj-mixing-effects": ["effects", "mixing", "filters", "transitions", "volume"],
    "dj-mix-songs": ["mixing", "songs", "transitions", "flow", "cue"],
    "master-a-dj-mix": ["mastering", "mix", "cue", "volume", "balance"],
    "advanced-dj-mixing-techniques": ["advanced", "techniques", "mixing", "transitions", "beatmatching"],
    "bad-dj-mixing-mistakes": ["mistakes", "beatmatching", "mixing", "sync", "timing"],
    "basic-transition-techniques": ["transition", "basic", "mixing", "bpm", "cue"],
    "bpm-house-music": ["bpm", "house", "music", "mixing", "beats"],
    "camelot-wheel": ["camelot", "key", "wheel", "mixing", "harmonic"],
    "guide-music-keygraph": ["keygraph", "mixing", "harmonic", "key", "music"],
    "how-pro-djs-mix-house-tech": ["house", "tech", "djs", "mixing", "transition"]
}

# Liste over URL-er
urls = [
    "https://dj.studio/blog/dj-mixing-beginners",
    "https://dj.studio/blog/auto-mixing",
    "https://dj.studio/blog/ai-dj-software",
    "https://dj.studio/blog/best-dj-software-for-mac",
    "https://dj.studio/blog/ai-mixing-apps",
    "https://dj.studio/blog/dj-crossfade-techniques",
    "https://dj.studio/blog/dj-tempo-change-techniques",
    "https://dj.studio/blog/phrasing-dj-mixing",
    "https://dj.studio/blog/dj-cue-points",
    "https://dj.studio/blog/dj-beatgridding",
    "https://dj.studio/blog/dj-inspiration",
    "https://dj.studio/blog/mixing-db-levels",
    "https://dj.studio/blog/dj-with-spotify",
    "https://dj.studio/blog/beat-matching-app",
    "https://dj.studio/blog/dj-mixing-effects",
    "https://dj.studio/blog/dj-mix-songs",
    "https://dj.studio/blog/master-a-dj-mix",
    "https://dj.studio/blog/advanced-dj-mixing-techniques",
    "https://dj.studio/blog/bad-dj-mixing-mistakes",
    "https://dj.studio/blog/basic-transition-techniques",
    "https://dj.studio/blog/bpm-house-music",
    "https://dj.studio/blog/camelot-wheel",
    "https://dj.studio/blog/guide-music-keygraph",
    "https://wearecrossfader.co.uk/blog/how-pro-djs-mix-house-tech-how-its-done"
]

# Opprett en mappe for å lagre filene
save_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'
os.makedirs(save_dir, exist_ok=True)

# Hent og lagre innholdet fra alle URL-ene
for url in urls:
    fetch_and_save_content(url, save_dir)

# Sjekk og legg til nøkkelordene der det er nødvendig
check_and_add_keywords(save_dir, keywords_by_article)

print("Nøkkelordene er sjekket og filene er oppdatert.")

from gensim.models import Word2Vec
import os

# Steg 1: Samle alle setninger fra filene
def gather_sentences_from_files(file_dir):
    sentences = []
    for filename in os.listdir(file_dir):
        if filename.endswith('.txt'):
            file_path = os.path.join(file_dir, filename)
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read().splitlines()
                for line in content:
                    sentences.append(line.split())  # Del hver setning i ord
    return sentences

# Steg 2: Tren Word2Vec-modellen
def train_word2vec(sentences):
    model = Word2Vec(sentences, vector_size=100, window=5, min_count=1, workers=4)
    return model

# Steg 3: Lagre modellen for senere bruk
def save_model(model, model_path):
    model.save(model_path)
    print(f"Modellen er lagret på {model_path}")

# Sti til mappen med tekstfiler
input_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Samle setninger og tren modellen
sentences = gather_sentences_from_files(input_dir)
model = train_word2vec(sentences)

# Lagre modellen
model_save_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model.model'
save_model(model, model_save_path)

# Steg 4: Test modellen med noen viktige DJ-ord
test_words = ['mixing', 'bpm', 'cue', 'sync', 'crossfade']
for word in test_words:
    if word in model.wv:
        print(f"Lignende ord til '{word}': {model.wv.most_similar(word)}")
    else:
        print(f"'{word}' finnes ikke i modellens vokabular.")

import os

# Utvidet ordliste for DJ-relaterte termer
dj_terms = [
    'mixing', 'crossfade', 'bpm', 'cueing', 'transition', 'looping',
    'beatmatching', 'sync', 'tempo', 'phrasing', 'effects', 'harmonic',
    'volume', 'filters', 'key', 'gridding', 'timing', 'levels',
    'audio', 'db', 'balance', 'streaming', 'mastering', 'track',
    'song', 'playlist', 'automation', 'algorithm', 'software'
]

# Funksjon for å sjekke og oppdatere filene med viktige DJ-relaterte ord
def check_and_update_files(file_dir, dj_terms):
    for filename in os.listdir(file_dir):
        if filename.endswith('.txt'):
            file_path = os.path.join(file_dir, filename)
            with open(file_path, 'r+', encoding='utf-8') as file:
                content = file.read().lower()
                for term in dj_terms:
                    if term not in content:
                        file.write(f"\n{term}")  # Legger til manglende DJ-relatert term
                        print(f"La til nøkkelord '{term}' i {filename}")

# Sti til mappen med tekstfiler
file_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Kjør sjekken og oppdateringen
check_and_update_files(file_dir, dj_terms)

print("Filene er sjekket og oppdatert der det var nødvendig.")

import os
from gensim.models import Word2Vec

# Funksjon for å laste inn tekstfilene og forberede dataene for modelltrening
def load_and_prepare_texts(input_dir):
    all_sentences = []
    for filename in os.listdir(input_dir):
        if filename.endswith('.txt'):
            file_path = os.path.join(input_dir, filename)
            with open(file_path, 'r', encoding='utf-8') as f:
                tokens = f.read().split()  # Splitt tekstene i ord
                all_sentences.append(tokens)  # Legg til ordlistene for modelltrening
    return all_sentences

# Sti til mappen med tekstfiler
input_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Last inn og forbered dataene
all_sentences = load_and_prepare_texts(input_dir)

# Tren modellen med de oppdaterte tekstene
model = Word2Vec(sentences=all_sentences, vector_size=100, window=5, min_count=1, workers=4)

# Lagre den finjusterte modellen
model_save_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model_finetuned.model'
model.save(model_save_path)

print("Modellen er finjustert og lagret.")

# Last inn modellen
from gensim.models import Word2Vec
model = Word2Vec.load('/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model.model')

# Sjekk lignende ord for noen viktige DJ-relaterte ord
similar_words = model.wv.most_similar('mixing')
print(f'Lignende ord til "mixing": {similar_words}')

# Last inn den finjusterte modellen
from gensim.models import Word2Vec

model_save_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model.model'
model = Word2Vec.load(model_save_path)

# Liste opp de første 100 ordene i ordforrådet
vocabulary = list(model.wv.index_to_key)
print(vocabulary[:100])  # Skriver ut de første 100 ordene

from gensim.models import Word2Vec
import os

# Last inn den oppdaterte modellen
model_save_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model.model'
model = Word2Vec.load(model_save_path)

# Definer DJ-relaterte begreper for å sjekke lignende ord
dj_terms = ['mixing', 'crossfade', 'bpm', 'cueing', 'transition', 'looping',
            'beatmatching', 'sync', 'phrasing', 'filters', 'volume', 'harmonic',
            'mastering', 'automation', 'algorithm', 'streaming', 'playlist']

# Kjør lignende ord-søk for hvert begrep i listen
for term in dj_terms:
    if term in model.wv.index_to_key:
        similar_words = model.wv.most_similar(term)
        print(f'Lignende ord til "{term}":', similar_words)
    else:
        print(f'Ordet "{term}" finnes ikke i modellens ordforråd.')

# Evaluering av modellens forståelse av relasjoner mellom DJ-begreper
def evaluate_model(model):
    # Eksempel: Sjekk hvor nært 'mixing' er relatert til 'sync'
    similarity = model.wv.similarity('mixing', 'sync')
    print(f'Relasjonen mellom "mixing" og "sync": {similarity}')

    # Eksempel: Finne ord som er lik 'mixing' kombinert med 'sync' (positive), men ulik 'automation' (negative)
    analogy_result = model.wv.most_similar(positive=['mixing', 'sync'], negative=['automation'])
    print(f'Analogi-resultat for "mixing" + "sync" - "automation": {analogy_result}')

# Kjør evaluering av modellen
evaluate_model(model)

!pip install nltk
import nltk
nltk.download('stopwords')

from nltk.corpus import stopwords
import os

# Hent listen over stoppord fra NLTK
stop_words = set(stopwords.words('english'))

# Funksjon for å fjerne stoppord fra en tekst
def remove_stopwords(text):
    words = text.split()
    filtered_words = [word for word in words if word.lower() not in stop_words]
    return ' '.join(filtered_words)

# Sti til mappen med tekstfiler
input_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Kjør gjennom alle filene i katalogen og fjern stoppord
for filename in os.listdir(input_dir):
    if filename.endswith('.txt'):
        file_path = os.path.join(input_dir, filename)
        with open(file_path, 'r', encoding='utf-8') as file:
            content = file.read()
            content_without_stopwords = remove_stopwords(content)

        # Lagre den filtrerte teksten tilbake i filen
        with open(file_path, 'w', encoding='utf-8') as file:
            file.write(content_without_stopwords)

print("Stoppord er fjernet fra alle filer.")

from gensim.models import Word2Vec
import os

# Les inn alle tekstfilene og legg til i en liste for trening
def load_texts(input_dir):
    texts = []
    for filename in os.listdir(input_dir):
        if filename.endswith('.txt'):
            file_path = os.path.join(input_dir, filename)
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read().split()  # Del teksten inn i ord
                texts.append(content)
    return texts

# Sti til mappen med tekstfiler
input_dir = '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'

# Last inn tekstene
training_data = load_texts(input_dir)

# Trene Word2Vec-modellen
model = Word2Vec(sentences=training_data, vector_size=100, window=5, min_count=1, workers=4)
model_save_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model_no_stopwords.model'
model.save(model_save_path)

print(f"Modellen er trent og lagret på {model_save_path}")

# Last inn den nye modellen
model = Word2Vec.load(model_save_path)

# Finn lignende ord for noen viktige DJ-termer
important_terms = ['mixing', 'cue', 'bpm', 'transition', 'sync', 'crossfade']

for term in important_terms:
    if term in model.wv.index_to_key:
        print(f"Lignende ord til '{term}': {model.wv.most_similar(term)}")
    else:
        print(f"Ordet '{term}' finnes ikke i modellens ordforråd.")

from gensim.models import Word2Vec

# Last inn modellen uten stoppord
model_save_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model_no_stopwords.model'
model = Word2Vec.load(model_save_path)

# Liste over DJ-relaterte ord å utforske
dj_terms = ['mixing', 'crossfade', 'bpm', 'cueing', 'transition', 'looping', 'beatmatching', 'sync']

# Utforsk relasjoner for hvert DJ-ord
for term in dj_terms:
    if term in model.wv.index_to_key:  # Sjekk om ordet finnes i ordforrådet
        similar_words = model.wv.most_similar(term)
        print(f'Lignende ord til "{term}": {similar_words}')
    else:
        print(f'Ordet "{term}" finnes ikke i modellens ordforråd.')

import os

# Sett opp stien til prosjektet ditt
project_dir = "/content/drive/MyDrive/SuperDJ_Project"

# Gå gjennom alle filer og underkataloger og finn mp3-filer
for root, dirs, files in os.walk(project_dir):
    for file in files:
        if file.endswith(".mp3"):
            print(os.path.join(root, file))

import librosa

# Skriv inn den eksakte filbanen til filen du vil analysere
audio_file_path = "/content/drive/MyDrive/SuperDJ_Project/music_library/16449902_Own Methods (Extended Mix)_(Original Mix).mp3"

# Last inn lydfilen med librosa
try:
    y, sr = librosa.load(audio_file_path, sr=None)
    print(f"Lydfil lastet inn: {audio_file_path}")

    # Beregn tempo (BPM)
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
    print(f"BPM: {tempo}")

    # Estimer tonalitet (chroma features)
    chroma = librosa.feature.chroma_stft(y=y, sr=sr)
    print("Chroma features extracted.")

except Exception as e:
    print(f"Feil ved lasting av lydfilen: {e}")

import glob

# Søk etter MP3-filer i hele Google Drive-mappen din
mp3_files = glob.glob('/content/drive/My Drive/SuperDJ_Project/music_library/**/*.mp3', recursive=True)

# Skriv ut alle filstier
for mp3_file in mp3_files:
    print(mp3_file)

import librosa
import glob

# Søk etter MP3-filer i hele Google Drive-mappen din
mp3_files = glob.glob('/content/drive/My Drive/SuperDJ_Project/music_library/**/*.mp3', recursive=True)

# Skriv ut alle filstier
print("Liste over MP3-filer i Google Drive:")
for mp3_file in mp3_files:
    print(mp3_file)

# Sett inn riktig filsti fra listen over
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/16449902_Own Methods (Extended Mix)_(Original Mix).mp3'

try:
    # Last inn lydfilen med Librosa
    y, sr = librosa.load(audio_file_path)
    print(f"Lydfil lastet inn: {audio_file_path}")

    # Beregn tempo (BPM)
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
    print(f"BPM: {tempo}")

    # Estimer tonalitet (chroma features)
    chroma = librosa.feature.chroma_stft(y=y, sr=sr)
    print("Chroma features extracted.")

except Exception as e:
    print(f"Feil ved lasting av lydfilen: {e}")

# Filsti direkte fra listen over mp3-filer som du fant
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

try:
    # Last inn lydfil
    y, sr = librosa.load(audio_file_path)
    print(f"Lydfil lastet inn: {audio_file_path}")

    # Beregn tempo (BPM)
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
    print(f"BPM: {tempo}")

    # Estimer tonalitet (chroma features)
    chroma = librosa.feature.chroma_stft(y=y, sr=sr)
    print("Chroma features extracted.")

except Exception as e:
    print(f"Feil ved lasting av lydfilen: {e}")

# Last inn og sjekk Word2Vec-modellen for viktige DJ-relaterte ord
from gensim.models import Word2Vec

model_save_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model.model'
model = Word2Vec.load(model_save_path)

# Liste over viktige DJ-relaterte ord
dj_terms = ['mixing', 'bpm', 'cue', 'transition', 'looping', 'beatmatching', 'sync', 'crossfade']

# Sjekk om disse ordene finnes i modellen
for term in dj_terms:
    if term in model.wv:
        print(f"{term} finnes i modellen.")
    else:
        print(f"{term} mangler i modellen.")

# Last inn den finjusterte modellen
from gensim.models import Word2Vec

# Sti til den siste lagrede modellen
model_save_path = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/word2vec_model_no_stopwords.model'
model = Word2Vec.load(model_save_path)

# Liste over viktige DJ-relaterte ord vi ønsker å sjekke
dj_terms = ['mixing', 'bpm', 'cueing', 'sync', 'crossfade', 'looping', 'beatmatching', 'phrasing', 'effects', 'transition', 'harmonic']

# Sjekk lignende ord for hvert DJ-term
for term in dj_terms:
    if term in model.wv:
        print(f'Lignende ord til "{term}": {model.wv.most_similar(term)}\n')
    else:
        print(f'Ord "{term}" er ikke i modellen.\n')

# Super AI DJ: Implementering av avanserte DJ-teknikker i Python

import librosa
import soundfile as sf
import numpy as np
from scipy.signal import butter, lfilter

# 1. Mixing
def mix_tracks(track1, track2, output_file):
    y1, sr1 = librosa.load(track1)
    y2, sr2 = librosa.load(track2)
    mixed = y1 + y2[:len(y1)]
    sf.write(output_file, mixed, sr1)

# 2. Cueing
def set_cue_point(track, cue_time):
    y, sr = librosa.load(track)
    cue_sample = int(cue_time * sr)
    return y[cue_sample:]

# 3. BPM (Beats Per Minute) og Beatmatching
def detect_bpm(track):
    y, sr = librosa.load(track)
    tempo, _ = librosa.beat.beat_track(y, sr=sr)
    return tempo

def beatmatch(track1, track2):
    bpm1 = detect_bpm(track1)
    bpm2 = detect_bpm(track2)
    rate = bpm1 / bpm2
    y2, sr = librosa.load(track2)
    y2_stretched = librosa.effects.time_stretch(y2, rate)
    return y2_stretched

# 4. Crossfade
def crossfade(track1, track2, fade_duration, output_file):
    y1, sr1 = librosa.load(track1)
    y2, sr2 = librosa.load(track2)
    fade_samples = int(fade_duration * sr1)
    y1[-fade_samples:] *= np.linspace(1, 0, fade_samples)
    y2[:fade_samples] *= np.linspace(0, 1, fade_samples)
    crossfaded = np.concatenate([y1, y2])
    sf.write(output_file, crossfaded, sr1)

# 5. Looping
def loop_track(track, start_time, end_time, loops):
    y, sr = librosa.load(track)
    start_sample = int(start_time * sr)
    end_sample = int(end_time * sr)
    loop_segment = y[start_sample:end_sample]
    looped = np.tile(loop_segment, loops)
    return looped

# 6. Effects (FX) - Reverb og Delay
def apply_reverb_and_delay(track, reverb_amount, delay_amount, output_file):
    y, sr = librosa.load(track)
    y_reverb = librosa.effects.preemphasis(y) * reverb_amount
    y_delay = np.roll(y, int(delay_amount * sr))
    y_with_effects = y + y_reverb + y_delay
    sf.write(output_file, y_with_effects, sr)

# 7. EQ-ing
def apply_eq(track, low_gain, mid_gain, high_gain, output_file):
    y, sr = librosa.load(track)
    y_low = butter_bandpass_filter(y, 20, 300, sr) * low_gain
    y_mid = butter_bandpass_filter(y, 300, 3000, sr) * mid_gain
    y_high = butter_bandpass_filter(y, 3000, 20000, sr) * high_gain
    y_eq = y_low + y_mid + y_high
    sf.write(output_file, y_eq, sr)

def butter_bandpass_filter(data, lowcut, highcut, fs, order=5):
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    y = lfilter(b, a, data)
    return y

# 8. Live Remixing og Sampling
def live_remix(tracks, output_file):
    remixed = []
    for track in tracks:
        y, sr = librosa.load(track)
        remixed.append(y[:len(y)//2])
    remixed_mix = np.concatenate(remixed)
    sf.write(output_file, remixed_mix, sr)

def extract_sample(track, start_time, duration, output_file):
    y, sr = librosa.load(track)
    start_sample = int(start_time * sr)
    end_sample = start_sample + int(duration * sr)
    y_sample = y[start_sample:end_sample]
    sf.write(output_file, y_sample, sr)

# 9. Timestretching og Warping
def apply_warping(track, tempo_change, output_file):
    y, sr = librosa.load(track)
    y_warped = librosa.effects.time_stretch(y, tempo_change)
    sf.write(output_file, y_warped, sr)

# 10. Crowd Interaction
def adjust_music_based_on_crowd(crowd_energy, tracks):
    track_energies = {track: calculate_energy(track) for track in tracks}
    selected_track = min(track_energies, key=lambda t: abs(track_energies[t] - crowd_energy))
    return selected_track

def calculate_energy(track):
    y, sr = librosa.load(track)
    onset_env = librosa.onset.onset_strength(y=y, sr=sr)
    return np.sum(onset_env)

# 11. Sonic Branding
def create_sonic_branding(track, signature_sound, output_file):
    y, sr = librosa.load(track)
    y_signature, _ = librosa.load(signature_sound)
    branded = y + y_signature[:len(y)]
    sf.write(output_file, branded, sr)

import librosa
import soundfile as sf
import numpy as np

# 1. Mixing
def mix_tracks(track1, track2, output_file):
    y1, sr1 = librosa.load(track1)
    y2, sr2 = librosa.load(track2)
    mixed = y1 + y2[:len(y1)]
    sf.write(output_file, mixed, sr1)

# 2. Cueing
def set_cue_point(track, cue_time):
    y, sr = librosa.load(track)
    cue_sample = int(cue_time * sr)
    return y[cue_sample:]

# 3. BPM (Beats Per Minute)
def detect_bpm(track):
    y, sr = librosa.load(track)
    tempo, _ = librosa.beat.beat_track(y, sr=sr)
    return tempo

# 4. Beatmatching
def beatmatch(track1, track2):
    bpm1 = detect_bpm(track1)
    bpm2 = detect_bpm(track2)
    rate = bpm1 / bpm2
    y2, sr = librosa.load(track2)
    y2_stretched = librosa.effects.time_stretch(y2, rate)
    return y2_stretched

# 5. Crossfade
def crossfade(track1, track2, fade_duration, output_file):
    y1, sr1 = librosa.load(track1)
    y2, sr2 = librosa.load(track2)
    fade_samples = int(fade_duration * sr1)
    y1[-fade_samples:] *= np.linspace(1, 0, fade_samples)
    y2[:fade_samples] *= np.linspace(0, 1, fade_samples)
    crossfaded = np.concatenate([y1, y2])
    sf.write(output_file, crossfaded, sr1)

# 6. Looping
def loop_track(track, start_time, end_time, loops):
    y, sr = librosa.load(track)
    start_sample = int(start_time * sr)
    end_sample = int(end_time * sr)
    loop_segment = y[start_sample:end_sample]
    looped = np.tile(loop_segment, loops)
    return looped

# 7. Effects (FX)
def apply_reverb(track, output_file):
    y, sr = librosa.load(track)
    y_reverb = librosa.effects.preemphasis(y)
    sf.write(output_file, y_reverb, sr)

# 8. Phrasing
def analyze_phrasing(track):
    y, sr = librosa.load(track)
    onset_env = librosa.onset.onset_strength(y, sr=sr)
    tempo, beats = librosa.beat.beat_track(y, sr=sr, onset_envelope=onset_env)
    return beats

# 9. Gridding (Beatgrid)
def create_beatgrid(track):
    y, sr = librosa.load(track)
    tempo, beats = librosa.beat.beat_track(y, sr=sr)
    return librosa.frames_to_time(beats, sr=sr)

# 10. Harmonic Mixing
def detect_key(track):
    y, sr = librosa.load(track)
    chroma = librosa.feature.chroma_stft(y, sr=sr)
    return librosa.feature.chroma_cqt(y, sr=sr).mean(axis=1)

# 11. Mastering
def master_track(track, output_file):
    y, sr = librosa.load(track)
    y_normalized = librosa.util.normalize(y)
    sf.write(output_file, y_normalized, sr)

# Filsti direkte fra listen over mp3-filer som du fant
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

try:
    # Last inn lydfil
    y, sr = librosa.load(audio_file_path)
    print(f"Lydfil lastet inn: {audio_file_path}")

    # Beregn tempo (BPM)
    tempo, _ = librosa.beat.beat_track(y, sr=sr)
    print(f"BPM: {tempo}")

    # Estimer tonalitet (chroma features)
    chroma = librosa.feature.chroma_stft(y, sr=sr)
    print('Chroma features extracted.')

    # Her kan vi også analysere andre aspekter, som struktur
    onset_env = librosa.onset.onset_strength(y, sr=sr)
    tempo, beats = librosa.beat.beat_track(y, sr=sr, onset_envelope=onset_env)
    print(f"Beats detected at time (seconds): {librosa.frames_to_time(beats, sr=sr)}")

except Exception as e:
    print(f"Feil ved lasting av lydfilen: {e}")

# Filsti direkte fra listen over mp3-filer som du fant
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

try:
    # Last inn lydfil
    y, sr = librosa.load(audio_file_path)
    print(f"Lydfil lastet inn: {audio_file_path}")

    # Beregn tempo (BPM)
    tempo, beats = librosa.beat.beat_track(y=y, sr=sr)  # Merk: y og sr er nå nøkkelordargumenter
    print(f"BPM: {tempo}")

    # Estimer tonalitet (chroma features)
    chroma = librosa.feature.chroma_stft(y=y, sr=sr)
    print('Chroma features extracted.')

    # Her kan vi også analysere andre aspekter, som struktur
    onset_env = librosa.onset.onset_strength(y, sr=sr)
    tempo, beats = librosa.beat.beat_track(y=y, sr=sr, onset_envelope=onset_env)
    print(f"Beats detected at time (seconds): {librosa.frames_to_time(beats, sr=sr)}")

except Exception as e:
    print(f"Feil ved lasting av lydfilen: {e}")

# Filsti direkte fra listen over mp3-filer som du fant
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

try:
    # Last inn lydfil
    y, sr = librosa.load(audio_file_path)
    print(f"Lydfil lastet inn: {audio_file_path}")

    # Beregn tempo (BPM)
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
    print(f"BPM: {tempo}")

    # Estimer tonaltitet (chroma features)
    chroma = librosa.feature.chroma_stft(y=y, sr=sr)
    print('Chroma features extracted.')

    # Beregn onset strength (rettet opp feilen her)
    onset_env = librosa.onset.onset_strength(y=y, sr=sr)
    print('Onset strength calculated.')

except Exception as e:
    print(f"Feil ved lasting av lydfilen: {e}")

import librosa
import numpy as np
import soundfile as sf

# Filsti til MP3-filen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Camelot Wheel mapping
camelot_wheel = {
    'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
    'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
    'Cm': '8A', 'C#m': '3A', 'Dm': '10A', 'D#m': '5A', 'Em': '12A', 'Fm': '7A',
    'F#m': '2A', 'Gm': '9A', 'G#m': '4A', 'Am': '11A', 'A#m': '6A', 'Bm': '1A'
}

def get_camelot_key(track):
    # Last inn lydfil og beregn chroma-funksjoner
    y, sr = librosa.load(track)
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)

    # Bruk librosa til å gjenkjenne toneart
    key = librosa.key.key(y, sr=sr)

    # Match til Camelot Wheel
    camelot_key = camelot_wheel.get(key, 'Unknown Key')

    return key, camelot_key

try:
    # Last inn lydfil
    y, sr = librosa.load(audio_file_path)
    print(f"Lydfil lastet inn: {audio_file_path}")

    # Beregn tempo (BPM)
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
    print(f"BPM: {tempo}")

    # Estimer tonality (chroma features) og få Camelot Key
    key, camelot_key = get_camelot_key(audio_file_path)
    print(f"Detected Key: {key}")
    print(f"Camelot Key: {camelot_key}")

except Exception as e:
    print(f"Feil ved lasting av lydfilen: {e}")

import librosa
import numpy as np
import soundfile as sf

# Filsti til MP3-filen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Camelot Wheel mapping
camelot_wheel = {
    'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
    'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
    'Cm': '8A', 'C#m': '3A', 'Dm': '10A', 'D#m': '5A', 'Em': '12A', 'Fm': '7A',
    'F#m': '2A', 'Gm': '9A', 'G#m': '4A', 'Am': '11A', 'A#m': '6A', 'Bm': '1A'
}

# Definer en funksjon for å identifisere tonearten (key) basert på chroma-funksjoner
def get_camelot_key(track):
    # Last inn lydfil og beregn chroma-funksjoner
    y, sr = librosa.load(track)
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)

    # Indikatorer for tonearter (dur og moll)
    major_profile = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1])  # C dur
    minor_profile = np.array([0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0])  # A moll

    # Normaliser chroma-dataene
    chroma_normalized = chroma / chroma.sum()

    # Beregn korrelasjonen med dur og moll profiler
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')

    # Finn tonearten som best matcher profilen
    if major_correlation.max() > minor_correlation.max():
        key = 'C'
    else:
        key = 'Cm'

    # Match til Camelot Wheel
    camelot_key = camelot_wheel.get(key, 'Unknown Key')

    return key, camelot_key

try:
    # Last inn lydfil
    y, sr = librosa.load(audio_file_path)
    print(f"Lydfil lastet inn: {audio_file_path}")

    # Beregn tempo (BPM)
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
    print(f"BPM: {tempo}")

    # Estimer tonality (chroma features) og få Camelot Key
    key, camelot_key = get_camelot_key(audio_file_path)
    print(f"Detected Key: {key}")
    print(f"Camelot Key: {camelot_key}")

except Exception as e:
    print(f"Feil ved lasting av lydfilen: {e}")

pip install torchlibrosa

import torch
import torchlibrosa as tl
import librosa

# Last inn lydfilen
y, sr = librosa.load('/path/to/audio_file.mp3')

# Konverter til tensor for PyTorch
waveform = torch.tensor(y).unsqueeze(0)  # Legg til en batch dimension

# Sett opp Mel-spektrogram-generatoren fra TorchLibrosa
mel_spectrogram = tl.Spectrogram.MelSpectrogram(sample_rate=sr)

# Generer mel-spektrogrammet
mel_spec = mel_spectrogram(waveform)

print(mel_spec.shape)  # Sjekk dimensjonene for å sikre at det fungerer

import torch
import torchlibrosa as tl
import librosa

# Last inn lydfilen
y, sr = librosa.load('/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3')

# Konverter til tensor for PyTorch
waveform = torch.tensor(y).unsqueeze(0)  # Legg til en batch-dimensjon

# Sett opp Mel-spektrogram-generatoren fra TorchLibrosa
mel_spectrogram = tl.Spectrogram.MelSpectrogram(sample_rate=sr)

# Generer mel-spektrogrammet
mel_spec = mel_spectrogram(waveform)

# Skriv ut dimensjonene for å sjekke at det fungerer
print(mel_spec.shape)

import torch
import torchaudio
import librosa

# Last inn lydfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
y, sr = librosa.load(audio_file_path)

# Konverter til tensor for PyTorch
waveform = torch.tensor(y).unsqueeze(0)  # Legg til en batch-dimensjon

# Bruk MelSpectrogram-generatoren fra torchaudio
mel_spectrogram = torchaudio.transforms.MelSpectrogram(sample_rate=sr, n_mels=128)

# Generer mel-spektrogrammet
mel_spec = mel_spectrogram(waveform)

# Skriv ut dimensjonene for å sjekke at det fungerer
print(mel_spec.shape)

!pip install torch
!pip install torchlibrosa
!pip install librosa

import torch
import torchlibrosa.stft as stft
import librosa

# Last inn lydfilen
y, sr = librosa.load('/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3')

# Konverter til tensor for PyTorch
waveform = torch.tensor(y).unsqueeze(0)  # Legg til en batch dimension

# Sett opp Mel-spektrogram-generatoren fra TorchLibrosa
mel_spectrogram = stft.MelSpectrogram(sr=sr, n_mels=64)  # Redusert fra 128 til 64

# Generer mel-spektrogrammet
mel_spec = mel_spectrogram(waveform)

# Sjekk dimensjonene for å sikre at det fungerer
print(mel_spec.shape)

import torch
import torchaudio
import librosa

# Last inn lydfilen med Librosa
y, sr = librosa.load('/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3')

# Konverter til tensor for PyTorch
waveform = torch.tensor(y).unsqueeze(0)  # Legg til en batch dimension

# Sett opp Mel-spektrogram-generatoren fra Torchaudio
mel_spectrogram = torchaudio.transforms.MelSpectrogram(
    sample_rate=sr,
    n_mels=64  # Redusert fra 128 til 64
)

# Generer Mel-spektrogrammet
mel_spec = mel_spectrogram(waveform)

# Sjekk dimensjonene for å sikre at det fungerer
print(mel_spec.shape)

import librosa
import numpy as np
import matplotlib.pyplot as plt

# Last inn lydfil
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
y, sr = librosa.load(audio_file_path)

# Onset detection
onset_frames = librosa.onset.onset_detect(y=y, sr=sr, units='frames')
onset_times = librosa.frames_to_time(onset_frames, sr=sr)

# Energi
hop_length = 512
onset_env = librosa.onset.onset_strength(y=y, sr=sr, hop_length=hop_length)

# Plot onset strength
plt.figure(figsize=(10, 6))
plt.plot(onset_env, label='Onset Strength')
plt.vlines(onset_times, 0, onset_env.max(), color='r', alpha=0.9, linestyle='--', label='Onsets')
plt.xlabel('Tidsramme')
plt.ylabel('Onset styrke')
plt.legend()
plt.title('Onset detection og energi i låten')
plt.show()

# Deteksjon av høyenergipunkter
high_energy_sections = onset_env > np.percentile(onset_env, 75)  # Eksempel: definér høy energi som over 75%-persentilen

print(f"Onset times (in seconds): {onset_times}")
print(f"High energy sections: {high_energy_sections}")

import numpy as np
import librosa
import matplotlib.pyplot as plt

# Last inn lydfil
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
y, sr = librosa.load(audio_file_path)

# Beregn onset strength (energistyrke ved start av nye lyder)
onset_env = librosa.onset.onset_strength(y=y, sr=sr)

# Definer funksjon for å gjenkjenne deler basert på onset og energi
def identify_song_structure(onset_env, sr, song_length_sec):
    # Definer antatt lengde på hver del i prosent av total lengde
    intro_threshold = 0.1  # 10% av sangens lengde
    buildup_threshold = 0.3  # 30% av sangens lengde
    breakdown_threshold = 0.5  # 50% av sangens lengde

    # Definer energiterskler
    high_energy_threshold = np.percentile(onset_env, 75)
    low_energy_threshold = np.percentile(onset_env, 25)

    # Identifiser tidspunkter (i sekunder) basert på energinivåer
    onset_times = librosa.frames_to_time(np.arange(len(onset_env)), sr=sr)

    # Bestem hvor i sangen disse delene er basert på tid og energi
    song_structure = {}

    for time in onset_times:
        if time < intro_threshold * song_length_sec:
            part = "Intro"
        elif intro_threshold * song_length_sec <= time < buildup_threshold * song_length_sec:
            part = "Buildup"
        elif buildup_threshold * song_length_sec <= time < breakdown_threshold * song_length_sec:
            part = "Breakdown"
        elif time > breakdown_threshold * song_length_sec:
            part = "Chorus/Outro"
        else:
            part = "Unknown"

        # Lagre hvilke deler som er identifisert
        song_structure[time] = part

    return song_structure

# Lengde av sangen (i sekunder)
song_length_sec = librosa.get_duration(y=y, sr=sr)

# Identifiser strukturen av sangen
song_structure = identify_song_structure(onset_env, sr, song_length_sec)

# Print ut sangstrukturen
for time, part in song_structure.items():
    print(f"Time: {time:.2f} sec - Part: {part}")

# Plot sangens onset strength sammen med markeringer av deler
plt.figure(figsize=(10, 6))
plt.plot(onset_env, label='Onset Strength')
plt.xlabel('Tidsramme')
plt.ylabel('Onset Styrke')
plt.title('Sangens struktur og energi')

# Legg til linjer for ulike deler av sangen
for time, part in song_structure.items():
    if part == "Intro":
        plt.axvline(x=time, color='green', linestyle='--', label='Intro')
    elif part == "Buildup":
        plt.axvline(x=time, color='blue', linestyle='--', label='Buildup')
    elif part == "Breakdown":
        plt.axvline(x=time, color='red', linestyle='--', label='Breakdown')
    elif part == "Chorus/Outro":
        plt.axvline(x=time, color='purple', linestyle='--', label='Chorus/Outro')

plt.legend()
plt.show()

import numpy as np
import librosa

# Last inn lydfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
y, sr = librosa.load(audio_file_path)

# Beregn onset strength (energiendringer)
onset_env = librosa.onset.onset_strength(y=y, sr=sr)

# Definer terskler for forskjellige deler av låten basert på onset styrke og varighet

# 1. Intro: Lav energi, ofte i starten
def detect_intro(onset_env, sr):
    intro_threshold = np.percentile(onset_env, 25)  # Definerer lav energi
    intro_indices = np.where(onset_env < intro_threshold)[0]  # Finn lav-energi seksjoner
    if len(intro_indices) > 0:
        return librosa.frames_to_time(intro_indices[0], sr=sr)  # Returner starttidspunkt for intro
    return None

# 2. Breakdown: En merkbar reduksjon i energi
def detect_breakdown(onset_env, sr):
    breakdown_threshold = np.percentile(onset_env, 20)  # Ofte lav energi i en breakdown
    breakdown_indices = np.where(onset_env < breakdown_threshold)[0]
    if len(breakdown_indices) > 0:
        return librosa.frames_to_time(breakdown_indices[0], sr=sr)
    return None

# 3. Build-up: Gradvis økning i energi før en take-off eller drop
def detect_buildup(onset_env, sr):
    buildup_threshold = np.percentile(onset_env, 50)  # Middels energi som bygger seg opp
    buildup_indices = np.where(onset_env > buildup_threshold)[0]
    if len(buildup_indices) > 0:
        return librosa.frames_to_time(buildup_indices[0], sr=sr)
    return None

# 4. Take-off: Kraftig energiøkning før en drop eller klimaks
def detect_takeoff(onset_env, sr):
    takeoff_threshold = np.percentile(onset_env, 80)  # Sterk energi som markerer take-off
    takeoff_indices = np.where(onset_env > takeoff_threshold)[0]
    if len(takeoff_indices) > 0:
        return librosa.frames_to_time(takeoff_indices[0], sr=sr)
    return None

# 5. Chorus/Drop: Høy energi etter take-off, ofte klimaks
def detect_chorus(onset_env, sr):
    chorus_threshold = np.percentile(onset_env, 85)  # Høy energi under chorus/drop
    chorus_indices = np.where(onset_env > chorus_threshold)[0]
    if len(chorus_indices) > 0:
        return librosa.frames_to_time(chorus_indices[0], sr=sr)
    return None

# 6. Outro: Gradvis fall i energi mot slutten
def detect_outro(onset_env, sr):
    outro_threshold = np.percentile(onset_env, 25)  # Lav energi mot slutten
    outro_indices = np.where(onset_env < outro_threshold)[0]
    if len(outro_indices) > 0:
        return librosa.frames_to_time(outro_indices[-1], sr=sr)  # Siste lav-energi del
    return None

# Analyse og identifikasjon av segmenter
intro_time = detect_intro(onset_env, sr)
breakdown_time = detect_breakdown(onset_env, sr)
buildup_time = detect_buildup(onset_env, sr)
takeoff_time = detect_takeoff(onset_env, sr)
chorus_time = detect_chorus(onset_env, sr)
outro_time = detect_outro(onset_env, sr)

# Skriv ut resultater
print(f"Intro detektert rundt tid: {intro_time:.2f} sek" if intro_time else "Ingen intro detektert.")
print(f"Breakdown detektert rundt tid: {breakdown_time:.2f} sek" if breakdown_time else "Ingen breakdown detektert.")
print(f"Build-up detektert rundt tid: {buildup_time:.2f} sek" if buildup_time else "Ingen build-up detektert.")
print(f"Take-off detektert rundt tid: {takeoff_time:.2f} sek" if takeoff_time else "Ingen take-off detektert.")
print(f"Chorus/Drop detektert rundt tid: {chorus_time:.2f} sek" if chorus_time else "Ingen chorus/drop detektert.")
print(f"Outro detektert rundt tid: {outro_time:.2f} sek" if outro_time else "Ingen outro detektert.")

import librosa
import numpy as np

# Filsti til lydfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Last inn lydfil og beregn onsets og tempo
y, sr = librosa.load(audio_file_path)
onset_env = librosa.onset.onset_strength(y=y, sr=sr)
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
onset_frames = librosa.onset.onset_detect(onset_envelope=onset_env, sr=sr)
onset_times = librosa.frames_to_time(onset_frames, sr=sr)

# Definer typer onset og energimønstre for ulike deler av sangen
def detect_song_structure(onset_env, onset_times):
    total_duration = librosa.get_duration(y=y, sr=sr)

    # Definer terskler for forskjellige deler basert på energi og varighet
    breakdown_threshold = np.percentile(onset_env, 25)
    buildup_threshold = np.percentile(onset_env, 75)
    drop_threshold = np.percentile(onset_env, 85)

    sections = []

    # Gå gjennom onset-punktene og identifiser segmenter
    for i, onset_time in enumerate(onset_times):
        if onset_env[i] < breakdown_threshold:  # Lav energi: breakdown
            sections.append((onset_time, "Breakdown", onset_env[i]))
        elif buildup_threshold < onset_env[i] < drop_threshold:  # Mellom energi: build-up
            sections.append((onset_time, "Build-up", onset_env[i]))
        elif onset_env[i] >= drop_threshold:  # Høy energi: drop eller take-off
            if len(sections) > 0 and sections[-1][1] == "Build-up":  # Hvis forrige var build-up, er dette take-off
                sections.append((onset_time, "Take-off", onset_env[i]))
            else:
                sections.append((onset_time, "Chorus/Drop", onset_env[i]))

    # Legg til outro basert på hvor langt vi er i sangen
    outro_time = total_duration - 30  # Antar at outro er siste 30 sekunder
    sections.append((outro_time, "Outro", 0))

    return sections

# Funksjon for å finne repetisjoner (som chorus)
def find_repeated_sections(sections, tolerance=0.05):
    repeats = []
    for i in range(len(sections) - 1):
        for j in range(i + 1, len(sections)):
            if sections[i][1] == "Chorus/Drop" and abs(sections[i][0] - sections[j][0]) > tolerance:
                repeats.append((sections[i], sections[j]))
    return repeats

# Konverter sekunder til minutter:sekunder format
def format_time(seconds):
    minutes = int(seconds // 60)
    seconds = seconds % 60
    return f"{minutes}:{seconds:.2f}"

# Hent de ulike delene av sangen
song_structure = detect_song_structure(onset_env, onset_times)
repeated_choruses = find_repeated_sections(song_structure)

# Skriv ut resultatet
print("\nResultater fra sanganalyse:")
for section in song_structure:
    print(f"Del: {section[1]} - Tid: {format_time(section[0])}")

# Skriv ut repetisjoner for chorus/drop
if repeated_choruses:
    print("\nChorus/Drop repetisjoner:")
    for chorus_pair in repeated_choruses:
        print(f"Første chorus: {format_time(chorus_pair[0][0])}, Repetisjon: {format_time(chorus_pair[1][0])}")

# Hvis ingen intro, breakdown, eller outro detektert
if not any(section[1] == "Breakdown" for section in song_structure):
    print("\nIngen breakdown detektert.")
if not any(section[1] == "Outro" for section in song_structure):
    print("Ingen outro detektert.")

import librosa
import numpy as np

# Filsti til lydfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Last inn lydfil og beregn onsets og tempo
y, sr = librosa.load(audio_file_path)
onset_env = librosa.onset.onset_strength(y=y, sr=sr)
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
onset_frames = librosa.onset.onset_detect(onset_envelope=onset_env, sr=sr)
onset_times = librosa.frames_to_time(onset_frames, sr=sr)

# Definer typer onset og energimønstre for ulike deler av sangen
def detect_song_structure(onset_env, onset_times):
    total_duration = librosa.get_duration(y=y, sr=sr)

    # Definer terskler for forskjellige deler basert på energi og varighet
    breakdown_threshold = np.percentile(onset_env, 25)
    buildup_threshold = np.percentile(onset_env, 75)
    drop_threshold = np.percentile(onset_env, 85)

    sections = []

    # Gå gjennom onset-punktene og identifiser segmenter
    for i, onset_time in enumerate(onset_times):
        if onset_env[i] < breakdown_threshold:  # Lav energi: breakdown
            sections.append((onset_time, "Breakdown", onset_env[i]))
        elif buildup_threshold < onset_env[i] < drop_threshold:  # Mellom energi: build-up
            sections.append((onset_time, "Build-up", onset_env[i]))
        elif onset_env[i] >= drop_threshold:  # Høy energi: drop eller take-off
            if len(sections) > 0 and sections[-1][1] == "Build-up":  # Hvis forrige var build-up, er dette take-off
                sections.append((onset_time, "Take-off", onset_env[i]))
            else:
                sections.append((onset_time, "Chorus/Drop", onset_env[i]))

    # Legg til outro basert på hvor langt vi er i sangen
    outro_time = total_duration - 30  # Antar at outro er siste 30 sekunder
    sections.append((outro_time, "Outro", 0))

    return sections

# Funksjon for å finne repetisjoner (som chorus)
def find_repeated_sections(sections, tolerance=0.05):
    repeats = []
    for i in range(len(sections) - 1):
        for j in range(i + 1, len(sections)):
            if sections[i][1] == "Chorus/Drop" and abs(sections[i][0] - sections[j][0]) > tolerance:
                repeats.append((sections[i], sections[j]))
    return repeats

# Konverter sekunder til minutter:sekunder format
def format_time(seconds):
    minutes = int(seconds // 60)
    seconds = seconds % 60
    return f"{minutes}:{seconds:.2f}"

# Hent de ulike delene av sangen
song_structure = detect_song_structure(onset_env, onset_times)
repeated_choruses = find_repeated_sections(song_structure)

# Skriv ut resultatet
print("\nResultater fra sanganalyse:")
for section in song_structure:
    print(f"Del: {section[1]} - Tid: {format_time(section[0])}")

# Skriv ut repetisjoner for chorus/drop
if repeated_choruses:
    print("\nChorus/Drop repetisjoner:")
    for chorus_pair in repeated_choruses:
        print(f"Første chorus: {format_time(chorus_pair[0][0])}, Repetisjon: {format_time(chorus_pair[1][0])}")

# Hvis ingen intro, breakdown, eller outro detektert
if not any(section[1] == "Breakdown" for section in song_structure):
    print("\nIngen breakdown detektert.")
if not any(section[1] == "Outro" for section in song_structure):
    print("Ingen outro detektert.")

import librosa
import numpy as np

# Filsti til lydfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Last inn lydfil og beregn onsets og tempo
y, sr = librosa.load(audio_file_path)
onset_env = librosa.onset.onset_strength(y=y, sr=sr)
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
onset_frames = librosa.onset.onset_detect(onset_envelope=onset_env, sr=sr)
onset_times = librosa.frames_to_time(onset_frames, sr=sr)

# Funksjon for å formatere tid i minutter, sekunder, millisekunder
def format_time(seconds):
    minutes = int(seconds // 60)
    seconds = int(seconds % 60)
    milliseconds = int((seconds % 1) * 1000)
    return f"{minutes:02d}:{seconds:02d}.{milliseconds:03d}"

# Funksjon for å identifisere sangstrukturen basert på onset-energi og segmentlengde
def detect_song_structure(onset_env, onset_times):
    total_duration = librosa.get_duration(y=y, sr=sr)

    # Definer terskler for å identifisere ulike deler basert på energi og lengde
    breakdown_threshold = np.percentile(onset_env, 25)
    buildup_threshold = np.percentile(onset_env, 75)
    drop_threshold = np.percentile(onset_env, 85)

    sections = []
    for i, onset_time in enumerate(onset_times[:-1]):  # Gå gjennom onset-punktene
        duration = onset_times[i+1] - onset_times[i]  # Beregn varighet mellom onsets

        if onset_env[i] < breakdown_threshold:  # Lav energi: breakdown
            sections.append((onset_time, "Breakdown", duration))
        elif buildup_threshold < onset_env[i] < drop_threshold:  # Mellom energi: build-up
            sections.append((onset_time, "Build-up", duration))
        elif onset_env[i] >= drop_threshold:  # Høy energi: drop eller take-off
            if len(sections) > 0 and sections[-1][1] == "Build-up":
                sections.append((onset_time, "Take-off", duration))
            else:
                sections.append((onset_time, "Chorus/Drop", duration))

    outro_time = total_duration - 30  # Antar at outro starter de siste 30 sekundene
    sections.append((outro_time, "Outro", total_duration - outro_time))

    return sections

# Funksjon for å finne repeterende elementer (f.eks. chorus)
def find_repeated_sections(sections, tolerance=0.1):
    repeats = []
    for i, section_i in enumerate(sections[:-1]):
        if section_i[1] == "Chorus/Drop":  # Bare sjekk chorus/drop
            for j, section_j in enumerate(sections[i+1:]):
                if section_j[1] == "Chorus/Drop" and abs(section_j[0] - section_i[0]) < tolerance:
                    repeats.append((section_i, section_j))
    return repeats

# Funksjon for å konvertere sekunder til minutter og sekunder med varighet
def format_section_times(section):
    start_time = format_time(section[0])
    end_time = format_time(section[0] + section[2])
    duration = format_time(section[2])
    return start_time, end_time, duration

# Hent de ulike delene av sangen
song_structure = detect_song_structure(onset_env, onset_times)
repeated_choruses = find_repeated_sections(song_structure)

# Skriv ut analysen i et strukturert format
print("\nResultater fra sanganalyse:")
for section in song_structure:
    start_time, end_time, duration = format_section_times(section)
    print(f"Del: {section[1]} - Start: {start_time} - Slutt: {end_time} - Varighet: {duration}")

# Hvis chorus blir repetert, skriv ut repetisjonene
if repeated_choruses:
    print("\nChorus/Drop repetisjoner:")
    for chorus_pair in repeated_choruses:
        first_start, _, first_duration = format_section_times(chorus_pair[0])
        second_start, _, _ = format_section_times(chorus_pair[1])
        print(f"Chorus 1: Start: {first_start} - Varighet: {first_duration}, Chorus 2: Start: {second_start}")

# Hvis deler mangler
if not any(section[1] == "Build-up" for section in song_structure):
    print("\nIngen build-up detektert.")
if not any(section[1] == "Take-off" for section in song_structure):
    print("Ingen take-off detektert.")
if not any(section[1] == "Chorus/Drop" for section in song_structure):
    print("Ingen chorus/drop detektert.")
if not any(section[1] == "Outro" for section in song_structure):
    print("Ingen outro detektert.")

import librosa

# Lese lydfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Librosa laster inn lydfilen og samplerate
y, sr = librosa.load(audio_file_path)

# Lengden på lydfilen i sekunder
total_duration = librosa.get_duration(y=y, sr=sr)
print(f"Lydfilens totale varighet er: {total_duration} sekunder")

# For eksempel, hvis vi vil dele opp sangen i segmenter på 30 sekunder hver
segment_duration = 30  # segment lengde i sekunder

# Beregn hvor mange segmenter vi får
num_segments = int(total_duration // segment_duration)

for i in range(num_segments):
    start_time = i * segment_duration
    end_time = (i + 1) * segment_duration
    print(f"Segment {i+1}: Start {start_time:.2f} sekunder, Slutt {end_time:.2f} sekunder")

!pip install pydub

import librosa
import numpy as np

# Laste inn lydfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
y, sr = librosa.load(audio_file_path)

# Finne onset-elementer
onsets = librosa.onset.onset_detect(y=y, sr=sr, backtrack=True)

# Konverter onsets til tidspunkter
onset_times = librosa.frames_to_time(onsets, sr=sr)

# Skriv ut onsets
print(f"Onset-tidspunkter: {onset_times}")

import librosa
import numpy as np

# Last inn lydfilen med Librosa
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
y, sr = librosa.load(audio_file_path)

# Beregn onset strength (energiendringer)
onset_env = librosa.onset.onset_strength(y=y, sr=sr)

# Definer funksjoner for å identifisere forskjellige deler av sangen
def detect_intro(onset_env, sr):
    intro_threshold = np.percentile(onset_env, 25)  # Definerer lav energi
    intro_indices = np.where(onset_env < intro_threshold)[0]
    if len(intro_indices) > 0:
        return librosa.frames_to_time(intro_indices[0], sr=sr)
    return None

def detect_breakdown(onset_env, sr):
    breakdown_threshold = np.percentile(onset_env, 20)
    breakdown_indices = np.where(onset_env < breakdown_threshold)[0]
    if len(breakdown_indices) > 0:
        return librosa.frames_to_time(breakdown_indices[0], sr=sr)
    return None

def detect_buildup(onset_env, sr):
    buildup_threshold = np.percentile(onset_env, 50)
    buildup_indices = np.where(onset_env > buildup_threshold)[0]
    if len(buildup_indices) > 0:
        return librosa.frames_to_time(buildup_indices[0], sr=sr)
    return None

def detect_takeoff(onset_env, sr):
    takeoff_threshold = np.percentile(onset_env, 80)
    takeoff_indices = np.where(onset_env > takeoff_threshold)[0]
    if len(takeoff_indices) > 0:
        return librosa.frames_to_time(takeoff_indices[0], sr=sr)
    return None

def detect_chorus(onset_env, sr):
    chorus_threshold = np.percentile(onset_env, 85)
    chorus_indices = np.where(onset_env > chorus_threshold)[0]
    if len(chorus_indices) > 0:
        return librosa.frames_to_time(chorus_indices[0], sr=sr)
    return None

def detect_outro(onset_env, sr):
    outro_threshold = np.percentile(onset_env, 25)
    outro_indices = np.where(onset_env < outro_threshold)[0]
    if len(outro_indices) > 0:
        return librosa.frames_to_time(outro_indices[-1], sr=sr)
    return None

# Hent de ulike delene av sangen
intro_time = detect_intro(onset_env, sr)
breakdown_time = detect_breakdown(onset_env, sr)
buildup_time = detect_buildup(onset_env, sr)
takeoff_time = detect_takeoff(onset_env, sr)
chorus_time = detect_chorus(onset_env, sr)
outro_time = detect_outro(onset_env, sr)

# Skriv ut resultater
print(f"Intro detektert rundt tid: {intro_time:.2f} sek" if intro_time else "Ingen intro detektert.")
print(f"Breakdown detektert rundt tid: {breakdown_time:.2f} sek" if breakdown_time else "Ingen breakdown detektert.")
print(f"Build-up detektert rundt tid: {buildup_time:.2f} sek" if buildup_time else "Ingen build-up detektert.")
print(f"Take-off detektert rundt tid: {takeoff_time:.2f} sek" if takeoff_time else "Ingen take-off detektert.")
print(f"Chorus/Drop detektert rundt tid: {chorus_time:.2f} sek" if chorus_time else "Ingen chorus/drop detektert.")
print(f"Outro detektert rundt tid: {outro_time:.2f} sek" if outro_time else "Ingen outro detektert.")

import librosa
import numpy as np

# Last inn lydfilen med Librosa
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
y, sr = librosa.load(audio_file_path)

# Beregn onset strength (energiendringer)
onset_env = librosa.onset.onset_strength(y=y, sr=sr)

# Funksjon for å identifisere sangsegmenter basert på onset energi
def detect_segments(onset_env, sr):
    # Definer prosentiler for energigrensene
    intro_threshold = np.percentile(onset_env, 10)   # Lav energi for intro
    breakdown_threshold = np.percentile(onset_env, 20)  # Lav energi for breakdown
    buildup_threshold = np.percentile(onset_env, 50)   # Økende energi for build-up
    takeoff_threshold = np.percentile(onset_env, 80)  # Høy energi for take-off
    chorus_threshold = np.percentile(onset_env, 90)   # Veldig høy energi for chorus/drop
    outro_threshold = np.percentile(onset_env, 15)   # Lav energi for outro (mot slutten)

    # Beregn segmentene basert på onset
    sections = {
        "Intro": None,
        "Breakdown": None,
        "Build-up": None,
        "Take-off": None,
        "Chorus/Drop": None,
        "Outro": None
    }

    # Gå gjennom onset-punktene
    for i in range(len(onset_env)):
        onset_time = librosa.frames_to_time(i, sr=sr)
        if onset_env[i] < intro_threshold and sections["Intro"] is None:
            sections["Intro"] = onset_time
        elif onset_env[i] < breakdown_threshold and sections["Breakdown"] is None and sections["Intro"] is not None:
            sections["Breakdown"] = onset_time
        elif buildup_threshold <= onset_env[i] < takeoff_threshold and sections["Build-up"] is None:
            sections["Build-up"] = onset_time
        elif takeoff_threshold <= onset_env[i] < chorus_threshold and sections["Take-off"] is None:
            sections["Take-off"] = onset_time
        elif onset_env[i] >= chorus_threshold and sections["Chorus/Drop"] is None:
            sections["Chorus/Drop"] = onset_time
        elif onset_env[i] < outro_threshold and sections["Outro"] is None and onset_time > 0.8 * librosa.get_duration(y=y, sr=sr):
            sections["Outro"] = onset_time

    return sections

# Hent de ulike segmentene
song_segments = detect_segments(onset_env, sr)

# Skriv ut resultatene
for section, time in song_segments.items():
    if time:
        print(f"{section} detektert rundt tid: {time:.2f} sek")
    else:
        print(f"Ingen {section.lower()} detektert.")

import librosa
import numpy as np

# Last inn lydfilen med Librosa
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
y, sr = librosa.load(audio_file_path)

# Beregn onset strength (energiendringer)
onset_env = librosa.onset.onset_strength(y=y, sr=sr)

# Funksjon for å identifisere sangsegmenter basert på onset energi
def detect_segments(onset_env, sr):
    # Definer prosentiler for energigrensene
    intro_threshold = np.percentile(onset_env, 10)   # Lav energi for intro
    breakdown_threshold = np.percentile(onset_env, 20)  # Lav energi for breakdown
    buildup_threshold = np.percentile(onset_env, 50)   # Økende energi for build-up
    takeoff_threshold = np.percentile(onset_env, 80)  # Høy energi for take-off
    chorus_threshold = np.percentile(onset_env, 90)   # Veldig høy energi for chorus/drop
    outro_threshold = np.percentile(onset_env, 15)   # Lav energi for outro (mot slutten)

    # Beregn segmentene basert på onset
    sections = {
        "Intro": None,
        "Breakdown": None,
        "Build-up": None,
        "Take-off": None,
        "Chorus/Drop": None,
        "Outro": None
    }

    # Gå gjennom onset-punktene
    for i in range(len(onset_env)):
        onset_time = librosa.frames_to_time(i, sr=sr)
        if onset_env[i] < intro_threshold and sections["Intro"] is None:
            sections["Intro"] = onset_time
        elif onset_env[i] < breakdown_threshold and sections["Breakdown"] is None and sections["Intro"] is not None:
            sections["Breakdown"] = onset_time
        elif buildup_threshold <= onset_env[i] < takeoff_threshold and sections["Build-up"] is None:
            sections["Build-up"] = onset_time
        elif takeoff_threshold <= onset_env[i] < chorus_threshold and sections["Take-off"] is None:
            sections["Take-off"] = onset_time
        elif onset_env[i] >= chorus_threshold and sections["Chorus/Drop"] is None:
            sections["Chorus/Drop"] = onset_time
        elif onset_env[i] < outro_threshold and sections["Outro"] is None and onset_time > 0.8 * librosa.get_duration(y=y, sr=sr):
            sections["Outro"] = onset_time

    return sections

# Hent de ulike segmentene
song_segments = detect_segments(onset_env, sr)

# Skriv ut resultatene
for section, time in song_segments.items():
    if time:
        print(f"{section} detektert rundt tid: {time:.2f} sek")
    else:
        print(f"Ingen {section.lower()} detektert.")

from google.colab import drive
drive.mount('/content/drive')

import librosa
import numpy as np

# Filsti til lydfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Last inn lydfil og beregn onsets og tempo
y, sr = librosa.load(audio_file_path)
onset_env = librosa.onset.onset_strength(y=y, sr=sr)
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
onset_frames = librosa.onset.onset_detect(onset_envelope=onset_env, sr=sr)
onset_times = librosa.frames_to_time(onset_frames, sr=sr)

# Funksjon for å formatere tid i minutter, sekunder, millisekunder
def format_time(seconds):
    minutes = int(seconds // 60)
    seconds = int(seconds % 60)
    milliseconds = int((seconds % 1) * 1000)
    return f"{minutes:02d}:{seconds:02d}.{milliseconds:03d}"

# Funksjon for å identifisere sangstrukturen basert på onset-energi og segmentlengde
def detect_song_structure(onset_env, onset_times):
    total_duration = librosa.get_duration(y=y, sr=sr)

    # Definer terskler for å identifisere ulike deler basert på energi og lengde
    breakdown_threshold = np.percentile(onset_env, 25)
    buildup_threshold = np.percentile(onset_env, 75)
    drop_threshold = np.percentile(onset_env, 85)

    sections = []
    for i, onset_time in enumerate(onset_times[:-1]):  # Gå gjennom onset-punktene
        duration = onset_times[i+1] - onset_times[i]  # Beregn varighet mellom onsets

        if onset_env[i] < breakdown_threshold:  # Lav energi: breakdown
            sections.append((onset_time, "Breakdown", duration))
        elif buildup_threshold < onset_env[i] < drop_threshold:  # Mellom energi: build-up
            sections.append((onset_time, "Build-up", duration))
        elif onset_env[i] >= drop_threshold:  # Høy energi: drop eller take-off
            if len(sections) > 0 and sections[-1][1] == "Build-up":
                sections.append((onset_time, "Take-off", duration))
            else:
                sections.append((onset_time, "Chorus/Drop", duration))

    outro_time = total_duration - 30  # Antar at outro starter de siste 30 sekundene
    sections.append((outro_time, "Outro", total_duration - outro_time))

    return sections

# Funksjon for å finne repeterende elementer (f.eks. chorus)
def find_repeated_sections(sections, tolerance=0.1):
    repeats = []
    for i, section_i in enumerate(sections[:-1]):
        if section_i[1] == "Chorus/Drop":  # Bare sjekk chorus/drop
            for j, section_j in enumerate(sections[i+1:]):
                if section_j[1] == "Chorus/Drop" and abs(section_j[0] - section_i[0]) < tolerance:
                    repeats.append((section_i, section_j))
    return repeats

# Funksjon for å konvertere sekunder til minutter og sekunder med varighet
def format_section_times(section):
    start_time = format_time(section[0])
    end_time = format_time(section[0] + section[2])
    duration = format_time(section[2])
    return start_time, end_time, duration

# Hent de ulike delene av sangen
song_structure = detect_song_structure(onset_env, onset_times)
repeated_choruses = find_repeated_sections(song_structure)

# Skriv ut analysen i et strukturert format
print("\nResultater fra sanganalyse:")
for section in song_structure:
    start_time, end_time, duration = format_section_times(section)
    print(f"Del: {section[1]} - Start: {start_time} - Slutt: {end_time} - Varighet: {duration}")

# Hvis chorus blir repetert, skriv ut repetisjonene
if repeated_choruses:
    print("\nChorus/Drop repetisjoner:")
    for chorus_pair in repeated_choruses:
        first_start, _, first_duration = format_section_times(chorus_pair[0])
        second_start, _, _ = format_section_times(chorus_pair[1])
        print(f"Chorus 1: Start: {first_start} - Varighet: {first_duration}, Chorus 2: Start: {second_start}")

# Hvis deler mangler
if not any(section[1] == "Build-up" for section in song_structure):
    print("\nIngen build-up detektert.")
if not any(section[1] == "Take-off" for section in song_structure):
    print("Ingen take-off detektert.")
if not any(section[1] == "Chorus/Drop" for section in song_structure):
    print("Ingen chorus/drop detektert.")
if not any(section[1] == "Outro" for section in song_structure):
    print("Ingen outro detektert.")

import librosa
import numpy as np

# Filsti til lydfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

try:
    # Last inn lydfil og beregn onsets og tempo
    y, sr = librosa.load(audio_file_path, sr=None)  # Bruker sr=None for å beholde original sampling rate
    onset_env = librosa.onset.onset_strength(y=y, sr=sr)
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
    onset_frames = librosa.onset.onset_detect(onset_envelope=onset_env, sr=sr)
    onset_times = librosa.frames_to_time(onset_frames, sr=sr)

except FileNotFoundError:
    print(f"Lydfilen {audio_file_path} ble ikke funnet.")
    raise
except Exception as e:
    print(f"En feil oppstod under innlasting av lydfil eller beregning av onsets/tempo: {e}")
    raise

# Funksjon for å formatere tid i minutter, sekunder, millisekunder
def format_time(seconds):
    minutes = int(seconds // 60)
    seconds_remaining = seconds % 60
    milliseconds = int((seconds_remaining % 1) * 1000)
    return f"{minutes:02d}:{int(seconds_remaining):02d}.{milliseconds:03d}"

# Funksjon for å identifisere sangstrukturen basert på onset-energi og segmentlengde
def detect_song_structure(onset_env, onset_times, y, sr):
    try:
        total_duration = librosa.get_duration(y=y, sr=sr)

        # Definer terskler for å identifisere ulike deler basert på energi og lengde
        breakdown_threshold = np.percentile(onset_env, 25)
        buildup_threshold = np.percentile(onset_env, 75)
        drop_threshold = np.percentile(onset_env, 85)

        sections = []
        for i, onset_time in enumerate(onset_times[:-1]):  # Gå gjennom onset-punktene
            duration = onset_times[i+1] - onset_times[i]  # Beregn varighet mellom onsets

            if onset_env[i] < breakdown_threshold:  # Lav energi: breakdown
                sections.append((onset_time, "Breakdown", duration))
            elif buildup_threshold < onset_env[i] < drop_threshold:  # Mellom energi: build-up
                sections.append((onset_time, "Build-up", duration))
            elif onset_env[i] >= drop_threshold:  # Høy energi: drop eller take-off
                if len(sections) > 0 and sections[-1][1] == "Build-up":
                    sections.append((onset_time, "Take-off", duration))
                else:
                    sections.append((onset_time, "Chorus/Drop", duration))

        outro_time = total_duration - 30  # Antar at outro starter de siste 30 sekundene
        if outro_time > 0:  # Hvis sangen er lang nok til å ha en outro
            sections.append((outro_time, "Outro", total_duration - outro_time))

        return sections

    except Exception as e:
        print(f"En feil oppstod under sangstrukturdeteksjon: {e}")
        raise

# Funksjon for å finne repeterende elementer (f.eks. chorus)
def find_repeated_sections(sections, tolerance=0.1):
    repeats = []
    try:
        for i, section_i in enumerate(sections[:-1]):
            if section_i[1] == "Chorus/Drop":  # Bare sjekk chorus/drop
                for j, section_j in enumerate(sections[i+1:]):
                    if section_j[1] == "Chorus/Drop" and abs(section_j[0] - section_i[0]) < tolerance:
                        repeats.append((section_i, section_j))
        return repeats

    except Exception as e:
        print(f"En feil oppstod under repetisjonssjekk: {e}")
        raise

# Funksjon for å konvertere sekunder til minutter og sekunder med varighet
def format_section_times(section):
    start_time = format_time(section[0])
    end_time = format_time(section[0] + section[2])
    duration = format_time(section[2])
    return start_time, end_time, duration

try:
    # Hent de ulike delene av sangen
    song_structure = detect_song_structure(onset_env, onset_times, y, sr)
    repeated_choruses = find_repeated_sections(song_structure)

    # Skriv ut analysen i et strukturert format
    print("\nResultater fra sanganalyse:")
    for section in song_structure:
        start_time, end_time, duration = format_section_times(section)
        print(f"Del: {section[1]} - Start: {start_time} - Slutt: {end_time} - Varighet: {duration}")

    # Hvis chorus blir repetert, skriv ut repetisjonene
    if repeated_choruses:
        print("\nChorus/Drop repetisjoner:")
        for chorus_pair in repeated_choruses:
            first_start, _, first_duration = format_section_times(chorus_pair[0])
            second_start, _, _ = format_section_times(chorus_pair[1])
            print(f"Chorus 1: Start: {first_start} - Varighet: {first_duration}, Chorus 2: Start: {second_start}")

    # Hvis deler mangler
    if not any(section[1] == "Build-up" for section in song_structure):
        print("\nIngen build-up detektert.")
    if not any(section[1] == "Take-off" for section in song_structure):
        print("Ingen take-off detektert.")
    if not any(section[1] == "Chorus/Drop" for section in song_structure):
        print("Ingen chorus/drop detektert.")
    if not any(section[1] == "Outro" for section in song_structure):
        print("Ingen outro detektert.")

except Exception as e:
    print(f"En feil oppstod under hovedanalysen: {e}")

import librosa
import numpy as np
import soundfile as sf

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Camelot Wheel mapping
camelot_wheel = {
    'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
    'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
    'Cm': '5A', 'C#m': '12A', 'Dm': '7A', 'D#m': '2A', 'Em': '9A', 'Fm': '4A',
    'F#m': '11A', 'Gm': '6A', 'G#m': '1A', 'Am': '8A', 'A#m': '3A', 'Bm': '10A'
}

# Funksjon for å identifisere toneart (key) basert på chroma-funksjoner
def get_camelot_key(track):
    # Last inn lydfil og beregn chroma-funksjoner
    y, sr = librosa.load(track)
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)

    # Indikatorer for tonearter (dur og moll)
    major_profile = np.array([1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0])  # C dur
    minor_profile = np.array([1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0])  # A moll

    # Normaliser chroma-dataene
    chroma_normalized = chroma / chroma.sum()

    # Beregn korrelasjonen med dur og moll profiler
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')

    # Finn tonearten som best matcher profilen
    if major_correlation.max() > minor_correlation.max():
        key = 'C'
    else:
        key = 'Cm'

    # Match til Camelot Wheel
    camelot_key = camelot_wheel.get(key, 'Unknown Key')

    return key, camelot_key

# Last inn lydfil
y, sr = librosa.load(audio_file_path)
print(f"Lydfil lastet inn: {audio_file_path}")

# Beregn tempo (BPM)
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
print(f"Detected BPM: {tempo:.2f}")

# Beregn toneart (chroma features) og få Camelot Key
key, camelot_key = get_camelot_key(audio_file_path)
print(f"Detected Key: {key} - Camelot Key: {camelot_key}")

# Beregn onset strength (energier i lyd)
onset_env = librosa.onset.onset_strength(y=y, sr=sr)

# Funksjon for å identifisere sangsegmenter basert på onset energi
def detect_segments(onset_env, sr):
    # Definer prosentiler for energigrense
    intro_threshold = np.percentile(onset_env, 10)  # Low energy for intro
    breakdown_threshold = np.percentile(onset_env, 20)  # Lav energi for breakdown
    buildup_threshold = np.percentile(onset_env, 50)  # Medium energi for build-up
    takeoff_threshold = np.percentile(onset_env, 80)  # Sterk energi for take-off
    chorus_threshold = np.percentile(onset_env, 90)  # Veldig høy energi for chorus/drop
    outro_threshold = np.percentile(onset_env, 15)  # Lav energi for outro (mot slutten)

    # Beregn segmentene basert på onset
    sections = {
        "Intro": None,
        "Breakdown": None,
        "Build-up": None,
        "Take-off": None,
        "Chorus/Drop": None,
        "Outro": None
    }

    # Gå gjennom onset-punktene
    for i in range(len(onset_env)):
        onset_time = librosa.frames_to_time(i, sr=sr)
        if onset_env[i] < intro_threshold and sections["Intro"] is None:
            sections["Intro"] = onset_time
        elif onset_env[i] < breakdown_threshold and sections["Breakdown"] is None and sections["Intro"] is not None:
            sections["Breakdown"] = onset_time
        elif buildup_threshold <= onset_env[i] < takeoff_threshold and sections["Build-up"] is None:
            sections["Build-up"] = onset_time
        elif takeoff_threshold <= onset_env[i] < chorus_threshold and sections["Take-off"] is None:
            sections["Take-off"] = onset_time
        elif onset_env[i] >= chorus_threshold and sections["Chorus/Drop"] is None:
            sections["Chorus/Drop"] = onset_time
        elif onset_env[i] < outro_threshold and sections["Outro

import os

# Skriv inn stiene til mappene du vil sjekke
enhanced_files_dir = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/enhanced_files'
ai_super_dj_dir = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj'

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å lese tekstfil og sjekke om den inneholder onset-definisjoner
def check_file_for_onsets(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
        if 'onset' in content.lower():  # Sjekker om filen nevner 'onset'
            return True
    return False

# Liste over filer i begge mappene
enhanced_files = list_files_in_directory(enhanced_files_dir)
ai_super_dj_files = list_files_in_directory(ai_super_dj_dir)

# Sjekker om filene inneholder onset-definisjoner
relevant_files = []
for file_path in enhanced_files + ai_super_dj_files:
    if file_path.endswith('.txt') and check_file_for_onsets(file_path):
        relevant_files.append(file_path)

# Skriver ut relevante filer som inneholder onset-definisjoner
print("Følgende filer inneholder onset-definisjoner:")
for file in relevant_files:
    print(file)

import os
import librosa
import numpy as np

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å lese tekstfil og sjekke om den inneholder onset-definisjoner
def check_file_for_onsets(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
        if 'onset' in content.lower():  # Sjekker om filen nevner 'onset'
            return True
    return False

# Sjekk filer i to mapper
enhanced_files_dir = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/enhanced_files'
ai_super_dj_dir = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj'

enhanced_files = list_files_in_directory(enhanced_files_dir)
ai_super_dj_files = list_files_in_directory(ai_super_dj_dir)

# Sjekker om filene inneholder onset-definisjoner
relevant_files = []
for file_path in enhanced_files + ai_super_dj_files:
    if file_path.endswith('.txt') and check_file_for_onsets(file_path):
        relevant_files.append(file_path)

# Skriver ut relevante filer som inneholder onset-definisjoner
print("Følgende filer inneholder onset-definisjoner:")
for file in relevant_files:
    print(file)

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Camelot Wheel mapping
camelot_wheel = {
    'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
    'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
    'Cm': '8A', 'C#m': '3A', 'Dm': '10A', 'D#m': '5A', 'Em': '12A', 'Fm': '7A',
    'F#m': '2A', 'Gm': '9A', 'G#m': '4A', 'Am': '11A', 'A#m': '6A', 'Bm': '1A'
}

# Last inn lydfilen
y, sr = librosa.load(audio_file_path)

# 1. Varighet i sekunder
duration = librosa.get_duration(y=y, sr=sr)
print(f"Varighet: {int(duration // 60):02d}:{int(duration % 60):02d}.{int((duration % 1) * 1000):03d}")

# 2. Onsets: Teller antall onsets og returnerer hvor mange ganger de oppstår
onset_env = librosa.onset.onset_strength(y=y, sr=sr)
onset_frames = librosa.onset.onset_detect(onset_envelope=onset_env, sr=sr)
onset_times = librosa.frames_to_time(onset_frames, sr=sr)
print(f"Antall onsets: {len(onset_times)}")

# 3. Seksjoner: Klassifisering av musikkseksjoner basert på onset-styrke
def detect_sections(onset_env, sr):
    sections = []
    intro_threshold = np.percentile(onset_env, 25)
    breakdown_threshold = np.percentile(onset_env, 20)
    buildup_threshold = np.percentile(onset_env, 50)
    takeoff_threshold = np.percentile(onset_env, 80)
    outro_threshold = np.percentile(onset_env, 25)

    # Identifiser seksjoner (rekkefølgen viktig)
    if any(onset_env < intro_threshold):
        sections.append("Intro")
    if any(onset_env < breakdown_threshold):
        sections.append("Breakdown")
    if any(onset_env > buildup_threshold):
        sections.append("Build-up")
    if any(onset_env > takeoff_threshold):
        sections.append("Take-off")
    if any(onset_env < outro_threshold):
        sections.append("Outro")

    return sections

sections = detect_sections(onset_env, sr)
print(f"Seksjoner: {sections}")

# 4. BPM-analyse (Tempo)
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
print(f"BPM (Tempo): {tempo:.2f}")

# 5. Toneart (Key) og Camelot Key
def get_camelot_key(y, sr):
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)

    # Indikatorer for tonearter (dur og moll)
    major_profile = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1])  # C dur
    minor_profile = np.array([0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0])  # A moll

    # Normaliser chroma-dataene
    chroma_normalized = chroma / chroma.sum()

    # Beregn korrelasjonen med dur og moll profiler
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')

    # Finn tonearten som best matcher profilen
    key = 'C' if major_correlation.max() > minor_correlation.max() else 'Cm'
    camelot_key = camelot_wheel.get(key, 'Unknown Key')

    return key, camelot_key

key, camelot_key = get_camelot_key(y, sr)
print(f"Toneart (Key): {key}")
print(f"Camelot Key: {camelot_key}")

import os
import librosa
import numpy as np

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å lese tekstfil og sjekke om den inneholder onset-definisjoner
def check_file_for_onsets(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
        if 'onset' in content.lower():  # Sjekker om filen nevner 'onset'
            return True
    return False

# Sjekk filer i to mapper
enhanced_files_dir = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/enhanced_files'
ai_super_dj_dir = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj'

enhanced_files = list_files_in_directory(enhanced_files_dir)
ai_super_dj_files = list_files_in_directory(ai_super_dj_dir)

# Sjekker om filene inneholder onset-definisjoner
relevant_files = []
for file_path in enhanced_files + ai_super_dj_files:
    if file_path.endswith('.txt') and check_file_for_onsets(file_path):
        relevant_files.append(file_path)

# Skriver ut relevante filer som inneholder onset-definisjoner
print("Følgende filer inneholder onset-definisjoner:")
for file in relevant_files:
    print(file)

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Camelot Wheel mapping
camelot_wheel = {
    'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
    'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
    'Cm': '8A', 'C#m': '3A', 'Dm': '10A', 'D#m': '5A', 'Em': '12A', 'Fm': '7A',
    'F#m': '2A', 'Gm': '9A', 'G#m': '4A', 'Am': '11A', 'A#m': '6A', 'Bm': '1A'
}

# Last inn lydfilen
y, sr = librosa.load(audio_file_path)

# 1. Varighet i sekunder
duration = librosa.get_duration(y=y, sr=sr)
print(f"Varighet: {int(duration // 60):02d}:{int(duration % 60):02d}.{int((duration % 1) * 1000):03d}")

# 2. Onsets: Teller antall onsets og returnerer hvor mange ganger de oppstår
onset_env = librosa.onset.onset_strength(y=y, sr=sr)
onset_frames = librosa.onset.onset_detect(onset_envelope=onset_env, sr=sr)
onset_times = librosa.frames_to_time(onset_frames, sr=sr)
print(f"Antall onsets: {len(onset_times)}")

# 3. Seksjoner: Klassifisering av musikkseksjoner basert på onset-styrke
def detect_sections(onset_env, sr):
    sections = []
    intro_threshold = np.percentile(onset_env, 25)
    breakdown_threshold = np.percentile(onset_env, 20)
    buildup_threshold = np.percentile(onset_env, 50)
    takeoff_threshold = np.percentile(onset_env, 80)
    outro_threshold = np.percentile(onset_env, 25)

    # Identifiser seksjoner (rekkefølgen viktig)
    if any(onset_env < intro_threshold):
        sections.append("Intro")
    if any(onset_env < breakdown_threshold):
        sections.append("Breakdown")
    if any(onset_env > buildup_threshold):
        sections.append("Build-up")
    if any(onset_env > takeoff_threshold):
        sections.append("Take-off")
    if any(onset_env < outro_threshold):
        sections.append("Outro")

    return sections

sections = detect_sections(onset_env, sr)
print(f"Seksjoner: {sections}")

# 4. BPM-analyse (Tempo)
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)

# Sjekk at tempo er et tall mellom 0 og 200
bpm_value = tempo[0] if isinstance(tempo, np.ndarray) else tempo

# Begrens BPM til å være mellom 0 og 200
bpm_value = min(max(bpm_value, 0), 200)

print(f"BPM (Tempo): {int(bpm_value)}")

# 5. Toneart (Key) og Camelot Key
def get_camelot_key(y, sr):
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)

    # Indikatorer for tonearter (dur og moll)
    major_profile = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1])  # C dur
    minor_profile = np.array([0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0])  # A moll

    # Normaliser chroma-dataene
    chroma_normalized = chroma / chroma.sum()

    # Beregn korrelasjonen med dur og moll profiler
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')

    # Finn tonearten som best matcher profilen
    key = 'C' if major_correlation.max() > minor_correlation.max() else 'Cm'
    camelot_key = camelot_wheel.get(key, 'Unknown Key')

    return key, camelot_key

key, camelot_key = get_camelot_key(y, sr)
print(f"Toneart (Key): {key}")
print(f"Camelot Key: {camelot_key}")

import os
import librosa
import numpy as np

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å lese tekstfil og sjekke om den inneholder onset-definisjoner
def check_file_for_onsets(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
        if 'onset' in content.lower():  # Sjekker om filen nevner 'onset'
            return True
    return False

# Sjekk filer i to mapper
enhanced_files_dir = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/enhanced_files'
ai_super_dj_dir = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj'

enhanced_files = list_files_in_directory(enhanced_files_dir)
ai_super_dj_files = list_files_in_directory(ai_super_dj_dir)

# Sjekker om filene inneholder onset-definisjoner
relevant_files = []
for file_path in enhanced_files + ai_super_dj_files:
    if file_path.endswith('.txt') and check_file_for_onsets(file_path):
        relevant_files.append(file_path)

# Skriver ut relevante filer som inneholder onset-definisjoner
print("Følgende filer inneholder onset-definisjoner:")
for file in relevant_files:
    print(file)

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Camelot Wheel mapping
camelot_wheel = {
    'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
    'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
    'Cm': '8A', 'C#m': '3A', 'Dm': '10A', 'D#m': '5A', 'Em': '12A', 'Fm': '7A',
    'F#m': '2A', 'Gm': '9A', 'G#m': '4A', 'Am': '11A', 'A#m': '6A', 'Bm': '1A'
}

# Last inn lydfilen
y, sr = librosa.load(audio_file_path)

# 1. Varighet i sekunder
duration = librosa.get_duration(y=y, sr=sr)
print(f"Varighet: {int(duration // 60):02d}:{int(duration % 60):02d}.{int((duration % 1) * 1000):03d}")

# 2. Juster onset deteksjonen: Bruk av `onset_detect` med justerte parametere
onset_env = librosa.onset.onset_strength(y=y, sr=sr, hop_length=512, aggregate=np.median)
onset_frames = librosa.onset.onset_detect(onset_envelope=onset_env, sr=sr, backtrack=True, units='frames')
onset_times = librosa.frames_to_time(onset_frames, sr=sr)

# Redusere antall onsets: Filtrer ut små onsets som er veldig nært hverandre
min_time_between_onsets = 1.0  # Minimum ett sekund mellom onsets
filtered_onset_times = []
last_onset_time = 0

for onset_time in onset_times:
    if onset_time - last_onset_time > min_time_between_onsets:
        filtered_onset_times.append(onset_time)
        last_onset_time = onset_time

print(f"Antall onsets etter filtrering: {len(filtered_onset_times)}")

# 3. Seksjoner: Klassifisering av musikkseksjoner basert på onset-styrke
def detect_sections(onset_env, sr):
    sections = []
    intro_threshold = np.percentile(onset_env, 25)
    breakdown_threshold = np.percentile(onset_env, 20)
    buildup_threshold = np.percentile(onset_env, 50)
    takeoff_threshold = np.percentile(onset_env, 80)
    outro_threshold = np.percentile(onset_env, 25)

    # Identifiser seksjoner (rekkefølgen viktig)
    if any(onset_env < intro_threshold):
        sections.append("Intro")
    if any(onset_env < breakdown_threshold):
        sections.append("Breakdown")
    if any(onset_env > buildup_threshold):
        sections.append("Build-up")
    if any(onset_env > takeoff_threshold):
        sections.append("Take-off")
    if any(onset_env < outro_threshold):
        sections.append("Outro")

    return sections

sections = detect_sections(onset_env, sr)
print(f"Seksjoner: {sections}")

# 4. BPM-analyse (Tempo)
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)

# Sjekk at tempo er et tall mellom 0 og 200
bpm_value = tempo[0] if isinstance(tempo, np.ndarray) else tempo

# Begrens BPM til å være mellom 0 og 200
bpm_value = min(max(bpm_value, 0), 200)

print(f"BPM (Tempo): {int(bpm_value)}")

# 5. Toneart (Key) og Camelot Key
def get_camelot_key(y, sr):
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)

    # Indikatorer for tonearter (dur og moll)
    major_profile = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1])  # C dur
    minor_profile = np.array([0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0])  # A moll

    # Normaliser chroma-dataene
    chroma_normalized = chroma / chroma.sum()

    # Beregn korrelasjonen med dur og moll profiler
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')

    # Finn tonearten som best matcher profilen
    key = 'C' if major_correlation.max() > minor_correlation.max() else 'Cm'
    camelot_key = camelot_wheel.get(key, 'Unknown Key')

    return key, camelot_key

key, camelot_key = get_camelot_key(y, sr)
print(f"Toneart (Key): {key}")
print(f"Camelot Key: {camelot_key}")

import os

# Opprett en ny mappe for å lagre informasjonen
base_dir = '/content/music_theory_and_onset_information'
if not os.path.exists(base_dir):
    os.makedirs(base_dir)

# Informasjon om musikkseksjoner, onset detection, og teori
wikipedia_info = """
Wikipedia-artikler og musikktermer:
- Gir grunnleggende innsikt i hvordan ulike seksjoner av en sang er strukturert.
- Begreper som 'Intro', 'Verse', 'Chorus', 'Breakdown', 'Build-up', 'Drop', og 'Outro' blir ofte brukt for å beskrive deler av en sang.
- Onset detection refererer til å finne starten av lyder eller hendelser i lydsignaler.
"""
glossary_info = """
Glossary of music terminology:
- Musikkterminologi som definisjoner for 'Coda', 'Bridge', 'Hook', 'Climax', og andre seksjoner.
- Kan hjelpe oss å forstå hva som utgjør de forskjellige seksjonene i musikk, spesielt innen sjangre som EDM, pop, rock, og klassisk musikk.
- Yousician har omfattende forklaringer på musikkstruktur som vi kan bruke for å forbedre onset detection.
"""
librosa_onset_info = """
Librosa onset detection:
- Dokumentasjonen for onset detection i librosa tilbyr mange parametere som kan justeres for bedre resultater.
- Parametere som backtrack, pre_max, post_max, delta påvirker hvordan onset detection kan oppfatte starten på en lyd.
"""
python_onset_detection_info = """
Python onset detection (GitHub):
- GitHub-repositorier inneholder tekniske kodeeksempler på onset detection.
- Ved å kombinere onset detection fra forskjellige kilder kan vi optimalisere resultater for spesifikke sjangre.
"""
edm_glossary_info = """
EDM-prod glossary:
- EDM-spesifikke termer som 'Build-up', 'Drop', 'Breakdown', 'Take-off' er nøkkelbegreper som er viktig å identifisere i elektronisk musikk.
- Kunnskap om denne sjangeren kan forbedre hvordan vi analyserer onsets i musikk med hurtige beats og intense overganger.
"""
mir_onset_info = """
musicinformationretrieval.com:
- En dyptgående ressurs om onset detection og musikkteknologi.
- Gir teknisk teori om hvordan man optimaliserer onset detection, inkludert bruk av spektrale funksjoner og dynamisk informasjon for å forbedre resultater.
"""

# Funksjon for å lagre informasjon til filer
def save_info_to_file(filename, content):
    filepath = os.path.join(base_dir, filename)
    with open(filepath, 'w') as file:
        file.write(content)
    print(f"Lagret: {filepath}")

# Lagre hver seksjon til en separat fil
save_info_to_file('wikipedia_musikkseksjoner.txt', wikipedia_info)
save_info_to_file('glossary_music_terminology.txt', glossary_info)
save_info_to_file('librosa_onset_detection.txt', librosa_onset_info)
save_info_to_file('python_onset_detection_github.txt', python_onset_detection_info)
save_info_to_file('edm_glossary.txt', edm_glossary_info)
save_info_to_file('mir_onset_detection.txt', mir_onset_info)

# Bekreft filene
print("\nAlle filer er opprettet og lagret i mappen.")

import requests
from bs4 import BeautifulSoup
import os

# Funksjon for å ekstrahere nøkkelsetninger fra en artikkel
def extract_key_sentences(article_url, important_words):
    response = requests.get(article_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    paragraphs = soup.find_all('p')
    extracted_sentences = []

    for paragraph in paragraphs:
        paragraph_text = paragraph.text.lower()
        if any(word in paragraph_text for word in important_words):
            extracted_sentences.append(paragraph.text.strip())
    return extracted_sentences

# Funksjon for å lagre artikkelinnholdet i en fil
def save_article_content(url, sentences, important_words):
    filename = url.split("/")[-1] + ".txt"
    save_path = f"/content/drive/My Drive/SuperDJ_Project/ai_super_dj/{filename}"

    with open(save_path, 'w', encoding='utf-8') as file:
        file.write(f"Nøkkelord brukt for utvalg: {', '.join(important_words)}\n\n")
        for sentence in sentences:
            file.write(sentence + '\n')

# Liste over lenker og viktige ord
urls_and_keywords = {
    "https://en.wikipedia.org/wiki/Onset_(audio)": ['onset', 'audio', 'detection'],
    "https://dsp.stackexchange.com/questions/18836/what-is-the-difference-between-pitch-detection-and-onset-detection": ['pitch', 'onset', 'detection'],
    "https://en.wikipedia.org/wiki/Glossary_of_music_terminology": ['glossary', 'music', 'terminology'],
    "https://www.classicfm.com/discover-music/musical-italian-terms/": ['music', 'terms', 'italian'],
    "https://yousician.com/blog/music-terminology": ['music', 'terminology'],
    "https://www.edmprod.com/electronic-music-production-glossary/": ['electronic', 'music', 'glossary', 'production'],
    "https://librosa.org/doc/main/generated/librosa.onset.onset_detect.html": ['librosa', 'onset', 'detection'],
    "https://www.freecodecamp.org/news/use-python-to-detect-music-onsets/": ['python', 'onset', 'detection'],
    "https://musicinformationretrieval.com/onset_detection.html": ['onset', 'detection', 'music'],
    "https://github.com/CPJKU/onset_detection/blob/master/onset_program.py": ['python', 'onset', 'detection']
}

# Kjør gjennom hver URL og prosesser dataene basert på nøkkelord
for url, important_words in urls_and_keywords.items():
    key_sentences = extract_key_sentences(url, important_words)
    save_article_content(url, key_sentences, important_words)

print("Ekstraksjon og lagring av viktige setninger fra artiklene fullført.")

import requests
from bs4 import BeautifulSoup
import os

# Funksjon for å ekstrahere nøkkelsetninger fra en artikkel
def extract_key_sentences(article_url, important_words):
    response = requests.get(article_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    paragraphs = soup.find_all('p')
    extracted_sentences = []

    for paragraph in paragraphs:
        paragraph_text = paragraph.text.lower()
        if any(word in paragraph_text for word in important_words):
            extracted_sentences.append(paragraph.text.strip())
    return extracted_sentences

# Funksjon for å lagre artikkelinnholdet i en fil
def save_article_content(url, sentences, important_words):
    filename = url.split("/")[-1] + ".txt"
    save_path = f"/content/drive/My Drive/SuperDJ_Project/ai_super_dj/{filename}"

    with open(save_path, 'w', encoding='utf-8') as file:
        file.write(f"Nøkkelord brukt for utvalg: {', '.join(important_words)}\n\n")
        for sentence in sentences:
            file.write(sentence + '\n')

    # Returnerer filstien etter at den er lagret
    return save_path

# Liste over lenker og spesifikke ordlister for hvert tema
articles_with_keywords = {
    "https://en.wikipedia.org/wiki/Onset_(audio)": ['onset', 'audio', 'detection', 'music'],
    "https://dsp.stackexchange.com/questions/18836/what-is-the-difference-between-pitch-detection-and-onset-detection": ['onset', 'pitch', 'detection'],
    "https://en.wikipedia.org/wiki/Glossary_of_music_terminology": ['music', 'terminology', 'glossary', 'tempo'],
    "https://www.classicfm.com/discover-music/musical-italian-terms/": ['music', 'terms', 'tempo'],
    "https://yousician.com/blog/music-terminology": ['terminology', 'music', 'theory', 'tempo'],
    "https://www.edmprod.com/electronic-music-production-glossary/": ['electronic', 'music', 'production', 'terms'],
    "https://librosa.org/doc/main/generated/librosa.onset.onset_detect.html": ['librosa', 'onset', 'detection'],
    "https://www.freecodecamp.org/news/use-python-to-detect-music-onsets/": ['python', 'music', 'onset', 'detection'],
    "https://musicinformationretrieval.com/onset_detection.html": ['onset', 'music', 'information', 'detection'],
    "https://github.com/CPJKU/onset_detection/blob/master/onset_program.py": ['onset', 'detection', 'python', 'program']
}

# Liste over alle filer og deres filstier
saved_files = []

# Kjør gjennom hver URL og prosesser dataene med spesifikke ord
for url, important_words in articles_with_keywords.items():
    key_sentences = extract_key_sentences(url, important_words)
    file_path = save_article_content(url, key_sentences, important_words)
    saved_files.append(file_path)

# Skriv ut alle filene som ble lagret
print("Følgende filer ble opprettet:")
for file in saved_files:
    print(f"Lagret: {file}")

import os

# Sti til mappen der filene er lagret
directory = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/'

# List opp alle filer i mappen
files = os.listdir(directory)

# Skriv ut alle filene med full filsti
print("Filer i mappen:")
for file in files:
    full_path = os.path.join(directory, file)
    print(full_path)

import os

# Sti til mappen der filene er lagret
directory = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/'

# Funksjon for å liste opp filer i mappen og legge til spesifikke ord for hver fil
def list_files_with_keywords(directory, file_keyword_map):
    files = os.listdir(directory)
    print("Filer og nøkkelord:")
    for file in files:
        full_path = os.path.join(directory, file)
        if file in file_keyword_map:
            keywords = file_keyword_map[file]
            print(f"{full_path}\n  Nøkkelord: {', '.join(keywords)}\n")
        else:
            print(f"{full_path}\n  Nøkkelord: Ingen spesifikke nøkkelord funnet.\n")

# Her legger vi inn ord som er valgt for hver fil, basert på tidligere analyse
file_keyword_map = {
    "Onset_(audio).txt": ['onset', 'detection', 'audio'],
    "what-is-the-difference-between-pitch-detection-and-onset-detection.txt": ['pitch', 'detection', 'onset'],
    "Glossary_of_music_terminology.txt": ['glossary', 'terms', 'music'],
    "music-terminology.txt": ['music', 'terminology', 'definitions'],
    "librosa.onset.onset_detect.html.txt": ['librosa', 'onset', 'detect'],
    "onset_detection.html.txt": ['onset', 'detection', 'techniques'],
    "onset_program.py.txt": ['program', 'onset', 'python'],
    # Legg til flere nøkkelord for de andre filene hvis ønskelig
}

# Kjør funksjonen for å liste opp filer og nøkkelord
list_files_with_keywords(directory, file_keyword_map)

import os

# Opprett en ordliste for hver fil, basert på tema
word_lists = {
    'Onset_(audio).txt': ['onset', 'attack', 'transient', 'detection', 'beat'],
    'what-is-the-difference-between-pitch-detection-and-onset-detection.txt': ['pitch', 'onset', 'frequency', 'detection'],
    'Glossary_of_music_terminology.txt': ['tempo', 'syncopation', 'cadence', 'rhythm', 'harmony'],
    'music-terminology.txt': ['tempo', 'pitch', 'dynamics', 'rhythm', 'key', 'harmony'],
    'librosa.onset.onset_detect.html.txt': ['onset', 'detection', 'librosa', 'function', 'threshold'],
    'onset_detection.html.txt': ['onset', 'detection', 'mir', 'music', 'signal', 'processing'],
    'onset_program.py.txt': ['python', 'onset', 'detection', 'audio', 'signal', 'processing'],
    # Legg til flere filer med relevante ord her om nødvendig
}

# Funksjon for å sjekke om nøkkelord er til stede i filene
def check_specific_words_in_files(word_lists, input_dir):
    for filename, word_list in word_lists.items():
        file_path = os.path.join(input_dir, filename)
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().lower()
                print(f'\nSjekker filen: {filename}')
                for word in word_list:
                    print(f'Er "{word}" til stede:', word in content)
        else:
            print(f'Filen {filename} ble ikke funnet i mappen.')

# Sti til mappen med tekstfiler
input_dir = '/content/drive/My Drive/SuperDJ_Project/ai_super_dj'

# Kjør sjekken
check_specific_words_in_files(word_lists, input_dir)

import requests
from bs4 import BeautifulSoup
import os

# Funksjon for å ekstrahere nøkkelsetninger fra en artikkel, basert på relevante ord
def extract_key_sentences(article_url, important_words):
    response = requests.get(article_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    paragraphs = soup.find_all('p')

    extracted_sentences = []
    for paragraph in paragraphs:
        paragraph_text = paragraph.text.lower()
        if any(word in paragraph_text for word in important_words):
            extracted_sentences.append(paragraph.text.strip())

    return extracted_sentences

# Funksjon for å lagre artikkelinnholdet i en fil
def save_article_content(url, sentences, important_words):
    filename = url.split("/")[-1] + ".txt"
    save_path = f"/content/drive/My Drive/SuperDJ_Project/ai_super_dj/{filename}"

    with open(save_path, 'w', encoding='utf-8') as file:
        file.write(f"Nøkkelord brukt for utvalg: {', '.join(important_words)}\n\n")
        for sentence in sentences:
            file.write(sentence + '\n')

# Liste over lenker og spesifikke ordlister for hvert tema
articles_with_keywords = {
    "https://dj.studio/blog/dj-mixing-beginners": ['mixing', 'cue', 'bpm', 'transition'],
    "https://dj.studio/blog/auto-mixing": ['ai', 'automation', 'software', 'mixing'],
    "https://dj.studio/blog/ai-dj-software": ['ai', 'algorithm', 'dj', 'software', 'mixing'],
    "https://dj.studio/blog/best-dj-software-for-mac": ['software', 'platform', 'mixing', 'cue'],
    "https://dj.studio/blog/ai-mixing-apps": ['ai', 'software', 'mixing', 'automation'],
    "https://dj.studio/blog/dj-crossfade-techniques": ['crossfade', 'transition', 'dj', 'mixing'],
    "https://dj.studio/blog/dj-tempo-change-techniques": ['tempo', 'bpm', 'transition', 'mixing'],
    "https://dj.studio/blog/phrasing-dj-mixing": ['phrasing', 'mixing', 'transition', 'dj'],
    "https://dj.studio/blog/dj-cue-points": ['cue', 'points', 'dj', 'mixing'],
    "https://dj.studio/blog/dj-beatgridding": ['beatgridding', 'bpm', 'sync', 'dj'],
    "https://dj.studio/blog/dj-inspiration": ['inspiration', 'creativity', 'dj', 'mixing'],
    "https://dj.studio/blog/mixing-db-levels": ['db', 'mixing', 'volume', 'levels'],
    "https://dj.studio/blog/dj-with-spotify": ['spotify', 'mixing', 'streaming', 'dj'],
    "https://dj.studio/blog/beat-matching-app": ['beatmatching', 'app', 'bpm', 'dj'],
    "https://dj.studio/blog/dj-mixing-effects": ['effects', 'mixing', 'dj', 'transition'],
    "https://dj.studio/blog/dj-mix-songs": ['mix', 'songs', 'dj', 'bpm'],
    "https://dj.studio/blog/master-a-dj-mix": ['master', 'mixing', 'dj', 'track'],
    "https://dj.studio/blog/advanced-dj-mixing-techniques": ['advanced', 'mixing', 'techniques', 'dj'],
    "https://dj.studio/blog/bad-dj-mixing-mistakes": ['mistakes', 'mixing', 'dj', 'avoid'],
    "https://dj.studio/blog/basic-transition-techniques": ['basic', 'transition', 'techniques', 'mixing'],
    "https://dj.studio/blog/bpm-house-music": ['bpm', 'house', 'mixing', 'dj'],
    "https://dj.studio/blog/camelot-wheel": ['camelot', 'key', 'mixing', 'dj'],
    "https://dj.studio/blog/guide-music-keygraph": ['keygraph', 'key', 'mixing', 'dj'],
    "https://wearecrossfader.co.uk/blog/how-pro-djs-mix-house-tech-how-its-done/": ['pro', 'mix', 'house', 'dj'],
}

# Kjør gjennom hver URL og prosesser dataene basert på nøkkelordene
for url, important_words in articles_with_keywords.items():
    key_sentences = extract_key_sentences(url, important_words)
    save_article_content(url, key_sentences, important_words)

print("Ekstraksjon og lagring av viktige setninger fullført.")

import os
import shutil

# Sti til de forskjellige mappene du vil samle filer fra
folders_to_collect_from = [
    '/content/drive/My Drive/SuperDJ_Project/ai_super_dj/enhanced_files',
    '/content/drive/My Drive/SuperDJ_Project/ai_super_dj',
    '/content/drive/My Drive/SuperDJ_Project/processed_ai_super_dj'
]

# Bestem hvor filene skal samles
target_directory = '/content/drive/My Drive/SuperDJ_Project/collected_files'

# Funksjon for å slå sammen filer med samme navn
def merge_files(file1, file2, output_file):
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Skriv innholdet av den første filen
        with open(file1, 'r', encoding='utf-8') as infile:
            outfile.write(infile.read())
            outfile.write("\n--- Samlet innhold fra to filer ---\n")  # Skiller mellom innhold fra de to filene
        # Skriv innholdet av den andre filen
        with open(file2, 'r', encoding='utf-8') as infile:
            outfile.write(infile.read())

# Funksjon for å samle filer fra flere mapper til en
def collect_and_merge_files(folders, target_directory):
    if not os.path.exists(target_directory):
        os.makedirs(target_directory)

    files_collected = {}  # Holder oversikt over hvilke filer som allerede er lagt til
    for folder in folders:
        for root, dirs, files in os.walk(folder):
            for file_name in files:
                source_file_path = os.path.join(root, file_name)
                target_file_path = os.path.join(target_directory, file_name)

                # Hvis filen allerede finnes i mål-mappen, slå sammen innholdet
                if file_name in files_collected:
                    print(f"Slår sammen: {file_name}")
                    merge_files(target_file_path, source_file_path, target_file_path)
                else:
                    # Kopier filen til mål-mappen
                    print(f"Kopierer: {file_name} til {target_directory}")
                    shutil.copy(source_file_path, target_file_path)
                    files_collected[file_name] = target_file_path

# Kjør funksjonen for å samle og slå sammen filer
collect_and_merge_files(folders_to_collect_from, target_directory)

print(f"Alle filer er samlet og lagret i {target_directory}.")

import os

collected_files_dir = '/content/drive/My Drive/SuperDJ_Project/collected_files'
for root, dirs, files in os.walk(collected_files_dir):
    for file in files:
        print(os.path.join(root, file))

import requests
from bs4 import BeautifulSoup
import os

# Funksjon for å ekstrahere nøkkelsetninger fra en artikkel, basert på relevante ord
def extract_key_sentences(article_url, important_words):
    response = requests.get(article_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    paragraphs = soup.find_all('p')

    extracted_sentences = []
    for paragraph in paragraphs:
        paragraph_text = paragraph.text.lower()
        if any(word in paragraph_text for word in important_words):
            extracted_sentences.append(paragraph.text.strip())

    return extracted_sentences

# Funksjon for å lagre artikkelinnholdet i en fil
def save_article_content(url, sentences, important_words):
    filename = "electronic_music_production_glossary.txt"
    save_path = f"/content/drive/My Drive/SuperDJ_Project/collected_files/{filename}"

    with open(save_path, 'w', encoding='utf-8') as file:
        file.write(f"Nøkkelord brukt for utvalg: {', '.join(important_words)}\n\n")
        for sentence in sentences:
            file.write(sentence + '\n')

# Spesifikke ord vi leter etter (kan tilpasses om nødvendig)
important_words = ['mixing', 'cue', 'bpm', 'transition', 'onset', 'build-up', 'breakdown', 'drop', 'intro', 'outro']

# URL til EDM-ordlisten
url = "https://www.edmprod.com/electronic-music-production-glossary/"

# Ekstrakt nøkkelsetninger fra artikkelen
key_sentences = extract_key_sentences(url, important_words)

# Lagre nøkkelsetningene i en fil
save_article_content(url, key_sentences, important_words)

print(f"Ekstraksjon og lagring av nøkkelsetninger fra {url} fullført.")

import requests
from bs4 import BeautifulSoup
import os

# Funksjon for å ekstrahere nøkkelsetninger fra en artikkel, basert på relevante ord
def extract_key_sentences(article_url, important_words):
    response = requests.get(article_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    paragraphs = soup.find_all('p')

    extracted_sentences = []
    for paragraph in paragraphs:
        paragraph_text = paragraph.text.lower()
        if any(word in paragraph_text for word in important_words):
            extracted_sentences.append(paragraph.text.strip())

    return extracted_sentences

# Funksjon for å lagre artikkelinnholdet i en fil
def save_article_content(url, sentences, important_words):
    filename = url.split("/")[-1] + ".txt"
    save_path = f"/content/drive/My Drive/SuperDJ_Project/collected_files/{filename}"

    with open(save_path, 'w', encoding='utf-8') as file:
        file.write(f"Nøkkelord brukt for utvalg: {', '.join(important_words)}\n\n")
        for sentence in sentences:
            file.write(sentence + '\n')

# Liste over lenker og spesifikke ordlister for hvert tema
articles_with_keywords = {
    "https://mixelite.com/blog/edm-song-structure/": ['intro', 'build-up', 'drop', 'breakdown', 'outro', 'transition', 'chorus', 'verse', 'onset'],
    # Legg til flere lenker her etter behov
}

# Kjør gjennom hver URL og prosesser dataene basert på nøkkelordene
for url, important_words in articles_with_keywords.items():
    key_sentences = extract_key_sentences(url, important_words)
    save_article_content(url, key_sentences, important_words)

print("Ekstraksjon og lagring av viktige setninger fra den nye EDM-lenken fullført.")

Flott, vi kan oppdatere koden for å sjekke filer i mappen `f"/content/drive/My Drive/SuperDJ_Project/collected_files/` og samtidig legge til flere seksjoner basert på all informasjonen vi har samlet.

Her er den oppdaterte koden:

```python
import os
import librosa
import numpy as np

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å lese tekstfil og sjekke om den inneholder onset-definisjoner
def check_file_for_onsets(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
        if 'onset' in content.lower():  # Sjekker om filen nevner 'onset'
            return True
    return False

# Sjekk filer i den samlete mappen
collected_files_dir = '/content/drive/My Drive/SuperDJ_Project/collected_files'

collected_files = list_files_in_directory(collected_files_dir)

# Sjekker om filene inneholder onset-definisjoner
relevant_files = []
for file_path in collected_files:
    if file_path.endswith('.txt') and check_file_for_onsets(file_path):
        relevant_files.append(file_path)

# Skriver ut relevante filer som inneholder onset-definisjoner
print("Følgende filer inneholder onset-definisjoner:")
for file in relevant_files:
    print(file)

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Camelot Wheel mapping
camelot_wheel = {
    'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
    'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
    'Cm': '8A', 'C#m': '3A', 'Dm': '10A', 'D#m': '5A', 'Em': '12A', 'Fm': '7A',
    'F#m': '2A', 'Gm': '9A', 'G#m': '4A', 'Am': '11A', 'A#m': '6A', 'Bm': '1A'
}

# Last inn lydfilen
y, sr = librosa.load(audio_file_path)

# 1. Varighet i sekunder
duration = librosa.get_duration(y=y, sr=sr)
print(f"Varighet: {int(duration // 60):02d}:{int(duration % 60):02d}.{int((duration % 1) * 1000):03d}")

# 2. Onsets: Teller antall onsets og returnerer hvor mange ganger de oppstår
onset_env = librosa.onset.onset_strength(y=y, sr=sr)
onset_frames = librosa.onset.onset_detect(onset_envelope=onset_env, sr=sr)
onset_times = librosa.frames_to_time(onset_frames, sr=sr)
print(f"Antall onsets: {len(onset_times)}")

# 3. Seksjoner: Klassifisering av musikkseksjoner basert på onset-styrke
def detect_sections(onset_env, sr):
    sections = []
    intro_threshold = np.percentile(onset_env, 25)
    breakdown_threshold = np.percentile(onset_env, 20)
    buildup_threshold = np.percentile(onset_env, 50)
    drop_threshold = np.percentile(onset_env, 70)
    takeoff_threshold = np.percentile(onset_env, 80)
    outro_threshold = np.percentile(onset_env, 25)

    # Identifiser seksjoner (rekkefølgen viktig)
    if any(onset_env < intro_threshold):
        sections.append("Intro")
    if any(onset_env < breakdown_threshold):
        sections.append("Breakdown")
    if any(onset_env > buildup_threshold):
        sections.append("Build-up")
    if any(onset_env > drop_threshold):
        sections.append("Drop")
    if any(onset_env > takeoff_threshold):
        sections.append("Take-off")
    if any(onset_env < outro_threshold):
        sections.append("Outro")

    return sections

sections = detect_sections(onset_env, sr)
print(f"Seksjoner: {sections}")

# 4. BPM-analyse (Tempo)
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)

# Sjekk at tempo er et tall mellom 0 og 200
bpm_value = tempo[0] if isinstance(tempo, np.ndarray) else tempo

# Begrens BPM til å være mellom 0 og 200
bpm_value = min(max(bpm_value, 0), 200)

print(f"BPM (Tempo): {int(bpm_value)}")

# 5. Toneart (Key) og Camelot Key
def get_camelot_key(y, sr):
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)

    # Indikatorer for tonearter (dur og

import os
import librosa
import numpy as np

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å lese tekstfil og sjekke om den inneholder onset-definisjoner
def check_file_for_onsets(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
        if 'onset' in content.lower():  # Sjekker om filen nevner 'onset'
            return True
    return False

# Sjekk filer i den samlete mappen
collected_files_dir = '/content/drive/My Drive/SuperDJ_Project/collected_files'

collected_files = list_files_in_directory(collected_files_dir)

# Sjekker om filene inneholder onset-definisjoner
relevant_files = []
for file_path in collected_files:
    if file_path.endswith('.txt') and check_file_for_onsets(file_path):
        relevant_files.append(file_path)

# Skriver ut relevante filer som inneholder onset-definisjoner
print("Følgende filer inneholder onset-definisjoner:")
for file in relevant_files:
    print(file)

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Camelot Wheel mapping
camelot_wheel = {
    'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
    'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
    'Cm': '8A', 'C#m': '3A', 'Dm': '10A', 'D#m': '5A', 'Em': '12A', 'Fm': '7A',
    'F#m': '2A', 'Gm': '9A', 'G#m': '4A', 'Am': '11A', 'A#m': '6A', 'Bm': '1A'
}

# Last inn lydfilen
y, sr = librosa.load(audio_file_path)

# 1. Varighet i sekunder
duration = librosa.get_duration(y=y, sr=sr)
print(f"Varighet: {int(duration // 60):02d}:{int(duration % 60):02d}.{int((duration % 1) * 1000):03d}")

# 2. Onsets: Teller antall onsets og returnerer hvor mange ganger de oppstår
onset_env = librosa.onset.onset_strength(y=y, sr=sr)
onset_frames = librosa.onset.onset_detect(onset_envelope=onset_env, sr=sr)
onset_times = librosa.frames_to_time(onset_frames, sr=sr)
print(f"Antall onsets: {len(onset_times)}")

import os
import librosa
import numpy as np

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å hente informasjon fra relevante filer
def extract_information_from_files(directory):
    important_info = []
    files = list_files_in_directory(directory)
    for file_path in files:
        if file_path.endswith('.txt'):
            with open(file_path, 'r') as file:
                content = file.read()
                # Ekstrakt nøkkelinfo - kan tilpasses hva du ønsker å hente fra filene
                important_info.append(content)  # Samler innholdet fra filene
    return " ".join(important_info)  # Returnerer all informasjonen som én stor tekststreng

# Sjekk filer i mappen
collected_files_dir = '/content/drive/My Drive/SuperDJ_Project/collected_files/'

# Hent viktig informasjon fra filene
additional_info = extract_information_from_files(collected_files_dir)
print(f"Ekstra informasjon hentet fra filene: {additional_info[:500]}...")  # Vis første 500 tegn

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Camelot Wheel mapping
camelot_wheel = {
    'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
    'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
    'Cm': '8A', 'C#m': '3A', 'Dm': '10A', 'D#m': '5A', 'Em': '12A', 'Fm': '7A',
    'F#m': '2A', 'Gm': '9A', 'G#m': '4A', 'Am': '11A', 'A#m': '6A', 'Bm': '1A'
}

# Last inn lydfilen
y, sr = librosa.load(audio_file_path)

# 1. Varighet i sekunder
duration = librosa.get_duration(y=y, sr=sr)
print(f"Varighet: {int(duration // 60):02d}:{int(duration % 60):02d}.{int((duration % 1) * 1000):03d}")

# 2. Onsets: Teller antall onsets og returnerer hvor mange ganger de oppstår
onset_env = librosa.onset.onset_strength(y=y, sr=sr)
onset_frames = librosa.onset.onset_detect(onset_envelope=onset_env, sr=sr)
onset_times = librosa.frames_to_time(onset_frames, sr=sr)
print(f"Antall onsets: {len(onset_times)}")

# 3. Seksjoner: Klassifisering av musikkseksjoner basert på onset-styrke, med mulig påvirkning fra fildata
def detect_sections(onset_env, sr, additional_info):
    sections = []

    # Tilpass tersklene basert på informasjon fra filene (dette kan gjøres mer avansert)
    intro_threshold = np.percentile(onset_env, 25)
    breakdown_threshold = np.percentile(onset_env, 20)
    buildup_threshold = np.percentile(onset_env, 50)
    takeoff_threshold = np.percentile(onset_env, 80)
    outro_threshold = np.percentile(onset_env, 25)

    # Bruk informasjon fra filene (kan forbedres med spesifikk logikk basert på filinnhold)
    if 'intro' in additional_info.lower():
        sections.append("Intro")
    if 'breakdown' in additional_info.lower():
        sections.append("Breakdown")
    if 'build-up' in additional_info.lower() or any(onset_env > buildup_threshold):
        sections.append("Build-up")
    if 'take-off' in additional_info.lower() or any(onset_env > takeoff_threshold):
        sections.append("Take-off")
    if 'outro' in additional_info.lower():
        sections.append("Outro")

    return sections

sections = detect_sections(onset_env, sr, additional_info)
print(f"Seksjoner: {sections}")

# 4. BPM-analyse (Tempo)
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)

# Sjekk at tempo er et tall mellom 0 og 200
bpm_value = tempo[0] if isinstance(tempo, np.ndarray) else tempo

# Begrens BPM til å være mellom 0 og 200
bpm_value = min(max(bpm_value, 0), 200)

print(f"BPM (Tempo): {int(bpm_value)}")

# 5. Toneart (Key) og Camelot Key
def get_camelot_key(y, sr):
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)

    # Indikatorer for tonearter (dur og moll)
    major_profile = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1])  # C dur
    minor_profile = np.array([0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0])  # A moll

    # Normaliser chroma-dataene
    chroma_normalized = chroma / chroma.sum()

    # Beregn korrelasjonen med dur og moll profiler
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')

    # Finn tonearten som best matcher profilen
    key = 'C' if major_correlation.max() > minor_correlation.max() else 'Cm'
    camelot_key = camelot_wheel.get(key, 'Unknown Key')

    return key, camelot_key

key, camelot_key = get_camelot_key(y, sr)
print(f"Toneart (Key): {key}")
print(f"Camelot Key: {camelot_key}")

import os
import librosa
import numpy as np

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å hente informasjon fra relevante filer
def extract_information_from_files(directory):
    important_info = []
    files = list_files_in_directory(directory)
    for file_path in files:
        if file_path.endswith('.txt'):
            with open(file_path, 'r') as file:
                content = file.read()
                important_info.append(content)  # Samler innholdet fra filene
    return " ".join(important_info)  # Returnerer all informasjonen som én stor tekststreng

# Tilpassede terskler for ulike sjangre innen elektronisk musikk
def detect_onsets_based_on_genre(y, sr, genre='edm'):
    # Standard terskler for EDM
    thresholds = {
        'intro': 25,
        'breakdown': 20,
        'buildup': 50,
        'takeoff': 80
    }

    # Tilpass tersklene basert på sjanger
    if genre == 'house':
        thresholds = {
            'intro': 30,
            'breakdown': 25,
            'buildup': 55,
            'takeoff': 75
        }
    elif genre == 'techno':
        thresholds = {
            'intro': 35,
            'breakdown': 30,
            'buildup': 60,
            'takeoff': 85
        }
    elif genre == 'trance':
        thresholds = {
            'intro': 40,
            'breakdown': 35,
            'buildup': 65,
            'takeoff': 90
        }
    elif genre == 'psytrance':
        thresholds = {
            'intro': 45,
            'breakdown': 40,
            'buildup': 70,
            'takeoff': 95
        }
    elif genre == 'dubstep':
        thresholds = {
            'intro': 20,
            'breakdown': 15,
            'buildup': 45,
            'takeoff': 70
        }
    elif genre == 'drum and bass':
        thresholds = {
            'intro': 25,
            'breakdown': 20,
            'buildup': 50,
            'takeoff': 75
        }

    # Onset-detection logikk basert på terskler
    onset_env = librosa.onset.onset_strength(y=y, sr=sr)
    intro_threshold = np.percentile(onset_env, thresholds['intro'])
    breakdown_threshold = np.percentile(onset_env, thresholds['breakdown'])
    buildup_threshold = np.percentile(onset_env, thresholds['buildup'])
    takeoff_threshold = np.percentile(onset_env, thresholds['takeoff'])

    # Identifisering av seksjoner basert på terskler
    sections = []
    if any(onset_env < intro_threshold):
        sections.append('Intro')
    if any(onset_env < breakdown_threshold):
        sections.append('Breakdown')
    if any(onset_env > buildup_threshold):
        sections.append('Build-up')
    if any(onset_env > takeoff_threshold):
        sections.append('Take-off')

    return sections

# Hent informasjon fra filer for å analysere
collected_files_dir = '/content/drive/My Drive/SuperDJ_Project/collected_files/'
additional_info = extract_information_from_files(collected_files_dir)
print(f"Ekstra informasjon hentet fra filene: {additional_info[:500]}...")  # Vis første 500 tegn

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
y, sr = librosa.load(audio_file_path)

# Velg sjanger du vil analysere
genre = 'house'  # Kan være 'edm', 'house', 'techno', 'trance', 'psytrance', 'dubstep', 'drum and bass'

# Onset-detection basert på valgt sjanger
sections = detect_onsets_based_on_genre(y, sr, genre=genre)
print(f"Seksjoner for sjangeren '{genre}': {sections}")

# BPM-analyse
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
bpm_value = tempo if isinstance(tempo, float) else tempo[0]
print(f"BPM (Tempo): {int(bpm_value)}")

# Funksjon for å bestemme toneart (key) og Camelot Key
def get_camelot_key(y, sr):
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)
    major_profile = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1])  # C dur
    minor_profile = np.array([0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0])  # A moll
    chroma_normalized = chroma / chroma.sum()
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')

    # Bestem tonearten basert på høyeste korrelasjon
    key = 'C' if major_correlation.max() > minor_correlation.max() else 'Cm'
    camelot_key = camelot_wheel.get(key, 'Unknown Key')

    return key, camelot_key

# Beregn toneart og Camelot Key
key, camelot_key = get_camelot_key(y, sr)
print(f"Toneart (Key): {key}")
print(f"Camelot Key: {camelot_key}")

import requests
from bs4 import BeautifulSoup

# Funksjon for å ekstrahere sjangere fra en nettside
def extract_genres_from_everynoise(url):
    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')
    genres = [a.text.strip() for a in soup.find_all('a', class_='genre')]
    return genres

# URL til Every Noise At Once
everynoise_url = 'https://everynoise.com/'

# Hent sjangerinformasjon
genres = extract_genres_from_everynoise(everynoise_url)

# Lagre sjangrene i en fil
with open('/content/drive/My Drive/SuperDJ_Project/collected_files/everynoise_genres.txt', 'w') as file:
    file.write("\n".join(genres))

print(f"{len(genres)} sjangre hentet fra Every Noise At Once.")

import requests
from bs4 import BeautifulSoup

# Funksjon for å hente de viktigste sjangrene fra Every Noise at Once
def fetch_top_genres(url, number_of_genres=30):
    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')

    # Finn sjangrene på nettsiden, her ser vi etter <div> elementer som kan inneholde sjangrene
    genre_elements = soup.find_all('div', class_='genre')[:number_of_genres]  # Begrens til de 30 første sjangrene

    # Ekstrahere sjangrene og legge dem til i en liste
    top_genres = [genre.text.strip() for genre in genre_elements]

    return top_genres

# Hent de 30 viktigste sjangrene
url = "https://everynoise.com/"
top_genres = fetch_top_genres(url)

# Skriv ut sjangrene
print("De 30 viktigste sjangrene hentet fra Every Noise at Once:")
for i, genre in enumerate(top_genres, 1):
    print(f"{i}. {genre}")

import requests
from bs4 import BeautifulSoup
import os

# Funksjon for å ekstrahere nøkkelsetninger fra en artikkel, basert på relevante ord
def extract_key_sentences(article_url, important_words):
    response = requests.get(article_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    paragraphs = soup.find_all('p')

    extracted_sentences = []
    for paragraph in paragraphs:
        paragraph_text = paragraph.text.lower()
        if any(word in paragraph_text for word in important_words):
            extracted_sentences.append(paragraph.text.strip())

    return extracted_sentences

# Funksjon for å lagre artikkelinnholdet i en fil
def save_article_content(url, sentences, important_words):
    filename = url.split("/")[-1] + ".txt"
    save_path = f"/content/drive/My Drive/SuperDJ_Project/collected_files/{filename}"

    with open(save_path, 'w', encoding='utf-8') as file:
        file.write(f"Nøkkelord brukt for utvalg: {', '.join(important_words)}\n\n")
        for sentence in sentences:
            file.write(sentence + '\n')

# Liste over sjangerbaserte ord og deres EDM-subkategorier
edm_genres = [
    'house', 'techno', 'trance', 'dubstep', 'drum and bass', 'hardcore',
    'deep house', 'progressive house', 'acid techno', 'minimal techno',
    'psytrance', 'future bass', 'electro house', 'chillout', 'ambient',
    'downtempo', 'breakbeat', 'tech house', 'melodic techno', 'trap edm',
    'glitch hop', 'big room house', 'future house', 'hardstyle', 'eurodance',
    'electro swing', 'french house', 'gabber', 'progressive trance', 'goa trance'
]

# Eksempel artikkel URL som vi kan analysere
articles_with_keywords = {
    "https://everynoise.com/": edm_genres,
    "https://music.ishkur.com/": edm_genres
}

# Kjør gjennom hver URL og prosesser dataene basert på EDM sjangrene
for url, important_words in articles_with_keywords.items():
    key_sentences = extract_key_sentences(url, important_words)
    save_article_content(url, key_sentences, important_words)

print("Ekstraksjon og lagring av viktige setninger for EDM-sjangre fullført.")

import os
import librosa
import numpy as np

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å hente informasjon fra relevante filer
def extract_information_from_files(directory):
    important_info = []
    files = list_files_in_directory(directory)
    for file_path in files:
        if file_path.endswith('.txt'):
            with open(file_path, 'r') as file:
                content = file.read()
                important_info.append(content)  # Samler innholdet fra filene
    return " ".join(important_info)  # Returnerer all informasjonen som én stor tekststreng

# Tilpassede terskler for ulike sjangre innen elektronisk musikk
def detect_onsets_based_on_genre(y, sr, genre='edm'):
    # Standard terskler for EDM
    thresholds = {
        'intro': 25,
        'breakdown': 20,
        'buildup': 50,
        'takeoff': 80
    }

    # Tilpass tersklene basert på sjanger
    if genre == 'house':
        thresholds = {
            'intro': 30,
            'breakdown': 25,
            'buildup': 55,
            'takeoff': 75
        }
    elif genre == 'techno':
        thresholds = {
            'intro': 35,
            'breakdown': 30,
            'buildup': 60,
            'takeoff': 85
        }
    elif genre == 'trance':
        thresholds = {
            'intro': 40,
            'breakdown': 35,
            'buildup': 65,
            'takeoff': 90
        }
    elif genre == 'psytrance':
        thresholds = {
            'intro': 45,
            'breakdown': 40,
            'buildup': 70,
            'takeoff': 95
        }
    elif genre == 'dubstep':
        thresholds = {
            'intro': 20,
            'breakdown': 15,
            'buildup': 45,
            'takeoff': 70
        }
    elif genre == 'drum and bass':
        thresholds = {
            'intro': 25,
            'breakdown': 20,
            'buildup': 50,
            'takeoff': 75
        }

    # Onset-detection logikk basert på terskler
    onset_env = librosa.onset.onset_strength(y=y, sr=sr)
    intro_threshold = np.percentile(onset_env, thresholds['intro'])
    breakdown_threshold = np.percentile(onset_env, thresholds['breakdown'])
    buildup_threshold = np.percentile(onset_env, thresholds['buildup'])
    takeoff_threshold = np.percentile(onset_env, thresholds['takeoff'])

    # Identifisering av seksjoner basert på terskler
    sections = []
    if any(onset_env < intro_threshold):
        sections.append('Intro')
    if any(onset_env < breakdown_threshold):
        sections.append('Breakdown')
    if any(onset_env > buildup_threshold):
        sections.append('Build-up')
    if any(onset_env > takeoff_threshold):
        sections.append('Take-off')

    return sections

# Hent informasjon fra filer for å analysere
collected_files_dir = '/content/drive/My Drive/SuperDJ_Project/collected_files/'
additional_info = extract_information_from_files(collected_files_dir)
print(f"Ekstra informasjon hentet fra filene: {additional_info[:500]}...")  # Vis første 500 tegn

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
y, sr = librosa.load(audio_file_path)

# Velg sjanger du vil analysere
genre = 'house'  # Kan være 'edm', 'house', 'techno', 'trance', 'psytrance', 'dubstep', 'drum and bass'

# Onset-detection basert på valgt sjanger
sections = detect_onsets_based_on_genre(y, sr, genre=genre)
print(f"Seksjoner for sjangeren '{genre}': {sections}")

# BPM-analyse
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
bpm_value = tempo if isinstance(tempo, float) else tempo[0]
print(f"BPM (Tempo): {int(bpm_value)}")

# Funksjon for å bestemme toneart (key) og Camelot Key
def get_camelot_key(y, sr):
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)
    major_profile = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1])  # C dur
    minor_profile = np.array([0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0])  # A moll
    chroma_normalized = chroma / chroma.sum()
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')

    # Finn tonearten som best matcher profilen
    key = 'C' if major_correlation.max() > minor_correlation.max() else 'Cm'
    camelot_key = camelot_wheel.get(key, 'Unknown Key')

    return key, camelot_key

key, camelot_key = get_camelot_key(y, sr)
print(f"Toneart (Key): {key}")
print(f"Camelot Key: {camelot_key}")

import os
import librosa
import numpy as np

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å hente informasjon fra relevante filer
def extract_information_from_files(directory):
    important_info = []
    files = list_files_in_directory(directory)
    for file_path in files:
        if file_path.endswith('.txt'):
            with open(file_path, 'r') as file:
                content = file.read()
                important_info.append(content)  # Samler innholdet fra filene
    return " ".join(important_info)  # Returnerer all informasjonen som én stor tekststreng

# Tilpassede terskler for ulike sjangre innen elektronisk musikk
def detect_onsets_based_on_genre(y, sr, genre='edm'):
    # Standard terskler for EDM
    thresholds = {
        'intro': 25,
        'breakdown': 20,
        'buildup': 50,
        'takeoff': 80
    }

    # Tilpass tersklene basert på sjanger
    if genre == 'house':
        thresholds = {
            'intro': 30,
            'breakdown': 25,
            'buildup': 55,
            'takeoff': 75
        }
    elif genre == 'techno':
        thresholds = {
            'intro': 35,
            'breakdown': 30,
            'buildup': 60,
            'takeoff': 85
        }
    elif genre == 'trance':
        thresholds = {
            'intro': 40,
            'breakdown': 35,
            'buildup': 65,
            'takeoff': 90
        }
    elif genre == 'psytrance':
        thresholds = {
            'intro': 45,
            'breakdown': 40,
            'buildup': 70,
            'takeoff': 95
        }
    elif genre == 'dubstep':
        thresholds = {
            'intro': 20,
            'breakdown': 15,
            'buildup': 45,
            'takeoff': 70
        }
    elif genre == 'drum and bass':
        thresholds = {
            'intro': 25,
            'breakdown': 20,
            'buildup': 50,
            'takeoff': 75
        }
    elif genre == 'hardcore':
        thresholds = {
            'intro': 50,
            'breakdown': 45,
            'buildup': 75,
            'takeoff': 100
        }
    elif genre == 'downtempo':
        thresholds = {
            'intro': 15,
            'breakdown': 10,
            'buildup': 30,
            'takeoff': 50
        }
    elif genre == 'electronica':
        thresholds = {
            'intro': 20,
            'breakdown': 15,
            'buildup': 40,
            'takeoff': 60
        }

    # Onset-detection logikk basert på terskler
    onset_env = librosa.onset.onset_strength(y=y, sr=sr)
    intro_threshold = np.percentile(onset_env, thresholds['intro'])
    breakdown_threshold = np.percentile(onset_env, thresholds['breakdown'])
    buildup_threshold = np.percentile(onset_env, thresholds['buildup'])
    takeoff_threshold = np.percentile(onset_env, thresholds['takeoff'])

    # Identifisering av seksjoner basert på terskler
    sections = []
    if any(onset_env < intro_threshold):
        sections.append('Intro')
    if any(onset_env < breakdown_threshold):
        sections.append('Breakdown')
    if any(onset_env > buildup_threshold):
        sections.append('Build-up')
    if any(onset_env > takeoff_threshold):
        sections.append('Take-off')

    return sections

# Hent informasjon fra filer for å analysere
collected_files_dir = '/content/drive/My Drive/SuperDJ_Project/collected_files/'
additional_info = extract_information_from_files(collected_files_dir)
print(f"Ekstra informasjon hentet fra filene: {additional_info[:500]}...")  # Vis første 500 tegn

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/17985216_Spring Girl_(Extended).mp3'
y, sr = librosa.load(audio_file_path)

# Velg sjanger du vil analysere
genre = 'techno'  # Kan være 'edm', 'house', 'techno', 'trance', 'psytrance', 'dubstep', 'drum and bass', 'hardcore', 'downtempo', 'electronica'

# Onset-detection basert på valgt sjanger
sections = detect_onsets_based_on_genre(y, sr, genre=genre)
print(f"Seksjoner for sjangeren '{genre}': {sections}")

# BPM-analyse
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
bpm_value = tempo if isinstance(tempo, float) else tempo[0]
print(f"BPM (Tempo): {int(bpm_value)}")

# Funksjon for å bestemme toneart (key) og Camelot Key
def get_camelot_key(y, sr):
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)
    major_profile = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1])  # C dur
    minor_profile = np.array([0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0])  # A moll
    chroma_normalized = chroma / chroma.sum()
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')

    # Finn tonearten som best matcher profilen
    key = 'C' if major_correlation.max() > minor_correlation.max() else 'Cm'
    camelot_key = camelot_wheel.get(key, 'Unknown Key')

    return key, camelot_key

key, camelot_key = get_camelot_key(y, sr)
print(f"Toneart (Key): {key}")
print(f"Camelot Key: {camelot_key}")

import os
import librosa
import numpy as np

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å hente informasjon fra relevante filer
def extract_information_from_files(directory):
    important_info = []
    files = list_files_in_directory(directory)
    for file_path in files:
        if file_path.endswith('.txt'):
            with open(file_path, 'r') as file:
                content = file.read()
                important_info.append(content)  # Samler innholdet fra filene
    return " ".join(important_info)  # Returnerer all informasjonen som én stor tekststreng

# Tilpassede terskler for ulike sjangre innen elektronisk musikk
def detect_onsets_based_on_genre(y, sr, genre='edm'):
    # Standard terskler for sjangre
    thresholds = {
        'intro': 25,
        'breakdown': 20,
        'buildup': 50,
        'takeoff': 80
    }

    # Tilpass tersklene basert på sjanger
    if genre == 'house':
        bpm_range = (110, 130)
        thresholds = {
            'intro': 30,
            'breakdown': 25,
            'buildup': 55,
            'takeoff': 75
        }
    elif genre == 'techno':
        bpm_range = (120, 140)
        thresholds = {
            'intro': 35,
            'breakdown': 30,
            'buildup': 60,
            'takeoff': 85
        }
    elif genre == 'trance':
        bpm_range = (130, 145)
        thresholds = {
            'intro': 40,
            'breakdown': 35,
            'buildup': 65,
            'takeoff': 90
        }
    elif genre == 'psytrance':
        bpm_range = (135, 150)
        thresholds = {
            'intro': 45,
            'breakdown': 40,
            'buildup': 70,
            'takeoff': 95
        }
    elif genre == 'dubstep':
        bpm_range = (70, 75)
        thresholds = {
            'intro': 20,
            'breakdown': 15,
            'buildup': 45,
            'takeoff': 70
        }
    elif genre == 'hardcore':
        bpm_range = (140, 200)
        thresholds = {
            'intro': 50,
            'breakdown': 45,
            'buildup': 75,
            'takeoff': 90
        }
    elif genre == 'downtempo':
        bpm_range = (90, 110)
        thresholds = {
            'intro': 20,
            'breakdown': 15,
            'buildup': 40,
            'takeoff': 60
        }
    elif genre == 'electronica':
        bpm_range = (100, 140)  # Varierende BPM
        thresholds = {
            'intro': 25,
            'breakdown': 20,
            'buildup': 50,
            'takeoff': 80
        }
    else:
        bpm_range = (110, 140)  # Standard EDM

    # Onset-detection logikk basert på terskler
    onset_env = librosa.onset.onset_strength(y=y, sr=sr)
    intro_threshold = np.percentile(onset_env, thresholds['intro'])
    breakdown_threshold = np.percentile(onset_env, thresholds['breakdown'])
    buildup_threshold = np.percentile(onset_env, thresholds['buildup'])
    takeoff_threshold = np.percentile(onset_env, thresholds['takeoff'])

    # Identifisering av seksjoner basert på terskler
    sections = []
    if any(onset_env < intro_threshold):
        sections.append('Intro')
    if any(onset_env < breakdown_threshold):
        sections.append('Breakdown')
    if any(onset_env > buildup_threshold):
        sections.append('Build-up')
    if any(onset_env > takeoff_threshold):
        sections.append('Take-off')

    return sections, bpm_range

# Hent informasjon fra filer for å analysere
collected_files_dir = '/content/drive/My Drive/SuperDJ_Project/collected_files/'
additional_info = extract_information_from_files(collected_files_dir)
print(f"Ekstra informasjon hentet fra filene: {additional_info[:500]}...")  # Vis første 500 tegn

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/17985216_Spring Girl_(Extended).mp3'
y, sr = librosa.load(audio_file_path)

# Velg sjanger du vil analysere
genre = 'techno'  # Kan være 'edm', 'house', 'techno', 'trance', 'psytrance', 'dubstep', 'hardcore', 'downtempo', 'electronica'

# Onset-detection basert på valgt sjanger
sections, bpm_range = detect_onsets_based_on_genre(y, sr, genre=genre)
print(f"Seksjoner for sjangeren '{genre}': {sections}")

# BPM-analyse
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
bpm_value = tempo if isinstance(tempo, float) else tempo[0]

# Sammenlign BPM med sjangerens BPM-område
if bpm_range[0] <= bpm_value <= bpm_range[1]:
    bpm_validity = "BPM passer innenfor sjangerens område."
else:
    bpm_validity = "BPM faller utenfor sjangerens typiske område."

print(f"BPM (Tempo): {int(bpm_value)} - {bpm_validity}")

# Funksjon for å bestemme toneart (key) og Camelot Key
def get_camelot_key(y, sr):
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)
    major_profile = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1])  # C dur
    minor_profile = np.array([0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0])  # A moll
    chroma_normalized = chroma / chroma.sum()
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')

    key = 'C' if major_correlation.max() > minor_correlation.max() else 'Cm'
    camelot_wheel = {
        'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
        'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
        'Cm': '8A', 'C#m': '3A', 'Dm': '10A', 'D#m': '5A', 'Em': '12A', 'Fm': '7A',
        'F#m': '2A', 'Gm': '9A', 'G#m': '4A', 'Am': '11A', 'A#m': '6A', 'Bm': '1A'
    }
    camelot_key = camelot_wheel.get(key, 'Unknown Key')

    return key, camelot_key

key, camelot_key = get_camelot_key(y, sr)
print(f"Toneart (Key): {key}")
print(f"Camelot Key: {camelot_key}")

import os
import librosa
import numpy as np

# Funksjon for å hente sjanger basert på BPM
def classify_genre_based_on_bpm(bpm_value):
    if 110 <= bpm_value <= 130:
        return 'house'
    elif 120 <= bpm_value <= 140:
        return 'techno'
    elif 130 <= bpm_value <= 145:
        return 'trance'
    elif 140 <= bpm_value <= 200:
        return 'hardcore'
    elif 160 <= bpm_value <= 180:
        return 'hard house'
    elif 90 <= bpm_value <= 110:
        return 'downtempo'
    elif 70 <= bpm_value <= 75:
        return 'dubstep'
    else:
        return 'edm'  # Standard sjanger om BPM ikke matcher de andre

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å hente informasjon fra relevante filer
def extract_information_from_files(directory):
    important_info = []
    files = list_files_in_directory(directory)
    for file_path in files:
        if file_path.endswith('.txt'):
            with open(file_path, 'r') as file:
                content = file.read()
                important_info.append(content)  # Samler innholdet fra filene
    return " ".join(important_info)  # Returnerer all informasjonen som én stor tekststreng

# Funksjon for å bestemme sjanger basert på onset-terskler
def detect_onsets_based_on_genre(y, sr, genre='edm'):
    # Standard terskler for EDM
    thresholds = {
        'intro': 25,
        'breakdown': 20,
        'buildup': 50,
        'takeoff': 80
    }

    # Tilpass tersklene basert på sjanger
    if genre == 'house':
        thresholds = {
            'intro': 30,
            'breakdown': 25,
            'buildup': 55,
            'takeoff': 75
        }
    elif genre == 'techno':
        thresholds = {
            'intro': 35,
            'breakdown': 30,
            'buildup': 60,
            'takeoff': 85
        }
    elif genre == 'trance':
        thresholds = {
            'intro': 40,
            'breakdown': 35,
            'buildup': 65,
            'takeoff': 90
        }
    elif genre == 'hardcore':
        thresholds = {
            'intro': 50,
            'breakdown': 45,
            'buildup': 70,
            'takeoff': 95
        }
    elif genre == 'hard house':
        thresholds = {
            'intro': 45,
            'breakdown': 40,
            'buildup': 65,
            'takeoff': 85
        }
    elif genre == 'dubstep':
        thresholds = {
            'intro': 20,
            'breakdown': 15,
            'buildup': 45,
            'takeoff': 70
        }
    elif genre == 'downtempo':
        thresholds = {
            'intro': 30,
            'breakdown': 25,
            'buildup': 55,
            'takeoff': 75
        }

    # Onset-detection logikk basert på terskler
    onset_env = librosa.onset.onset_strength(y=y, sr=sr)
    intro_threshold = np.percentile(onset_env, thresholds['intro'])
    breakdown_threshold = np.percentile(onset_env, thresholds['breakdown'])
    buildup_threshold = np.percentile(onset_env, thresholds['buildup'])
    takeoff_threshold = np.percentile(onset_env, thresholds['takeoff'])

    # Identifisering av seksjoner basert på terskler
    sections = []
    if any(onset_env < intro_threshold):
        sections.append('Intro')
    if any(onset_env < breakdown_threshold):
        sections.append('Breakdown')
    if any(onset_env > buildup_threshold):
        sections.append('Build-up')
    if any(onset_env > takeoff_threshold):
        sections.append('Take-off')

    return sections

# Hent informasjon fra filer for å analysere
collected_files_dir = '/content/drive/My Drive/SuperDJ_Project/collected_files/'
additional_info = extract_information_from_files(collected_files_dir)
print(f"Ekstra informasjon hentet fra filene: {additional_info[:500]}...")  # Vis første 500 tegn

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
y, sr = librosa.load(audio_file_path)

# BPM-analyse
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
bpm_value = int(tempo) if isinstance(tempo, float) else int(tempo[0])
print(f"BPM (Tempo): {bpm_value}")

# Klassifiser sjanger basert på BPM
genre = classify_genre_based_on_bpm(bpm_value)
print(f"Identifisert sjanger basert på BPM: {genre}")

# Onset-detection basert på sjanger
sections = detect_onsets_based_on_genre(y, sr, genre=genre)
print(f"Seksjoner for sjangeren '{genre}': {sections}")

# Funksjon for å bestemme toneart (key) og Camelot Key
def get_camelot_key(y, sr):
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)
    major_profile = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1])  # C dur
    minor_profile = np.array([0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0])  # A moll
    chroma_normalized = chroma / chroma.sum()
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')
    key = 'C' if major_correlation.max() > minor_correlation.max() else 'Cm'
    camelot_wheel = {
        'C': '8B', 'Cm': '8A'
        # Legg til resten av Camelot Key-mappingen her
    }
    camelot_key = camelot_wheel.get(key, 'Unknown Key')
    return key, camelot_key

key, camelot_key = get_camelot_key(y, sr)
print(f"Toneart (Key): {key}")
print(f"Camelot Key: {camelot_key}")

import os
import librosa
import numpy as np

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å hente informasjon fra relevante filer
def extract_information_from_files(directory):
    important_info = []
    files = list_files_in_directory(directory)
    for file_path in files:
        if file_path.endswith('.txt'):
            with open(file_path, 'r') as file:
                content = file.read()
                important_info.append(content)  # Samler innholdet fra filene
    return " ".join(important_info)  # Returnerer all informasjonen som én stor tekststreng

# Funksjon for avansert sjangeranalyse basert på flere faktorer
def detect_genre_advanced(y, sr):
    # Beregn spektrale egenskaper
    chroma = librosa.feature.chroma_stft(y=y, sr=sr).mean(axis=1)
    mfcc = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=13).mean(axis=1)
    rms_energy = librosa.feature.rms(y=y).mean()
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)

    # Definer sjangergrenser basert på BPM og andre faktorer
    if 110 <= tempo <= 130 and rms_energy < 0.05:
        return 'house'
    elif 120 <= tempo <= 140 and rms_energy > 0.06 and chroma.mean() > 0.5:
        return 'techno'
    elif 130 <= tempo <= 145 and chroma.mean() > 0.6:
        return 'trance'
    elif 140 <= tempo <= 200 and rms_energy > 0.08:
        return 'hardcore'
    elif 70 <= tempo <= 75 and mfcc[0] < -200:
        return 'dubstep'
    elif 90 <= tempo <= 110 and rms_energy < 0.04:
        return 'downtempo'
    else:
        return 'edm'

# Funksjon for å analysere toneart (key) og Camelot Key
def get_camelot_key(y, sr):
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)
    major_profile = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1])  # C dur
    minor_profile = np.array([0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0])  # A moll
    chroma_normalized = chroma / chroma.sum()
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')

    key = 'C' if major_correlation.max() > minor_correlation.max() else 'Cm'
    camelot_wheel = {
        'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
        'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
        'Cm': '8A', 'C#m': '3A', 'Dm': '10A', 'D#m': '5A', 'Em': '12A', 'Fm': '7A',
        'F#m': '2A', 'Gm': '9A', 'G#m': '4A', 'Am': '11A', 'A#m': '6A', 'Bm': '1A'
    }
    return key, camelot_wheel.get(key, 'Unknown Key')

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

import os
import librosa
import numpy as np

# Funksjon for å liste filer i en mappe
def list_files_in_directory(directory):
    files = []
    for root, dirs, file_list in os.walk(directory):
        for file_name in file_list:
            files.append(os.path.join(root, file_name))
    return files

# Funksjon for å hente informasjon fra relevante filer
def extract_information_from_files(directory):
    important_info = []
    files = list_files_in_directory(directory)
    for file_path in files:
        if file_path.endswith('.txt'):
            with open(file_path, 'r') as file:
                content = file.read()
                important_info.append(content)  # Samler innholdet fra filene
    return " ".join(important_info)  # Returnerer all informasjonen som én stor tekststreng

# Funksjon for avansert sjangeranalyse basert på flere faktorer
def detect_genre_advanced(y, sr):
    # Beregn spektrale egenskaper
    chroma = librosa.feature.chroma_stft(y=y, sr=sr).mean(axis=1)
    mfcc = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=13).mean(axis=1)
    rms_energy = librosa.feature.rms(y=y).mean()
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)

    # Definer sjangergrenser basert på BPM og andre faktorer
    if 110 <= tempo <= 130 and rms_energy < 0.05:
        return 'house'
    elif 120 <= tempo <= 140 and rms_energy > 0.06 and chroma.mean() > 0.5:
        return 'techno'
    elif 130 <= tempo <= 145 and chroma.mean() > 0.6:
        return 'trance'
    elif 140 <= tempo <= 200 and rms_energy > 0.08:
        return 'hardcore'
    elif 70 <= tempo <= 75 and mfcc[0] < -200:
        return 'dubstep'
    elif 90 <= tempo <= 110 and rms_energy < 0.04:
        return 'downtempo'
    else:
        return 'edm'

# Funksjon for å analysere toneart (key) og Camelot Key
def get_camelot_key(y, sr):
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)
    major_profile = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1])  # C dur
    minor_profile = np.array([0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0])  # A moll
    chroma_normalized = chroma / chroma.sum()
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')

    key = 'C' if major_correlation.max() > minor_correlation.max() else 'Cm'
    camelot_wheel = {
        'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
        'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
        'Cm': '8A', 'C#m': '3A', 'Dm': '10A', 'D#m': '5A', 'Em': '12A', 'Fm': '7A',
        'F#m': '2A', 'Gm': '9A', 'G#m': '4A', 'Am': '11A', 'A#m': '6A', 'Bm': '1A'
    }
    return key, camelot_wheel.get(key, 'Unknown Key')

# Last inn lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
y, sr = librosa.load(audio_file_path)

# Kjør sjangeranalyse
genre = detect_genre_advanced(y, sr)
print(f"Identifisert sjanger basert på BPM og egenskaper: {genre}")

# Kjør toneartanalyse (key og Camelot Key)
key, camelot_key = get_camelot_key(y, sr)
print(f"Toneart (Key): {key}")
print(f"Camelot Key: {camelot_key}")

# BPM-analyse
tempo, _ = librosa.beat.beat_track(y=y, sr

from google.colab import drive
drive.mount('/content/drive')

pip install numpy tensorflow librosa

!pip install --upgrade pip

!pip install acoustics

from google.colab import drive
drive.mount('/content/drive')

import librosa
import numpy as np

# Filsti til lydfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Camelot Wheel mapping
camelot_wheel = {
    'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
    'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
    'Cm': '8A', 'C#m': '3A', 'Dm': '10A', 'D#m': '5A', 'Em': '12A', 'Fm': '7A',
    'F#m': '2A', 'Gm': '9A', 'G#m': '4A', 'Am': '11A', 'A#m': '6A', 'Bm': '1A'
}

# Last inn lydfilen
y, sr = librosa.load(audio_file_path)

# 1. Varighet i sekunder
duration = librosa.get_duration(y=y, sr=sr)
print(f"Varighet: {int(duration // 60):02d}:{int(duration % 60):02d}.{int((duration % 1) * 1000):03d}")

# 2. Onsets: Teller antall onsets og returnerer hvor mange ganger de oppstår
onset_env = librosa.onset.onset_strength(y=y, sr=sr)
onset_frames = librosa.onset.onset_detect(onset_envelope=onset_env, sr=sr)
onset_times = librosa.frames_to_time(onset_frames, sr=sr)
print(f"Antall onsets: {len(onset_times)}")

# 3. Seksjoner: Klassifisering av musikkseksjoner basert på onset-styrke
def detect_sections(onset_env, sr):
    sections = []
    intro_threshold = np.percentile(onset_env, 25)
    breakdown_threshold = np.percentile(onset_env, 20)
    buildup_threshold = np.percentile(onset_env, 50)
    takeoff_threshold = np.percentile(onset_env, 80)
    outro_threshold = np.percentile(onset_env, 25)

    # Identifiser seksjoner (rekkefølgen viktig)
    if any(onset_env < intro_threshold):
        sections.append("Intro")
    if any(onset_env < breakdown_threshold):
        sections.append("Breakdown")
    if any(onset_env > buildup_threshold):
        sections.append("Build-up")
    if any(onset_env > takeoff_threshold):
        sections.append("Take-off")
    if any(onset_env < outro_threshold):
        sections.append("Outro")

    return sections

sections = detect_sections(onset_env, sr)
print(f"Seksjoner: {sections}")

# 4. BPM-analyse (Tempo)
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)

# Sjekk at tempo er et tall mellom 0 og 200
bpm_value = tempo[0] if isinstance(tempo, np.ndarray) else tempo

# Begrens BPM til å være mellom 0 og 200
bpm_value = min(max(bpm_value, 0), 200)

print(f"BPM (Tempo): {int(bpm_value)}")

# 5. Toneart (Key) og Camelot Key
def get_camelot_key(y, sr):
    chroma = librosa.feature.chroma_cqt(y=y, sr=sr).mean(axis=1)

    # Indikatorer for tonearter (dur og moll)
    major_profile = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1])  # C dur
    minor_profile = np.array([0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0])  # A moll

    # Normaliser chroma-dataene
    chroma_normalized = chroma / chroma.sum()

    # Beregn korrelasjonen med dur og moll profiler
    major_correlation = np.correlate(chroma_normalized, major_profile, mode='same')
    minor_correlation = np.correlate(chroma_normalized, minor_profile, mode='same')

    # Finn tonearten som best matcher profilen
    key = 'C' if major_correlation.max() > minor_correlation.max() else 'Cm'
    camelot_key = camelot_wheel.get(key, 'Unknown Key')

    return key, camelot_key

key, camelot_key = get_camelot_key(y, sr)
print(f"Toneart (Key): {key}")
print(f"Camelot Key: {camelot_key}")

from google.colab import drive
drive.mount('/content/drive')

import random

# Funksjon for å velge neste sang basert på BPM og pitch-shift
def choose_next_song(current_song, music_data, played_songs, bpm_tolerance=15, max_pitch_shift=10):
    if current_song is None:
        return None, None

    current_bpm = current_song['BPM']

    # Filtrer musikkdata for sanger som ikke er spilt og som er innenfor BPM-toleransen
    candidate_songs = [
        song for song in music_data
        if song['Sang'] not in played_songs and abs(song['BPM'] - current_bpm) <= bpm_tolerance
    ]

    # Debug: Skriv ut sanger som vurderes uten pitch-shift
    print(f"Vurderer følgende sanger innen BPM-toleranse {bpm_tolerance}:")
    for song in candidate_songs:
        print(f"Sang: {song['Sang']} med BPM: {song['BPM']}")

    if candidate_songs:
        selected_song = random.choice(candidate_songs)
        pitch_shift = 0
        return selected_song, pitch_shift
    else:
        # Hvis ingen sanger uten pitch-shift, prøv med pitch-shift
        print("Ingen sanger funnet uten pitch-shift, prøver med pitch-shift...")
        for song in music_data:
            if song['Sang'] not in played_songs:
                pitch_shift = ((current_bpm - song['BPM']) / song['BPM']) * 100
                # Debug: Skriv ut pitch-shift som vurderes
                print(f"Sjekker sang: {song['Sang']} med BPM: {song['BPM']} og pitch-shift: {pitch_shift:.2f}%")
                if abs(pitch_shift) <= max_pitch_shift:
                    return song, pitch_shift

        return None, None  # Ingen passende sang funnet

# Start-sang (kan velge hvilken som helst for testing)
start_song = {
    'Sang': '18420294_Got That Booty_(Extended Mix).mp3',
    'BPM': 161.5,
    'Toneart': 'F',
    'Sjanger': 'Drum and Bass'
}

# Data for musikkbiblioteket
music_data = [
    {'Sang': '18420294_Got That Booty_(Extended Mix).mp3', 'BPM': 161.5, 'Toneart': 'F', 'Sjanger': 'Drum and Bass'},
    {'Sang': '18222120_It_s That Time (Dimension Remix)_(Original Mix).mp3', 'BPM': 172.27, 'Toneart': 'F', 'Sjanger': 'Drum and Bass'},
    {'Sang': '16149902_Own Methods (Extented Mix)_(Original Mix).mp3', 'BPM': 152.0, 'Toneart': 'A', 'Sjanger': 'Unknown'},
    {'Sang': '17985216_Spring Girl_(Extended).mp3', 'BPM': 123.05, 'Toneart': 'G', 'Sjanger': 'House'},
    {'Sang': '17588048_Believer_(Original Mix).mp3', 'BPM': 129.2, 'Toneart': 'G', 'Sjanger': 'House'},
    {'Sang': '18081983_T.O.K.Y.O._(Extended Mix).mp3', 'BPM': 136.0, 'Toneart': 'D#', 'Sjanger': 'Techno'},
    {'Sang': '17997183_My Gasoline_(Extended Mix).mp3', 'BPM': 143.55, 'Toneart': 'F#', 'Sjanger': 'Trance'}
]

# Liste over sanger som har blitt spilt
played_songs = [start_song['Sang']]  # Start med å legge til start-sangen i "spilt" listen

# Velg den første sangen etter start-sangen
next_song_1, pitch_shift_1 = choose_next_song(start_song, music_data, played_songs)

if next_song_1:
    played_songs.append(next_song_1['Sang'])  # Legg til sangen i "spilt" listen
    if pitch_shift_1 == 0:
        print(f"Neste sang: {next_song_1['Sang']} med BPM: {next_song_1['BPM']}, Toneart: {next_song_1['Toneart']}, Sjanger: {next_song_1['Sjanger']}")
    else:
        print(f"Neste sang: {next_song_1['Sang']} med BPM justert til {next_song_1['BPM']} via pitch-shift på {pitch_shift_1:.2f}%")
else:
    print("Ingen passende sang funnet for den første sangen.")

# Sjekk om den første sangen ble valgt før vi velger den andre
if next_song_1:
    # Velg en ny sang (den andre sangen) som ikke er den første eller start-sangen
    next_song_2, pitch_shift_2 = choose_next_song(next_song_1, music_data, played_songs)

    if next_song_2:
        played_songs.append(next_song_2['Sang'])  # Legg til den andre sangen i "spilt" listen
        if pitch_shift_2 == 0:
            print(f"Andre sang: {next_song_2['Sang']} med BPM: {next_song_2['BPM']}, Toneart: {next_song_2['Toneart']}, Sjanger: {next_song_2['Sjanger']}")
        else:
            print(f"Andre sang: {next_song_2['Sang']} med BPM justert til {next_song_2['BPM']} via pitch-shift på {pitch_shift_2:.2f}%")
    else:
        print("Ingen passende andre sang funnet.")

import os
import librosa
import numpy as np
import csv

# Funksjon for å beregne energinivåer
def calculate_energy(y, sr, frame_size=2048, hop_length=512):
    rmse = librosa.feature.rms(y=y, frame_length=frame_size, hop_length=hop_length)[0]
    return np.mean(rmse)

# Funksjon for harmonisk analyse (Chroma)
def harmonic_analysis(y, sr, hop_length=512):
    chroma = librosa.feature.chroma_stft(y=y, sr=sr, hop_length=hop_length)
    return chroma

# Funksjon for frekvensanalyse (STFT)
def frequency_analysis(y, sr, hop_length=512):
    stft = np.abs(librosa.stft(y, hop_length=hop_length))
    db = librosa.amplitude_to_db(stft, ref=np.max)
    return db

# Funksjon for å analysere BPM
def analyze_bpm(y, sr):
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
    return tempo if isinstance(tempo, float) else tempo[0]

# Funksjon for å analysere toneart (Key)
def analyze_key(y, sr):
    chroma_cqt = librosa.feature.chroma_cqt(y=y, sr=sr)
    key_index = np.argmax(chroma_cqt.mean(axis=1))
    keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
    key = keys[key_index]
    return key

# Funksjon for å tilordne Camelot Key
def get_camelot_key(key):
    camelot_keys = {
        'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
        'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B',
        'Cm': '8A', 'C#m': '3A', 'Dm': '10A', 'D#m': '5A', 'Em': '12A', 'Fm': '7A',
        'F#m': '2A', 'Gm': '9A', 'G#m': '4A', 'Am': '11A', 'A#m': '6A', 'Bm': '1A'
    }
    return camelot_keys.get(key, "Unknown")

# Funksjon for å gjenkjenne sjanger basert på BPM
def detect_genre(bpm):
    if bpm >= 160 and bpm <= 180:
        return 'Drum and Bass'
    elif bpm >= 130 and bpm <= 150:
        return 'Trance'
    elif bpm >= 120 and bpm <= 130:
        return 'House'
    elif bpm >= 100 and bpm <= 120:
        return 'Techno'
    else:
        return 'Unknown'

# Funksjon for å analysere om sangen har vokal
def detect_vocals(y, sr):
    S_full, _ = librosa.magphase(librosa.stft(y))
    S_filter = librosa.decompose.nn_filter(S_full, aggregate=np.median)
    margin_i, margin_v = 2, 10
    S_margin = librosa.util.softmask(S_full - S_filter, margin_i * S_filter, power=2)
    S_foreground = S_margin * S_full
    return np.mean(S_foreground) > 0.1  # Terskel for vokal

# Funksjon for å analysere en enkelt sang og lagre resultatene
def analyze_song(file_path, output_dir):
    y, sr = librosa.load(file_path)
    bpm = analyze_bpm(y, sr)
    key = analyze_key(y, sr)
    camelot_key = get_camelot_key(key)
    energy = calculate_energy(y, sr)
    genre = detect_genre(bpm)
    has_vocals = detect_vocals(y, sr)

    # Lagre analysen som en ordbok
    analysis = {
        'Sang': os.path.basename(file_path),
        'BPM': bpm,
        'Toneart': key,
        'Camelot Key': camelot_key,
        'Energi': energy,
        'Sjanger': genre,
        'Vokal': has_vocals,
        'Stemning': 'High' if energy > 0.3 else 'Medium'
    }

    # Lagre analysen som en CSV-fil
    output_file_csv = os.path.join(output_dir, 'music_analysis.csv')
    with open(output_file_csv, 'a', newline='') as f:
        writer = csv.DictWriter(f, fieldnames=analysis.keys())
        if f.tell() == 0:  # Hvis filen er tom, skriv topptekstene
            writer.writeheader()
        writer.writerow(analysis)

    print(f"Analysert {os.path.basename(file_path)}: {analysis}")

# Hovedfunksjon for å analysere hele musikkbiblioteket
def analyze_music_library(music_directory, output_directory):
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    for file_name in os.listdir(music_directory):
        if file_name.endswith('.mp3'):
            file_path = os.path.join(music_directory, file_name)
            analyze_song(file_path, output_directory)

# Filstier
music_directory = '/content/drive/My Drive/SuperDJ_Project/music_library'
output_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Kjør analysen
analyze_music_library(music_directory, output_directory)

from google.colab import drive
drive.mount('/content/drive')

import os
import json
import random

# Funksjon for å lese JSON-filene fra musikkbiblioteket
def load_music_data(analysis_directory):
    music_data = []
    for file_name in os.listdir(analysis_directory):
        if file_name.endswith('.json'):
            file_path = os.path.join(analysis_directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å velge neste sang basert på Camelot Key og BPM
def choose_next_song(current_song, music_data, played_songs, bpm_tolerance=10, max_pitch_shift=6, vocal_threshold=0.2):
    current_bpm = current_song['BPM']
    current_key = current_song['Camelot Key']
    current_vocal_energy = current_song.get('Har Vokal', 0)

    # Filtrer musikkdata for sanger som ikke er spilt og som er innenfor BPM-toleransen
    candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs
        and abs(song['BPM'] - current_bpm) <= bpm_tolerance
        and abs(song['Har Vokal'] - current_vocal_energy) <= vocal_threshold
        and song['Camelot Key'] in camelot_compatible_keys(current_key)  # Camelot Key sjekk
    ]

    # Hvis det finnes kandidater, velg en sang
    if candidates:
        selected_song = random.choice(candidates)
        pitch_shift = ((current_bpm - selected_song['BPM']) / selected_song['BPM']) * 100
        return selected_song, pitch_shift
    else:
        print(f"Ingen passende sang funnet innen BPM-toleranse {bpm_tolerance}.")
        return None, 0

# Funksjon for å sjekke kompatible Camelot Keys
def camelot_compatible_keys(current_key):
    # Her kan du utvide med alle Camelot-teoriene dine
    camelot_wheel = {
        '1A': ['12A', '2A', '1B'],
        '1B': ['12B', '2B', '1A'],
        '2A': ['1A', '3A', '2B'],
        # Fyll inn resten av hjulet her...
    }
    return camelot_wheel.get(current_key, [])

# Hovedkjøring for å bruke ferdig analyserte sanger
def main():
    # Stien der JSON-filene ligger (ferdig analyserte)
    analysis_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

    # Last inn all musikkdata fra JSON-filene
    music_data = load_music_data(analysis_directory)

    if not music_data:
        print("Ingen musikkdata funnet.")
        return

    # Velg en start-sang
    current_song = music_data[0]  # Start med første sangen

    # Liste over sanger som har blitt spilt
    played_songs = [current_song['Sang']]

    # Velg den første sangen etter start-sangen
    next_song_1, pitch_shift_1 = choose_next_song(current_song, music_data, played_songs)

    if next_song_1:
        played_songs.append(next_song_1['Sang'])  # Legg til sangen i "spilt" listen
        if pitch_shift_1 == 0:
            print(f"Neste sang: {next_song_1['Sang']} med BPM: {next_song_1['BPM']}, Camelot Key: {next_song_1['Camelot Key']}, Sjanger: {next_song_1['Sjanger']}")
        else:
            print(f"Neste sang: {next_song_1['Sang']} med BPM justert til {next_song_1['BPM']} via pitch-shift på {pitch_shift_1:.2f}%")
    else:
        print("Ingen passende sang funnet.")

# Kjør programmet
main()

import os
import json

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å velge neste sang basert på BPM, toneart og vokal
def choose_next_song(current_song, music_data, played_songs, bpm_tolerance=10, max_pitch_shift=6):
    current_bpm = current_song['BPM']
    current_key = current_song['Camelot Key']

    # Filtrer musikkdata for sanger som ikke er spilt, som er innenfor BPM-toleransen og passer med Camelot Key
    candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs
        and abs(song['BPM'] - current_bpm) <= bpm_tolerance
        and song['Camelot Key'] in get_compatible_camelot_keys(current_key)  # Camelot Key sjekk
    ]

    # Hvis det er kandidater, velg den første
    if candidates:
        selected_song = candidates[0]
        pitch_shift = (current_bpm - selected_song['BPM']) / selected_song['BPM'] * 100
        return selected_song, pitch_shift
    else:
        print(f"Ingen passende sang funnet innen BPM-toleranse {bpm_tolerance}.")
        return None, None

# Funksjon for å få kompatible Camelot Keys basert på Camelot-hjulet
def get_compatible_camelot_keys(current_key):
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel.get(current_key, [])

# Test-kjøring
def main():
    # Sti til mappen med analyserte musikkdata (JSON-filer)
    json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

    # Last inn analysene fra JSON-filene
    music_data = load_music_data_from_json(json_directory)

    # Start med en nåværende sang (kan velges fra bruker eller tilfeldig)
    current_song = music_data[0]  # Bruk den første sangen i biblioteket for test

    # Liste for å holde oversikt over sanger som er spilt
    played_songs = [current_song['Sang']]

    # Velg den neste sangen basert på BPM, Camelot Key, og vokal
    next_song, pitch_shift = choose_next_song(current_song, music_data, played_songs)

    if next_song:
        print(f"Neste sang: {next_song['Sang']} med BPM: {next_song['BPM']}, Camelot Key: {next_song['Camelot Key']}, Pitch-shift: {pitch_shift:.2f}%")
    else:
        print("Ingen passende sang funnet.")

if __name__ == "__main__":
    main()

import os
import json

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å velge neste sang basert på toneart og vokal, med fleksibilitet i BPM
def choose_next_song(current_song, music_data, played_songs, max_pitch_shift=6):
    current_bpm = current_song['BPM']
    current_key = current_song['Camelot Key']

    # Filtrer musikkdata for sanger som ikke er spilt og passer med Camelot Key
    candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs
        and song['Camelot Key'] in get_compatible_camelot_keys(current_key)  # Camelot Key sjekk
    ]

    if candidates:
        # Vi ser etter den sangen som krever minst pitch-shift
        best_song = None
        min_pitch_shift = None

        for song in candidates:
            pitch_shift = (current_bpm - song['BPM']) / song['BPM'] * 100
            if abs(pitch_shift) <= max_pitch_shift:
                if min_pitch_shift is None or abs(pitch_shift) < abs(min_pitch_shift):
                    best_song = song
                    min_pitch_shift = pitch_shift

        if best_song:
            return best_song, min_pitch_shift
        else:
            print(f"Ingen passende sang funnet innen maks pitch-shift {max_pitch_shift}%.")
            return None, None
    else:
        print("Ingen passende sang funnet basert på Camelot Key.")
        return None, None

# Funksjon for å få kompatible Camelot Keys basert på Camelot-hjulet
def get_compatible_camelot_keys(current_key):
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel.get(current_key, [])

# Test-kjøring
def main():
    # Sti til mappen med analyserte musikkdata (JSON-filer)
    json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

    # Last inn analysene fra JSON-filene
    music_data = load_music_data_from_json(json_directory)

    # Start med en nåværende sang (kan velges fra bruker eller tilfeldig)
    current_song = music_data[0]  # Bruk den første sangen i biblioteket for test

    # Liste for å holde oversikt over sanger som er spilt
    played_songs = [current_song['Sang']]

    # Velg den neste sangen basert på Camelot Key og tillatt pitch-shift
    next_song, pitch_shift = choose_next_song(current_song, music_data, played_songs)

    if next_song:
        print(f"Neste sang: {next_song['Sang']} med BPM: {next_song['BPM']}, Camelot Key: {next_song['Camelot Key']}, Pitch-shift: {pitch_shift:.2f}%")
    else:
        print("Ingen passende sang funnet.")

if __name__ == "__main__":
    main()

import os
import random
import json

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å velge neste sang basert på energi, Camelot Key, vokal og pitch-shift
def choose_next_song(current_song, music_data, played_songs, bpm_tolerance=20, max_pitch_shift=12, vocal_threshold=0.5):
    current_bpm = current_song['BPM']
    current_camelot = current_song['Camelot Key']
    current_energy = current_song['Energi']
    current_vocal_energy = current_song.get('Har Vokal', 0)

    # Filtrer musikkdata for sanger som ikke er spilt, og som er innenfor BPM-toleransen og Camelot-nøkkelmatch
    candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs
        and abs(song['BPM'] - current_bpm) <= bpm_tolerance
        and song['Camelot Key'] in get_compatible_camelot_keys(current_camelot)
        and abs(song['Energi'] - current_energy) <= 0.2  # Energinivå bør være noenlunde likt
        and abs(song['Har Vokal'] - current_vocal_energy) <= vocal_threshold  # For å unngå vokaloverlapping
    ]

    # Debug: Skriv ut hvilke sanger som vurderes
    print(f"Vurderer følgende sanger innen BPM-toleranse {bpm_tolerance}, Camelot Key {current_camelot}, energi og vokal:")
    for song in candidates:
        print(f"Sang: {song['Sang']} med BPM: {song['BPM']}, Camelot Key: {song['Camelot Key']}, Energi: {song['Energi']}, Har Vokal: {song['Har Vokal']}")

    # Hvis kandidater finnes, velg en tilfeldig sang fra listen
    if candidates:
        selected_song = random.choice(candidates)
        pitch_shift = 0
        return selected_song, pitch_shift
    else:
        # Hvis ingen sanger er innenfor toleransen, prøv med pitch-shift
        print("Ingen sanger funnet uten pitch-shift, prøver med pitch-shift...")
        for song in music_data:
            if song['Sang'] not in played_songs:
                pitch_shift = ((current_bpm - song['BPM']) / song['BPM']) * 100
                if abs(pitch_shift) <= max_pitch_shift:
                    print(f"Valgt sang med pitch-shift: {song['Sang']} med BPM: {song['BPM']} og pitch-shift: {pitch_shift:.2f}%")
                    return song, pitch_shift

        print(f"Ingen passende sang funnet innen maks pitch-shift {max_pitch_shift}%.")
        return None, None  # Ingen passende sang funnet

# Funksjon for å få kompatible Camelot Keys basert på Camelot-hjulet
def get_compatible_camelot_keys(current_key):
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel.get(current_key, [])

# Test-kjøring
def main():
    # Sti til mappen med analyserte musikkdata (JSON-filer)
    json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

    # Last inn analysene fra JSON-filene
    music_data = load_music_data_from_json(json_directory)

    # Start med en nåværende sang (kan velges fra bruker eller tilfeldig)
    current_song = music_data[0]  # Bruk den første sangen i biblioteket for test

    # Liste for å holde oversikt over sanger som er spilt
    played_songs = [current_song['Sang']]

    # Velg den neste sangen basert på Camelot Key, energi og pitch-shift
    next_song, pitch_shift = choose_next_song(current_song, music_data, played_songs)

    if next_song:
        print(f"Neste sang: {next_song['Sang']} med BPM: {next_song['BPM']}, Camelot Key: {next_song['Camelot Key']}, Energi: {next_song['Energi']}, Pitch-shift: {pitch_shift:.2f}%")
    else:
        print("Ingen passende sang funnet.")

if __name__ == "__main__":
    main()

from google.colab import drive
drive.mount('/content/drive')

import os

# Sti til mappen du vil liste opp
directory_path = '/content/drive/My Drive/SuperDJ_Project/collected_files'

# Liste opp filer og mapper i den spesifiserte katalogen
files_in_directory = os.listdir(directory_path)

# Skriv ut alle filene og mappene
for file_name in files_in_directory:
    print(file_name)

def load_camelot_wheel(file_path):
    camelot_wheel = {}
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            if ':' in line:  # Sjekk om linjen inneholder ':'
                key, compatible_keys = line.split(':')
                camelot_wheel[key.strip()] = [ck.strip() for ck in compatible_keys.split(',')]
            else:
                print(f"Ugyldig linje i filen: {line}")  # For logging av uventede linjer
    return camelot_wheel

# Laste inn Camelot-hjulet
camelot_wheel_path = '/content/drive/My Drive/SuperDJ_Project/collected_files/camelot-wheel.txt'
camelot_wheel = load_camelot_wheel(camelot_wheel_path)

def load_camelot_wheel(file_path):
    camelot_wheel = {}
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            # Sjekk om linjen inneholder ':' og Camelot Keys-formatet (for eksempel '1A: 12A, 2A, 1B')
            if ':' in line and any(c in line for c in ['A', 'B']):
                try:
                    key, compatible_keys = line.split(':')
                    camelot_wheel[key.strip()] = [ck.strip() for ck in compatible_keys.split(',')]
                except ValueError:
                    print(f"Ugyldig Camelot Key-linje: {line}")
            else:
                # Denne linjen er tekst, så vi ignorerer den
                pass
    return camelot_wheel

# Laste inn Camelot-hjulet
camelot_wheel_path = '/content/drive/My Drive/SuperDJ_Project/collected_files/camelot-wheel.txt'
camelot_wheel = load_camelot_wheel(camelot_wheel_path)

# Skriv ut Camelot-hjulet for å sjekke om det er lastet riktig
print(camelot_wheel)

def check_camelot_wheel(file_path):
    with open(file_path, 'r') as f:
        for line in f:
            print(f"Linje: {line.strip()}")

# Kjør denne for å skrive ut alle linjene i Camelot-hjulet
camelot_wheel_path = '/content/drive/My Drive/SuperDJ_Project/collected_files/camelot-wheel.txt'
check_camelot_wheel(camelot_wheel_path)

import re

def clean_camelot_wheel(file_path, cleaned_file_path):
    cleaned_lines = []

    with open(file_path, 'r') as f:
        for line in f:
            # Bruk regex for å finne Camelot Keys (f.eks. '1A', '12B' osv.)
            if re.match(r'^\d{1,2}[AB]:', line):
                cleaned_lines.append(line.strip())

    # Lagre de rensede linjene i en ny fil
    with open(cleaned_file_path, 'w') as cleaned_file:
        for line in cleaned_lines:
            cleaned_file.write(f"{line}\n")

    print(f"Renset fil lagret til: {cleaned_file_path}")

# Rens camelot-wheel.txt
camelot_wheel_path = '/content/drive/My Drive/SuperDJ_Project/collected_files/camelot-wheel.txt'
cleaned_camelot_wheel_path = '/content/drive/My Drive/SuperDJ_Project/collected_files/cleaned_camelot_wheel.txt'

clean_camelot_wheel(camelot_wheel_path, cleaned_camelot_wheel_path)

def load_cleaned_camelot_wheel(file_path):
    camelot_wheel = {}
    with open(file_path, 'r') as f:
        for line in f:
            key, compatible_keys = line.split(':')
            camelot_wheel[key.strip()] = [ck.strip() for ck in compatible_keys.split(',')]
    return camelot_wheel

# Laste inn den rensede Camelot-hjul-filen
cleaned_camelot_wheel_path = '/content/drive/My Drive/SuperDJ_Project/collected_files/cleaned_camelot_wheel.txt'
cleaned_camelot_wheel = load_cleaned_camelot_wheel(cleaned_camelot_wheel_path)

# Skriv ut resultatet for å sjekke om Camelot-hjulet ble lastet riktig
print(cleaned_camelot_wheel)

def print_cleaned_camelot_wheel(file_path):
    with open(file_path, 'r') as f:
        for line in f:
            print(f"Renset linje: {line.strip()}")

# Skriv ut innholdet i den rensede filen
cleaned_camelot_wheel_path = '/content/drive/My Drive/SuperDJ_Project/collected_files/cleaned_camelot_wheel.txt'
print_cleaned_camelot_wheel(cleaned_camelot_wheel_path)

import os

# Sjekk filstørrelse for å se om den inneholder noe
file_size = os.path.getsize(cleaned_camelot_wheel_path)
print(f"Filstørrelse: {file_size} bytes")

def print_original_camelot_wheel(file_path):
    with open(file_path, 'r') as f:
        for line in f:
            print(f"Original linje: {line.strip()}")

# Skriv ut innholdet i originalfilen
camelot_wheel_path = '/content/drive/My Drive/SuperDJ_Project/collected_files/camelot-wheel.txt'
print_original_camelot_wheel(camelot_wheel_path)

# Opprett og skriv innholdet til 'camelot_wheel_ai_learning.txt'
content = """
# Lær Camelot-hjulet og harmonisk miksing

## Hva er Camelot-hjulet?
Camelot-hjulet er et verktøy for harmonisk mixing. Det hjelper DJ-er med å finne sanger som passer sammen basert på tonearter.
Hjulet er delt i 24 tonearter, kategorisert i:
- Moll (A): Ofte mørkere og mer følelsesladde.
- Dur (B): Mer energiske, positive og lyse.

Tallene på Camelot-hjulet går fra 1 til 12. Kombinasjoner av tallene og bokstavene (A eller B) indikerer harmonisk kompatibilitet.

## Hvordan Camelot-hjulet fungerer
1. Sanger ved siden av hverandre numerisk på Camelot-hjulet er kompatible.
2. Eksempel: 8A (A-moll) kan mikses med 9A (E-moll) eller 8B (C-dur).
3. Blandet overgang: Fra 8A til 9B gir en gradvis overgang mellom energiske og emosjonelle følelser.

## Muligheter Camelot-hjulet gir
1. Sømløse overganger: Mikser du sanger som følger Camelot-hjulets regler, skaper du jevne overganger.
2. Stemmingsendringer: Flytt opp eller ned i tallene for gradvis å endre stemningen (f.eks. fra 8A til 9A for en mer emosjonell følelse).
3. Energibytte: Å bytte mellom A- og B-tonearter (fra moll til dur) kan løfte energien i settet (f.eks. fra 7A til 7B).

## Hva AI-en aldri må gjøre
1. **Mikse inkompatible tonearter**: Å mikse en toneart som er for langt unna (f.eks. 4A til 10B) vil skape disharmonisk miksing.
2. **Store toneart-hopp**: Hopp over flere Camelot-nøkler uten mellomliggende overgang skaper brå overganger. Hold det gradvis for jevn flyt.
3. **Ignorere energinivå**: Selv om sanger er harmonisk kompatible, vil store forskjeller i energinivå ødelegge flyten på dansegulvet.

## Hvordan forbedre AI-en
1. **Detaljert forståelse av Camelot-hjulet**: AI-en må lære flere Camelot Key-overganger og hvordan dur og moll påvirker stemningen.
2. **Forhindre inkompatible overganger**: AI-en må unngå store toneart-hopp og alltid prioritere nære, kompatible tonearter.
3. **Fokus på energi og vokal**: Harmonisk kompatibilitet bør kombineres med passende energinivåer, og AI-en må unngå vokaloverlapping.
"""

# Lagre innholdet til en fil
with open('/content/drive/My Drive/SuperDJ_Project/camelot_wheel_ai_learning.txt', 'w') as file:
    file.write(content)

print("Fil opprettet og lagret som 'camelot_wheel_ai_learning.txt'")

# Les inn filen som treningsdata eller referanse
def load_learning_material(file_path):
    with open(file_path, 'r') as file:
        learning_material = file.read()
    return learning_material

# Laste inn materialet
learning_material_path = '/content/drive/My Drive/SuperDJ_Project/camelot_wheel_ai_learning.txt'
camelot_learning_material = load_learning_material(learning_material_path)

# Bruk materialet (f.eks. til å justere AI-algoritmer, trene, eller verifisere sanger)
print(camelot_learning_material)

# Integrer inn i AI-modellen (pseudo-kode for å justere AI-en basert på læring)
def integrate_into_ai(ai_model, learning_material):
    # Eksempel: AI-modellen kan justere harmonisk miksing basert på læringsmaterialet
    ai_model.update_harmonic_mixing_rules(learning_material)
    # Andre oppdateringer avhengig av hvordan AI-en din er strukturert

# Generer Camelot-hjulet (fra tidligere eksempel)
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet og energinivå
def choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, bpm_tolerance=20):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']

    candidates = []

    for song in music_data:
        next_key = song['Camelot Key']
        if is_harmonically_compatible(current_key, next_key, camelot_wheel):
            if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                candidates.append(song)

    if candidates:
        # Velg en sang blant kompatible kandidater
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']}")
        return selected_song
    else:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet.")
        return None

# Test Camelot-basert sangvalg
camelot_wheel = generate_camelot_wheel()
music_data = [
    {'Sang': 'Track 1', 'Camelot Key': '8A', 'BPM': 128},
    {'Sang': 'Track 2', 'Camelot Key': '9A', 'BPM': 130},
    {'Sang': 'Track 3', 'Camelot Key': '10A', 'BPM': 132},
    {'Sang': 'Track 4', 'Camelot Key': '8B', 'BPM': 128},
    # Legg til flere sanger her
]

current_song = {'Sang': 'Track 1', 'Camelot Key': '8A', 'BPM': 128}

# Velg neste sang
next_song = choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Last inn analysene fra JSON-filene
music_data = load_music_data_from_json(json_directory)

# Generer Camelot-hjulet (fra tidligere eksempel)
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet og energinivå
def choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, bpm_tolerance=20):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']

    candidates = []

    for song in music_data:
        next_key = song['Camelot Key']
        if is_harmonically_compatible(current_key, next_key, camelot_wheel):
            if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                candidates.append(song)

    if candidates:
        # Velg en sang blant kompatible kandidater
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']}")
        return selected_song
    else:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet.")
        return None

# Test Camelot-basert sangvalg
camelot_wheel = generate_camelot_wheel()

# Start med en nåværende sang (kan velges fra bruker eller tilfeldig)
current_song = music_data[0]  # Bruk den første sangen i biblioteket for test

# Velg neste sang
next_song = choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Last inn analysene fra JSON-filene
music_data = load_music_data_from_json(json_directory)

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet
def choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, bpm_tolerance=20):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']

    candidates = []

    for song in music_data:
        next_key = song['Camelot Key']
        if is_harmonically_compatible(current_key, next_key, camelot_wheel):
            if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']})")
        return selected_song
    else:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet.")
        return None

# Test Camelot-basert sangvalg for tre sanger
def select_three_songs(music_data, camelot_wheel):
    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']})")

    # Velg andre sang
    second_song = choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel)
    if second_song:
        # Velg tredje sang basert på andre sang
        third_song = choose_next_song_based_on_camelot(second_song, music_data, camelot_wheel)
        if third_song:
            print(f"Tredje sang valgt: {third_song['Sang']} (Camelot Key: {third_song['Camelot Key']}, BPM: {third_song['BPM']})")

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Velg tre sanger i rekkefølge
select_three_songs(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Last inn analysene fra JSON-filene
music_data = load_music_data_from_json(json_directory)

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, unngå duplikater
def choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=20):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']

    candidates = []

    for song in music_data:
        if song['Sang'] not in played_songs:  # Unngå duplikater
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']})")
        played_songs.append(selected_song['Sang'])  # Legg til i listen over spilte sanger
        return selected_song
    else:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet.")
        return None

# Test Camelot-basert sangvalg for tre sanger
def select_three_songs(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']})")

    # Velg andre sang
    second_song = choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs)
    if second_song:
        # Velg tredje sang basert på andre sang
        third_song = choose_next_song_based_on_camelot(second_song, music_data, camelot_wheel, played_songs)
        if third_song:
            print(f"Tredje sang valgt: {third_song['Sang']} (Camelot Key: {third_song['Camelot Key']}, BPM: {third_song['BPM']})")

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Velg tre sanger i rekkefølge uten duplikater
select_three_songs(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Last inn analysene fra JSON-filene
music_data = load_music_data_from_json(json_directory)

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, unngå duplikater
def choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=20):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']

    candidates = []

    for song in music_data:
        if song['Sang'] not in played_songs:  # Unngå duplikater
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']})")
        played_songs.append(selected_song['Sang'])  # Legg til i listen over spilte sanger
        return selected_song
    else:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet.")
        return None

# Test Camelot-basert sangvalg for tre sanger
def select_three_songs(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']})")

    # Velg andre sang
    second_song = choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs)
    if second_song:
        # Velg tredje sang basert på andre sang
        third_song = choose_next_song_based_on_camelot(second_song, music_data, camelot_wheel, played_songs)
        if third_song:
            print(f"Tredje sang valgt: {third_song['Sang']} (Camelot Key: {third_song['Camelot Key']}, BPM: {third_song['BPM']})")

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Velg tre sanger i rekkefølge uten duplikater
select_three_songs(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Last inn analysene fra JSON-filene
music_data = load_music_data_from_json(json_directory)

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, unngå duplikater
def choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=20):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']

    candidates = []

    for song in music_data:
        if song['Sang'] not in played_songs:  # Unngå duplikater
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']})")
        played_songs.append(selected_song['Sang'])  # Legg til i listen over spilte sanger
        return selected_song
    else:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet.")
        return None

# Test Camelot-basert sangvalg for tre sanger
def select_three_songs(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']})")

    # Velg andre sang
    second_song = choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs)
    if second_song:
        # Velg tredje sang basert på andre sang
        third_song = choose_next_song_based_on_camelot(second_song, music_data, camelot_wheel, played_songs)
        if third_song:
            print(f"Tredje sang valgt: {third_song['Sang']} (Camelot Key: {third_song['Camelot Key']}, BPM: {third_song['BPM']})")

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Velg tre sanger i rekkefølge uten duplikater
select_three_songs(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Last inn analysene fra JSON-filene
music_data = load_music_data_from_json(json_directory)

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, unngå duplikater og samme sang etter hverandre
def choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=20):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']

    candidates = []

    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:  # Unngå duplikater og samme sang etter hverandre
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']})")
        played_songs.append(selected_song['Sang'])  # Legg til i listen over spilte sanger
        return selected_song
    else:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet.")
        return None

# Test Camelot-basert sangvalg for ti sanger
def select_ten_songs(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']})")

    # Velg ti sanger i rekkefølge
    for i in range(9):  # 9 flere sanger etter den første
        next_song = choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            current_song = next_song
        else:
            break  # Avslutt hvis ingen flere kompatible sanger finnes

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Velg ti sanger i rekkefølge uten duplikater
select_ten_songs(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å velge neste sang basert på flere kriterier
def choose_next_song(current_song, music_data, played_songs, bpm_tolerance=15, energy_tolerance=0.2, max_pitch_shift=6):
    current_bpm = current_song['BPM']
    current_energy = current_song['Energi']
    current_has_vocals = current_song['Har Vokal']

    # 1. Camelot Key-prioritet
    camelot_candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs
        and song['Camelot Key'] == current_song['Camelot Key']
        and abs(song['BPM'] - current_bpm) <= bpm_tolerance
    ]

    if camelot_candidates:
        selected_song = random.choice(camelot_candidates)
        print(f"Valgt sang basert på Camelot Key: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']})")
        return selected_song, 0

    # 2. BPM-prioritet
    bpm_candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs
        and abs(song['BPM'] - current_bpm) <= bpm_tolerance
    ]

    if bpm_candidates:
        selected_song = random.choice(bpm_candidates)
        print(f"Valgt sang basert på BPM: {selected_song['Sang']} (BPM: {selected_song['BPM']})")
        return selected_song, 0

    # 3. Energi-prioritet
    energy_candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs
        and abs(song['Energi'] - current_energy) <= energy_tolerance
    ]

    if energy_candidates:
        selected_song = random.choice(energy_candidates)
        print(f"Valgt sang basert på energi: {selected_song['Sang']} (Energi: {selected_song['Energi']}, BPM: {selected_song['BPM']})")
        return selected_song, 0

    # 4. Pitch-shift som siste utvei
    print("Ingen kompatible sanger funnet. Prøver med pitch-shift...")
    for song in music_data:
        if song['Sang'] not in played_songs:
            pitch_shift = ((current_bpm - song['BPM']) / song['BPM']) * 100
            if abs(pitch_shift) <= max_pitch_shift:
                print(f"Valgt sang med pitch-shift: {song['Sang']} med pitch-shift: {pitch_shift:.2f}%")
                return song, pitch_shift

    return None, None  # Ingen passende sang funnet

# Hovedkjøringen
def main():
    # Last inn musikkdata fra tidligere analyserte JSON-filer
    music_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'
    music_data = load_music_data_from_json(music_directory)

    # Start med en nåværende sang
    current_song = music_data[0]
    played_songs = [current_song['Sang']]

    # Velg neste sang basert på Camelot Key, BPM, energi osv.
    next_song, pitch_shift = choose_next_song(current_song, music_data, played_songs)

    if next_song:
        played_songs.append(next_song['Sang'])
        print(f"Neste sang: {next_song['Sang']} med BPM: {next_song['BPM']}, Camelot Key: {next_song['Camelot Key']}")
    else:
        print("Ingen passende sang funnet.")

# Kjør hovedprogrammet
main()

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Last inn analysene fra JSON-filene
music_data = load_music_data_from_json(json_directory)

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, BPM, energi og vokal, med fallback-mekanismer
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=15, energy_tolerance=0.2, max_pitch_shift=6):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_energy = current_song['Energi']
    current_has_vocals = current_song['Har Vokal']

    # 1. Camelot Key-prioritet (Harmonisk miksing)
    camelot_candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs
        and is_harmonically_compatible(current_key, song['Camelot Key'], camelot_wheel)
        and abs(song['BPM'] - current_bpm) <= bpm_tolerance
    ]

    if camelot_candidates:
        selected_song = random.choice(camelot_candidates)
        print(f"Valgt sang basert på Camelot Key: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']})")
        return selected_song, 0

    # 2. BPM-prioritet (Tempo matching)
    bpm_candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs
        and abs(song['BPM'] - current_bpm) <= bpm_tolerance
    ]

    if bpm_candidates:
        selected_song = random.choice(bpm_candidates)
        print(f"Valgt sang basert på BPM: {selected_song['Sang']} (BPM: {selected_song['BPM']})")
        return selected_song, 0

    # 3. Energi-prioritet (Matching basert på RMS-energi)
    energy_candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs
        and abs(song['Energi'] - current_energy) <= energy_tolerance
    ]

    if energy_candidates:
        selected_song = random.choice(energy_candidates)
        print(f"Valgt sang basert på energi: {selected_song['Sang']} (Energi: {selected_song['Energi']}, BPM: {selected_song['BPM']})")
        return selected_song, 0

    # 4. Vokaloverlapp: Unngå sanger med overlappende vokalintensitet
    vocal_candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs
        and song['Har Vokal'] == current_has_vocals
    ]

    if vocal_candidates:
        selected_song = random.choice(vocal_candidates)
        print(f"Valgt sang basert på vokaloverlapp: {selected_song['Sang']} (Har Vokal: {selected_song['Har Vokal']})")
        return selected_song, 0

    # 5. Pitch-shift som siste utvei (juster BPM om nødvendig)
    print("Ingen kompatible sanger funnet. Prøver med pitch-shift...")
    for song in music_data:
        if song['Sang'] not in played_songs:
            pitch_shift = ((current_bpm - song['BPM']) / song['BPM']) * 100
            if abs(pitch_shift) <= max_pitch_shift:
                print(f"Valgt sang med pitch-shift: {song['Sang']} med pitch-shift: {pitch_shift:.2f}%")
                return song, pitch_shift

    return None, None  # Ingen passende sang funnet

# Test Camelot-basert sangvalg for ti sanger med prioritert prosess
def select_ten_songs(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']})")

    # Velg ti sanger i rekkefølge
    for i in range(9):  # 9 flere sanger etter den første
        next_song, _ = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            current_song = next_song
        else:
            break  # Avslutt hvis ingen flere kompatible sanger finnes

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Velg ti sanger i rekkefølge uten duplikater, med prioritert prosess
select_ten_songs(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Last inn analysene fra JSON-filene
music_data = load_music_data_from_json(json_directory)

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, BPM, energi og vokal, med fallback-mekanismer
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=15, energy_tolerance=0.2, max_pitch_shift=6):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_energy = current_song['Energi']
    current_has_vocals = current_song['Har Vokal']

    # 1. Camelot Key-prioritet (Harmonisk miksing)
    camelot_candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs  # Ikke velg sanger som allerede er spilt
        and is_harmonically_compatible(current_key, song['Camelot Key'], camelot_wheel)
        and abs(song['BPM'] - current_bpm) <= bpm_tolerance
    ]

    if camelot_candidates:
        selected_song = random.choice(camelot_candidates)
        print(f"Valgt sang basert på Camelot Key: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']})")
        return selected_song, 0

    # 2. BPM-prioritet (Tempo matching)
    bpm_candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs  # Ikke velg sanger som allerede er spilt
        and abs(song['BPM'] - current_bpm) <= bpm_tolerance
    ]

    if bpm_candidates:
        selected_song = random.choice(bpm_candidates)
        print(f"Valgt sang basert på BPM: {selected_song['Sang']} (BPM: {selected_song['BPM']})")
        return selected_song, 0

    # 3. Energi-prioritet (Matching basert på RMS-energi)
    energy_candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs  # Ikke velg sanger som allerede er spilt
        and abs(song['Energi'] - current_energy) <= energy_tolerance
    ]

    if energy_candidates:
        selected_song = random.choice(energy_candidates)
        print(f"Valgt sang basert på energi: {selected_song['Sang']} (Energi: {selected_song['Energi']}, BPM: {selected_song['BPM']})")
        return selected_song, 0

    # 4. Vokaloverlapp: Unngå sanger med overlappende vokalintensitet
    vocal_candidates = [
        song for song in music_data
        if song['Sang'] not in played_songs  # Ikke velg sanger som allerede er spilt
        and song['Har Vokal'] == current_has_vocals
    ]

    if vocal_candidates:
        selected_song = random.choice(vocal_candidates)
        print(f"Valgt sang basert på vokaloverlapp: {selected_song['Sang']} (Har Vokal: {selected_song['Har Vokal']})")
        return selected_song, 0

    # 5. Pitch-shift som siste utvei (juster BPM om nødvendig)
    print("Ingen kompatible sanger funnet. Prøver med pitch-shift...")
    for song in music_data:
        if song['Sang'] not in played_songs:  # Ikke velg sanger som allerede er spilt
            pitch_shift = ((current_bpm - song['BPM']) / song['BPM']) * 100
            if abs(pitch_shift) <= max_pitch_shift:
                print(f"Valgt sang med pitch-shift: {song['Sang']} med pitch-shift: {pitch_shift:.2f}%")
                return song, pitch_shift

    return None, None  # Ingen passende sang funnet

# Test Camelot-basert sangvalg for ti sanger med prioritert prosess
def select_ten_songs(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']})")

    # Velg ti sanger i rekkefølge
    for i in range(9):  # 9 flere sanger etter den første
        next_song, _ = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            played_songs.append(next_song['Sang'])  # Legg til den valgte sangen i listen over spilte sanger
            current_song = next_song
        else:
            break  # Avslutt hvis ingen flere kompatible sanger finnes

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Velg ti sanger i rekkefølge uten duplikater, med prioritert prosess
select_ten_songs(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Last inn analysene fra JSON-filene
music_data = load_music_data_from_json(json_directory)

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, unngå duplikater og samme sang etter hverandre
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=20, energy_tolerance=0.1):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_energy = current_song['Energi']

    # Kriterier for valg av sanger
    candidates = []

    # Camelot Key Matching
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:  # Unngå duplikater og samme sang
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel) and abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                candidates.append(song)

    # Hvis Camelot Key Matching ikke gir resultater, sjekk BPM og energi
    if not candidates:
        print("Ingen kompatible sanger basert på Camelot-hjulet, prøver med BPM og energi.")
        for song in music_data:
            if song['Sang'] not in played_songs:
                # Sammenlign BPM og energi
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance and abs(song['Energi'] - current_energy) <= energy_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        played_songs.append(selected_song['Sang'])  # Legg til i listen over spilte sanger
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']})")
        return selected_song
    else:
        print("Ingen kompatible sanger funnet.")
        return None

# Funksjon for å velge ti sanger i rekkefølge
def select_ten_songs(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']})")

    # Velg ti sanger i rekkefølge
    for i in range(9):  # 9 flere sanger etter den første
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            current_song = next_song
        else:
            break  # Avslutt hvis ingen flere kompatible sanger finnes

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Velg ti sanger i rekkefølge uten duplikater
select_ten_songs(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Last inn analysene fra JSON-filene
music_data = load_music_data_from_json(json_directory)

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, BPM og energi
def choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=20, energy_tolerance=0.1):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_energy = current_song['Energi']

    candidates = []

    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:  # Unngå duplikater og samme sang etter hverandre
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance and abs(song['Energi'] - current_energy) <= energy_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']})")
        played_songs.append(selected_song['Sang'])  # Legg til i listen over spilte sanger
        return selected_song
    else:
        print("Ingen kompatible sanger basert på Camelot-hjulet, prøver med BPM og energi.")
        # Hvis ingen Camelot-kompatible sanger, velg basert på BPM og energi alene
        for song in music_data:
            if song['Sang'] not in played_songs and abs(song['BPM'] - current_bpm) <= bpm_tolerance and abs(song['Energi'] - current_energy) <= energy_tolerance:
                print(f"Valgt sang: {song['Sang']} (BPM: {song['BPM']}, Energi: {song['Energi']})")
                played_songs.append(song['Sang'])
                return song
        print("Ingen flere kompatible sanger funnet.")
        return None

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']})")

    # Velg flere sanger i rekkefølge
    for _ in range(10):  # Velg 10 sanger til å starte med
        next_song = choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            current_song = next_song
        else:
            break  # Avslutt hvis ingen flere kompatible sanger finnes

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Kjør sangvalg for hele musikkbiblioteket
select_songs_for_library(music_data, camelot_wheel)

import os

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Funksjon for å liste alle JSON-filene i biblioteket
def list_all_files(directory):
    files = [file_name for file_name in os.listdir(directory) if file_name.endswith('.json')]
    return files

# List alle filene
music_files = list_all_files(json_directory)

# Skriv ut filene
print("Følgende filer er i biblioteket:")
for file in music_files:
    print(file)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, BPM, og energi
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=15, energy_tolerance=0.1):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_energy = current_song['Energi']

    candidates = []

    # Først forsøk å finne sanger basert på Camelot Key, BPM og energi
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance and abs(song['Energi'] - current_energy) <= energy_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']})")
        played_songs.append(selected_song['Sang'])  # Legg til i listen over spilte sanger
        return selected_song
    else:
        print("Ingen kompatible sanger basert på Camelot-hjulet, prøver med bare BPM og energi.")
        # Hvis ingen Camelot-kompatible sanger, velg basert på BPM og energi
        for song in music_data:
            if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance and abs(song['Energi'] - current_energy) <= energy_tolerance:
                    print(f"Valgt sang basert på BPM og energi: {song['Sang']} (BPM: {song['BPM']}, Energi: {song['Energi']})")
                    played_songs.append(song['Sang'])
                    return song

        return None

# Funksjon for å velge alle sanger i biblioteket, unngå duplikater og rekkefølge
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []

    # Velg første sang tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']})")

    # Fortsett å velge neste sang til hele biblioteket er dekket
    for i in range(len(music_data) - 1):  # Minus 1 fordi vi allerede har valgt første sang
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            current_song = next_song
        else:
            break

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Last inn musikkdata fra JSON-filene
music_data = load_music_data_from_json(json_directory)

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Kjør sangvalg for hele musikkbiblioteket
select_songs_for_library(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        # (Resten av Camelot-hjulet)
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Juster toleransene for BPM og energi
def adjust_tolerances(played_songs_count):
    bpm_tolerance = 15 if played_songs_count < 5 else 20  # Justerer toleransen basert på hvor mange sanger som er spilt
    energy_tolerance = 0.1 if played_songs_count < 5 else 0.15  # Øk energitoleransen etterhvert
    return bpm_tolerance, energy_tolerance

# Velg neste sang basert på Camelot-hjulet, BPM, energi, vokal og sjanger
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, played_genres, bpm_tolerance, energy_tolerance):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_energy = current_song['Energi']
    current_vocal = current_song['Har Vokal']
    current_genre = current_song['Sjanger']

    candidates = []

    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            # Sjekk Camelot-kompatibilitet og BPM/energi-toleranser
            if is_harmonically_compatible(current_key, next_key, camelot_wheel) or \
               abs(song['BPM'] - current_bpm) <= bpm_tolerance or \
               abs(song['Energi'] - current_energy) <= energy_tolerance:
                if song['Sjanger'] not in played_genres:  # Legg til variasjon i sjanger
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song['Sjanger']})")
        played_songs.append(selected_song['Sang'])
        played_genres.append(selected_song['Sjanger'])  # Oppdater sjangerlisten
        return selected_song
    else:
        print("Ingen kompatible sanger funnet, utvider søket...")
        # Her kan vi utvide toleransene ytterligere eller velge sang med minst avvik fra BPM eller energi
        return None

# Hovedløp for å teste sangvalg for hele musikkbiblioteket med flere kriterier
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []
    played_genres = []

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    played_genres.append(current_song['Sjanger'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song['Sjanger']})")

    # Velg flere sanger
    for i in range(9):  # For å velge totalt 10 sanger
        bpm_tolerance, energy_tolerance = adjust_tolerances(len(played_songs))
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs, played_genres, bpm_tolerance, energy_tolerance)
        if next_song:
            current_song = next_song
        else:
            print("Ingen flere sanger kan velges.")
            break

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Last inn musikkdata fra JSON-filene
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'
music_data = load_music_data_from_json(json_directory)

# Kjør sangvalg for hele musikkbiblioteket
select_songs_for_library(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Last inn analysene fra JSON-filene
music_data = load_music_data_from_json(json_directory)

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, unngå duplikater og samme sang etter hverandre
def choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=15, max_pitch_shift=6):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']

    candidates = []

    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:  # Unngå duplikater og samme sang etter hverandre
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']})")
        played_songs.append(selected_song['Sang'])  # Legg til i listen over spilte sanger
        return selected_song
    else:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")

        # Utvide søket ved å bruke BPM og energi
        for song in music_data:
            if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
                bpm_difference = abs(current_bpm - song['BPM'])
                pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
                if pitch_shift <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                    candidates.append(song)

        if candidates:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']})")
            played_songs.append(selected_song['Sang'])
            return selected_song
        else:
            print("Ingen sanger tilgjengelig.")
            return None

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg ti sanger i rekkefølge
    for i in range(9):  # 9 flere sanger etter den første
        next_song = choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            current_song = next_song
        else:
            break  # Avslutt hvis ingen flere kompatible sanger finnes

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Kjør sangvalg for hele musikkbiblioteket
select_songs_for_library(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Sti til mappen med JSON-filene dine
json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

# Last inn analysene fra JSON-filene
music_data = load_music_data_from_json(json_directory)

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, unngå duplikater og samme sang etter hverandre
def choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=15, max_pitch_shift=6):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']

    candidates = []

    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:  # Unngå duplikater og samme sang etter hverandre
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']})")
        played_songs.append(selected_song['Sang'])  # Legg til i listen over spilte sanger
        return selected_song
    else:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")

        # Utvide søket ved å bruke BPM og energi
        for song in music_data:
            if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
                bpm_difference = abs(current_bpm - song['BPM'])
                pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
                if pitch_shift <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                    candidates.append(song)

        if candidates:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']})")
            played_songs.append(selected_song['Sang'])
            return selected_song
        else:
            print("Ingen sanger tilgjengelig.")
            return None

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg sanger til hele biblioteket er spilt
    while len(played_songs) < len(music_data):
        next_song = choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            current_song = next_song
        else:
            break  # Avslutt hvis ingen flere kompatible sanger finnes

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Kjør sangvalg for hele musikkbiblioteket
select_songs_for_library(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, unngå duplikater og samme sang etter hverandre
def choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=15, max_pitch_shift=6):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']

    candidates = []

    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:  # Unngå duplikater og samme sang etter hverandre
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']})")
        played_songs.append(selected_song['Sang'])  # Legg til i listen over spilte sanger
        return selected_song
    else:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")

        # Utvide søket ved å bruke BPM og energi
        for song in music_data:
            if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
                bpm_difference = abs(current_bpm - song['BPM'])
                pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
                if pitch_shift <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                    candidates.append(song)

        if candidates:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']})")
            played_songs.append(selected_song['Sang'])
            return selected_song
        else:
            print("Ingen sanger tilgjengelig, velger en tilfeldig sang fra de resterende.")
            remaining_songs = [song for song in music_data if song['Sang'] not in played_songs]
            if remaining_songs:
                selected_song = random.choice(remaining_songs)
                print(f"Tilfeldig valgt sang: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']})")
                played_songs.append(selected_song['Sang'])
                return selected_song
            return None

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg sanger til hele biblioteket er spilt
    while len(played_songs) < len(music_data):
        next_song = choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            current_song = next_song
        else:
            break  # Avslutt hvis ingen flere kompatible sanger finnes

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Kjør sangvalg for hele musikkbiblioteket
select_songs_for_library(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, unngå duplikater og samme sang etter hverandre
def choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']

    candidates = []

    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:  # Unngå duplikater og samme sang etter hverandre
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']})")
        played_songs.append(selected_song['Sang'])  # Legg til i listen over spilte sanger
        return selected_song
    else:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")

        # Utvide søket ved å bruke BPM og energi
        for song in music_data:
            if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                bpm_difference = abs(current_bpm - song['BPM'])
                pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
                if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                    candidates.append(song)

        if candidates:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']})")
            played_songs.append(selected_song['Sang'])
            return selected_song
        else:
            print("Ingen sanger tilgjengelig, velger en tilfeldig sang fra de resterende.")
            remaining_songs = [song for song in music_data if song['Sang'] not in played_songs]
            if remaining_songs:
                selected_song = random.choice(remaining_songs)
                print(f"Tilfeldig valgt sang: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']})")
                played_songs.append(selected_song['Sang'])
                return selected_song
            return None

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg sanger til hele biblioteket er spilt
    while len(played_songs) < len(music_data):
        next_song = choose_next_song_based_on_camelot(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            current_song = next_song
        else:
            break  # Avslutt hvis ingen flere kompatible sanger finnes

# Last inn Camelot-hjulet
camelot_wheel = generate_camelot_wheel()

# Kjør sangvalg for hele musikkbiblioteket
select_songs_for_library(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Funksjon for å sjekke harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Funksjon for å finne den beste sangen basert på toleranse
def find_best_match(current_song, music_data, played_songs, bpm_tolerance=30, energy_tolerance=0.3, max_pitch_shift=12):
    current_bpm = current_song['BPM']
    current_energy = current_song['Energi']
    current_genre = current_song['Sjanger']

    candidates = []

    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            bpm_diff = abs(song['BPM'] - current_bpm)
            energy_diff = abs(song['Energi'] - current_energy)
            if bpm_diff / current_bpm <= bpm_tolerance / 100 and energy_diff <= energy_tolerance:
                candidates.append(song)

    # Hvis vi har noen kandidater, velg den som har samme sjanger eller er nærmest
    if candidates:
        best_match = min(candidates, key=lambda x: (x['Sjanger'] != current_genre, abs(x['BPM'] - current_bpm)))
        print(f"Valgt sang basert på BPM og energi: {best_match['Sang']} (BPM: {best_match['BPM']}, Energi: {best_match['Energi']}, Sjanger: {best_match['Sjanger']})")
        return best_match

    # Hvis ingen passende sang, returner None
    print("Ingen kompatible sanger funnet basert på BPM og energi.")
    return None

# Funksjon for å velge neste sang
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']

    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:  # Unngå duplikater og samme sang etter hverandre
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                candidates.append(song)

    # Prioriter Camelot-kompatible sanger
    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # Hvis ingen Camelot-kompatible sanger finnes, bruk BPM og energi som kriterier
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    return find_best_match(current_song, music_data, played_songs, bpm_tolerance, max_pitch_shift)

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song['Sjanger']})")

    # Velg flere sanger i rekkefølge
    for i in range(len(music_data) - 1):  # Prøv å velge så mange sanger som mulig
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            current_song = next_song
        else:
            break  # Hvis ingen flere sanger kan velges, stopp.

# Hovedprogrammet som kjører analysen og velger sanger
def main():
    # Sti til mappen med JSON-filene dine
    json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'

    # Last inn musikkdata fra JSON-filene
    music_data = load_music_data_from_json(json_directory)

    # Last inn Camelot-hjulet
    camelot_wheel = generate_camelot_wheel()

    # Velg sanger i rekkefølge basert på Camelot-hjulet, BPM, energi og sjanger
    select_songs_for_library(music_data, camelot_wheel)

# Kjør hovedprogrammet
main()

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, BPM, energi og sjanger
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_genre = current_song.get('Sjanger', 'Unknown')

    # 1. Camelot Key Matching
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 2. BPM og Energi Matching (med pitch-shift)
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            song = adjust_bpm(song)  # Juster BPM hvis det er under 100
            bpm_difference = abs(current_bpm - song['BPM'])
            pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
            if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                candidates.append(song)

    if candidates:
        # 3. Prioriter sjanger matching
        genre_matched_candidates = [song for song in candidates if song.get('Sjanger', 'Unknown') == current_genre]
        if genre_matched_candidates:
            selected_song = random.choice(genre_matched_candidates)
            print(f"Valgt sang basert på BPM, energi og sjanger: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        else:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")

        played_songs.append(selected_song['Sang'])
        return selected_song

    # 4. Hvis ingen kompatibel sang er funnet, velg tilfeldig sang innen ±30% BPM og energi
    print("Ingen kompatible sanger basert på BPM og energi, prøver med større toleranse (±30%).")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            bpm_difference = abs(current_bpm - song['BPM'])
            if bpm_difference <= current_bpm * 0.3:  # ±30% toleranse på BPM
                candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang innen ±30% BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 5. Til slutt, velg en tilfeldig sang
    print("Ingen sanger tilgjengelig, velger en tilfeldig sang fra de resterende.")
    remaining_songs = [song for song in music_data if song['Sang'] not in played_songs]
    if remaining_songs:
        selected_song = random.choice(remaining_songs)
        print(f"Tilfeldig valgt sang: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song
    return None

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Sjekk harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Velg neste sang basert på Camelot-hjulet, BPM, energi og sjanger
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_genre = current_song.get('Sjanger', 'Unknown')

    # 1. Camelot Key Matching
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 2. BPM og Energi Matching (med pitch-shift)
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            song = adjust_bpm(song)  # Juster BPM hvis det er under 100
            bpm_difference = abs(current_bpm - song['BPM'])
            pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
            if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                candidates.append(song)

    if candidates:
        # 3. Prioriter sjanger matching
        genre_matched_candidates = [song for song in candidates if song.get('Sjanger', 'Unknown') == current_genre]
        if genre_matched_candidates:
            selected_song = random.choice(genre_matched_candidates)
            print(f"Valgt sang basert på BPM, energi og sjanger: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        else:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")

        played_songs.append(selected_song['Sang'])
        return selected_song

    # 4. Hvis ingen kompatibel sang er funnet, velg tilfeldig sang innen ±30% BPM og energi
    print("Ingen kompatible sanger basert på BPM og energi, prøver med større toleranse (±30%).")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            bpm_difference = abs(current_bpm - song['BPM'])
            if bpm_difference <= current_bpm * 0.3:  # ±30% toleranse på BPM
                candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang innen ±30% BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 5. Til slutt, velg en tilfeldig sang
    print("Ingen sanger tilgjengelig, velger en tilfeldig sang fra de resterende.")
    remaining_songs = [song for song in music_data if song['Sang'] not in played_songs]
    if remaining_songs:
        selected_song = random.choice(remaining_songs)
        print(f"Tilfeldig valgt sang: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song
    return None

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg sanger til hele biblioteket er spilt
    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            current_song = next_song
        else:
            break  # Avslutt hvis ingen flere kompatible sanger finnes

# Last inn

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Funksjon for å sjekke harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Funksjon for å finne sang med Camelot Key matching først
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_genre = current_song.get('Sjanger', 'Unknown')

    # 1. Camelot Key Matching
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 2. BPM og Energi Matching (med pitch-shift)
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            song = adjust_bpm(song)  # Juster BPM hvis det er under 100
            bpm_difference = abs(current_bpm - song['BPM'])
            pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
            if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                candidates.append(song)

    if candidates:
        # 3. Prioriter sjanger matching
        genre_matched_candidates = [song for song in candidates if song.get('Sjanger', 'Unknown') == current_genre]
        if genre_matched_candidates:
            selected_song = random.choice(genre_matched_candidates)
            print(f"Valgt sang basert på BPM, energi og sjanger: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        else:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")

        played_songs.append(selected_song['Sang'])
        return selected_song

    # 4. Hvis ingen kompatibel sang er funnet, velg tilfeldig sang innen ±30% BPM og energi
    print("Ingen kompatible sanger basert på BPM og energi, prøver med større toleranse (±30%).")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            bpm_difference = abs(current_bpm - song['BPM'])
            if bpm_difference <= current_bpm * 0.3:  # ±30% toleranse på BPM
                candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang innen ±30% BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 5. Til slutt, velg en tilfeldig sang
    print("Ingen sanger tilgjengelig, velger en tilfeldig sang fra de resterende.")
    remaining_songs = [song for song in music_data if song['Sang'] not in played_songs]
    if remaining_songs:
        selected_song = random.choice(remaining_songs)
        print(f"Tilfeldig valgt sang: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song
    return None

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg flere sanger i rekkefølge til alle er spilt
    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            current_song = next_song
        else:
            break  # Avslutt hvis ingen flere sanger kan velges

# Hovedprogrammet som kjører analysen og velger sanger
def main():
    # Sti til mappen med JSON-filene dine
    json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'  # Bytt ut med riktig sti til JSON-filene dine

    # Last inn musikkdata fra JSON-filene
    music_data = load_music_data_from_json(json_directory)

    # Last inn Camelot-hjulet
    camelot_wheel = generate_camelot_wheel()

    # Velg sanger i rekkefølge basert på Camelot-hjulet, BPM, energi og sjanger
    select_songs_for_library(music_data, camelot_wheel)

# Kjør hovedprogrammet
if __name__ == '__main__':
    main()

# Lese inn filene som inneholder DJ-teknikker

def load_uploaded_dj_techniques(file_paths):
    techniques = {}
    for file_path in file_paths:
        with open(file_path, 'r') as file:
            content = file.read()
            techniques[file_path] = content
    return techniques

# Filstiene til de opplastede teknikkfilene fra Google Drive
uploaded_files = [
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj_mixing_beginners_processed.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj_mixing_techniques_processed.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-crossfade-techniques_processed.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-tempo-change-techniques_processed.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-cue-points_processed.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/phrasing-dj-mixing_processed.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/mixing-db-levels_processed.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/advanced-dj-mixing-techniques_processed.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/basic-transition-techniques_processed.txt'
]

# Laste inn DJ-teknikker fra opplastede filer
dj_techniques = load_uploaded_dj_techniques(uploaded_files)

# Print ut en liten del av teknikkene for å forsikre oss om at de er lastet inn korrekt
for filename, content in dj_techniques.items():
    print(f"Innhold fra {filename}:\n{content[:200]}...\n")

import re

# Funksjon for å rense uønsket tekst fra innholdet
def clean_text(content):
    # Definer uønskede fraser (f.eks. reklame)
    unwanted_phrases = [
        "End Summer Sale", "discount", "Noah Feasey-Kemp", "DJ.Studio", "Pro + Stems"
    ]

    # Fjern URL-er og reklame-linjer
    lines = content.split('\n')
    cleaned_lines = []

    for line in lines:
        # Hopp over linjer som inneholder uønskede fraser eller er URL-er
        if not any(phrase in line for phrase in unwanted_phrases) and not re.match(r'http\S+', line):
            cleaned_lines.append(line)

    # Bli med de rensede linjene til én tekst
    return '\n'.join(cleaned_lines)

# Oppdater funksjonen for å laste og rense filene
def load_uploaded_dj_techniques(file_paths):
    techniques = {}
    for file_path in file_paths:
        with open(file_path, 'r') as file:
            content = file.read()
            cleaned_content = clean_text(content)
            techniques[file_path] = cleaned_content
    return techniques

# Laste inn og rense DJ-teknikker fra opplastede filer
dj_techniques = load_uploaded_dj_techniques(uploaded_files)

# Print ut en liten del av de rensede teknikkene for å forsikre oss om at de er lastet inn korrekt
for filename, content in dj_techniques.items():
    print(f"Innhold fra {filename}:\n{content[:200]}...\n")

import os

# Path til 'collected_files' mappen
collected_files_dir = '/content/drive/MyDrive/SuperDJ_Project/collected_files'

# List opp alle filene i 'collected_files' mappen
def list_all_files(directory):
    for file_name in os.listdir(directory):
        print(file_name)

# Kall funksjonen for å vise alle filene
list_all_files(collected_files_dir)

import re

# Funksjon for å rense uønsket tekst fra innholdet
def clean_text(content):
    # Definer uønskede fraser (f.eks. reklame)
    unwanted_phrases = [
        "End Summer Sale", "discount", "Noah Feasey-Kemp", "DJ.Studio", "Pro + Stems"
    ]

    # Fjern URL-er og reklame-linjer
    lines = content.split('\n')
    cleaned_lines = []

    for line in lines:
        # Hopp over linjer som inneholder uønskede fraser eller er URL-er
        if not any(phrase in line for phrase in unwanted_phrases) and not re.match(r'http\S+', line):
            cleaned_lines.append(line)

    # Bli med de rensede linjene til én tekst
    return '\n'.join(cleaned_lines)

# Oppdater funksjonen for å laste og rense filene
def load_uploaded_dj_techniques(file_paths):
    techniques = {}
    for file_path in file_paths:
        with open(file_path, 'r') as file:
            content = file.read()
            cleaned_content = clean_text(content)
            techniques[file_path] = cleaned_content
    return techniques

# Filstiene til de ubehandlede DJ-teknikkfilene du foreslo
uploaded_files = [
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-crossfade-techniques_vectors.kv',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-mix-songs.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-mixing-effects.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/mixing-db-levels.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/beat-matching-app.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-cue-points_vectors.kv',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-with-spotify.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/master-a-dj-mix.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/basic-transition-techniques.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/bad-dj-mixing-mistakes.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/advanced-dj-mixing-techniques.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/bpm-house-music.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/camelot-wheel.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/guide-music-keygraph.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-beatgridding_vectors.kv',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-inspiration_vectors.kv'
]

# Laste inn og rense DJ-teknikker fra opplastede filer
dj_techniques = load_uploaded_dj_techniques(uploaded_files)

# Print ut en liten del av de rensede teknikkene for å forsikre oss om at de er lastet inn korrekt
for filename, content in dj_techniques.items():
    print(f"Innhold fra {filename}:\n{content[:200]}...\n")

import re

# Funksjon for å rense uønsket tekst fra innholdet
def clean_text(content):
    # Definer uønskede fraser (f.eks. reklame)
    unwanted_phrases = [
        "End Summer Sale", "discount", "Noah Feasey-Kemp", "DJ.Studio", "Pro + Stems"
    ]

    # Fjern URL-er og reklame-linjer
    lines = content.split('\n')
    cleaned_lines = []

    for line in lines:
        # Hopp over linjer som inneholder uønskede fraser eller er URL-er
        if not any(phrase in line for phrase in unwanted_phrases) and not re.match(r'http\S+', line):
            cleaned_lines.append(line)

    # Bli med de rensede linjene til én tekst
    return '\n'.join(cleaned_lines)

# Funksjon for å laste og rense filer med feilkontroll for koding
def load_uploaded_dj_techniques(file_paths):
    techniques = {}
    for file_path in file_paths:
        try:
            # Forsøk å lese filen med utf-8 først
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read()
        except UnicodeDecodeError:
            # Hvis utf-8 feiler, prøv latin-1 eller annen koding
            with open(file_path, 'r', encoding='latin-1') as file:
                content = file.read()

        # Rens innholdet
        cleaned_content = clean_text(content)
        techniques[file_path] = cleaned_content
    return techniques

# Filstiene til de relevante filene i collected_files-mappen
uploaded_files = [
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-crossfade-techniques.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-mixing-effects.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-cue-points.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/mixing-db-levels.txt',
    '/content/drive/MyDrive/SuperDJ_Project/collected_files/beat-matching-app.txt'
]

# Laste inn og rense DJ-teknikker fra opplastede filer
dj_techniques = load_uploaded_dj_techniques(uploaded_files)

# Print ut en liten del av de rensede teknikkene for å forsikre oss om at de er lastet inn korrekt
for filename, content in dj_techniques.items():
    print(f"Innhold fra {filename}:\n{content[:200]}...\n")

import numpy as np
import librosa

# Funksjon for å bruke crossfade mellom to spor
def apply_crossfade(track1_path, track2_path, duration=5):
    track1, sr1 = librosa.load(track1_path)
    track2, sr2 = librosa.load(track2_path)

    # Juster sample rates om nødvendig
    if sr1 != sr2:
        track2 = librosa.resample(track2, sr2, sr1)

    # Lag en crossfade over 'duration' sekunder
    fade_length = int(duration * sr1)
    crossfade = np.linspace(1, 0, fade_length)

    # Fade out på track1 og fade in på track2
    track1[-fade_length:] *= crossfade
    track2[:fade_length] *= crossfade[::-1]

    # Kombiner sporene
    combined_track = np.concatenate([track1[:-fade_length], track1[-fade_length:] + track2[:fade_length], track2[fade_length:]])

    return combined_track

# Funksjon for å bruke beatmatching og tempojustering
def beatmatch_and_adjust_tempo(track1_path, track2_path):
    track1, sr1 = librosa.load(track1_path)
    track2, sr2 = librosa.load(track2_path)

    # Beat-deteksjon
    onset_env1 = librosa.onset.onset_strength(track1, sr=sr1)
    onset_env2 = librosa.onset.onset_strength(track2, sr=sr2)

    # Finn BPM for begge sporene
    tempo1, _ = librosa.beat.beat_track(onset_envelope=onset_env1, sr=sr1)
    tempo2, _ = librosa.beat.beat_track(onset_envelope=onset_env2, sr=sr2)

    # Juster tempo for track2 for å matche track1
    if tempo1 != tempo2:
        track2 = librosa.effects.time_stretch(track2, tempo1 / tempo2)

    return track1, track2

# Funksjon for å bruke cue-punkter i mikseprosessen
def apply_cue_point_transition(track1_path, track2_path, cue_point=30):
    track1, sr1 = librosa.load(track1_path)
    track2, sr2 = librosa.load(track2_path)

    # Finn tidspunktet for cue-punktet i track1
    cue_point_sample = int(cue_point * sr1)

    # Kutt track1 ved cue-punktet
    track1_cut = track1[:cue_point_sample]

    # Kombiner track1_cut og track2 for å skape en overgang
    combined_track = np.concatenate([track1_cut, track2])

    return combined_track

# Simulere DJ-sett med teknikker
def ai_dj_simulation(music_data, camelot_wheel, dj_techniques):
    played_songs = []
    current_song = random.choice(music_data)
    print(f"Start med sang: {current_song['Sang']}")

    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)

        if next_song:
            # Bruk av crossfade
            if 'crossfade' in dj_techniques:
                apply_crossfade(current_song['Sang'], next_song['Sang'])
            # Bruk av cue-punkter
            if 'cue_points' in dj_techniques:
                apply_cue_point_transition(current_song['Sang'], next_song['Sang'])

            # Beatmatching og tempojustering
            current_song, next_song = beatmatch_and_adjust_tempo(current_song['Sang'], next_song['Sang'])

            current_song = next_song
        else:
            break

import numpy as np
import librosa
import random

# Funksjon for å bruke crossfade mellom to spor
def apply_crossfade(track1_path, track2_path, duration=5):
    print(f"Bruker crossfade mellom {track1_path} og {track2_path} med varighet {duration} sekunder.")
    track1, sr1 = librosa.load(track1_path)
    track2, sr2 = librosa.load(track2_path)

    if sr1 != sr2:
        track2 = librosa.resample(track2, sr2, sr1)

    fade_length = int(duration * sr1)
    crossfade = np.linspace(1, 0, fade_length)

    track1[-fade_length:] *= crossfade
    track2[:fade_length] *= crossfade[::-1]

    combined_track = np.concatenate([track1[:-fade_length], track1[-fade_length:] + track2[:fade_length], track2[fade_length:]])
    print(f"Crossfade fullført.")

    return combined_track

# Funksjon for å bruke beatmatching og tempojustering
def beatmatch_and_adjust_tempo(track1_path, track2_path):
    print(f"Justerer tempo og beatmatcher {track1_path} med {track2_path}.")
    track1, sr1 = librosa.load(track1_path)
    track2, sr2 = librosa.load(track2_path)

    onset_env1 = librosa.onset.onset_strength(track1, sr=sr1)
    onset_env2 = librosa.onset.onset_strength(track2, sr=sr2)

    tempo1, _ = librosa.beat.beat_track(onset_envelope=onset_env1, sr=sr1)
    tempo2, _ = librosa.beat.beat_track(onset_envelope=onset_env2, sr=sr2)

    print(f"Tempo for {track1_path}: {tempo1} BPM, Tempo for {track2_path}: {tempo2} BPM")

    if tempo1 != tempo2:
        track2 = librosa.effects.time_stretch(track2, tempo1 / tempo2)
        print(f"Tempojustering gjort for {track2_path} for å matche {track1_path}.")

    return track1, track2

# Funksjon for å bruke cue-punkter i mikseprosessen
def apply_cue_point_transition(track1_path, track2_path, cue_point=30):
    print(f"Bruker cue-punkt på {cue_point} sekunder for å mikse {track1_path} med {track2_path}.")
    track1, sr1 = librosa.load(track1_path)
    track2, sr2 = librosa.load(track2_path)

    cue_point_sample = int(cue_point * sr1)
    track1_cut = track1[:cue_point_sample]

    combined_track = np.concatenate([track1_cut, track2])
    print(f"Cue-punkt mikseovergang fullført.")

    return combined_track

# Simulere DJ-sett med teknikker
def ai_dj_simulation(music_analysis, camelot_wheel, dj_techniques):
    played_songs = []
    current_song = random.choice(music_analysis)
    print(f"Start med sang: {current_song['Sang']}")

    while len(played_songs) < len(mmusic_analysis):
        next_song = choose_next_song(current_song, music_analysis, camelot_wheel, played_songs)

        if next_song:
            print(f"Neste sang valgt: {next_song['Sang']}")

            # Bruk av crossfade
            if 'crossfade' in dj_techniques:
                apply_crossfade(current_song['Sang'], next_song['Sang'])

            # Bruk av cue-punkter
            if 'cue_points' in dj_techniques:
                apply_cue_point_transition(current_song['Sang'], next_song['Sang'])

            # Beatmatching og tempojustering
            current_song, next_song = beatmatch_and_adjust_tempo(current_song['Sang'], next_song['Sang'])

            current_song = next_song
        else:
            print("Ingen flere sanger tilgjengelig, mikseprosessen avsluttes.")
            break

import numpy as np
import librosa
import random

# Funksjon for å bruke crossfade mellom to spor
def apply_crossfade(track1_path, track2_path, duration=5):
    print(f"Bruker crossfade mellom {track1_path} og {track2_path} med varighet {duration} sekunder.")
    track1, sr1 = librosa.load(track1_path)
    track2, sr2 = librosa.load(track2_path)

    if sr1 != sr2:
        track2 = librosa.resample(track2, sr2, sr1)

    fade_length = int(duration * sr1)
    crossfade = np.linspace(1, 0, fade_length)

    track1[-fade_length:] *= crossfade
    track2[:fade_length] *= crossfade[::-1]

    combined_track = np.concatenate([track1[:-fade_length], track1[-fade_length:] + track2[:fade_length], track2[fade_length:]])

    print("Crossfade fullført.")
    return combined_track

# Funksjon for å bruke beatmatching og tempojustering
def beatmatch_and_adjust_tempo(track1_path, track2_path):
    print(f"Justerer tempo og beatmatcher {track1_path} med {track2_path}.")
    track1, sr1 = librosa.load(track1_path)
    track2, sr2 = librosa.load(track2_path)

    onset_env1 = librosa.onset.onset_strength(track1, sr=sr1)
    onset_env2 = librosa.onset.onset_strength(track2, sr=sr2)

    tempo1, _ = librosa.beat.beat_track(onset_envelope=onset_env1, sr=sr1)
    tempo2, _ = librosa.beat.beat_track(onset_envelope=onset_env2, sr=sr2)

    print(f"Tempo for {track1_path}: {tempo1} BPM, Tempo for {track2_path}: {tempo2} BPM")

    if tempo1 != tempo2:
        track2 = librosa.effects.time_stretch(track2, tempo1 / tempo2)
        print(f"Tempojustering gjort for {track2_path} for å matche {track1_path}.")

    return track1, track2

# Funksjon for å bruke cue-punkter i mikseprosessen
def apply_cue_point_transition(track1_path, track2_path, cue_point=30):
    print(f"Bruker cue-punkt på {cue_point} sekunder for å mikse {track1_path} med {track2_path}.")
    track1, sr1 = librosa.load(track1_path)
    track2, sr2 = librosa.load(track2_path)

    cue_point_sample = int(cue_point * sr1)
    track1_cut = track1[:cue_point_sample]

    combined_track = np.concatenate([track1_cut, track2])
    print(f"Cue-punkt mikseovergang fullført.")

    return combined_track

# Simulere DJ-sett med teknikker
def ai_dj_simulation(music_data, camelot_wheel, dj_techniques):
    played_songs = []
    current_song = random.choice(music_data)
    print(f"Start med sang: {current_song['Sang']}")

    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)

        if next_song:
            print(f"Neste sang valgt: {next_song['Sang']}")

            # Bruk av crossfade
            if 'crossfade' in dj_techniques:
                apply_crossfade(current_song['Sang'], next_song['Sang'])
            # Bruk av cue-punkter
            if 'cue_points' in dj_techniques:
                apply_cue_point_transition(current_song['Sang'], next_song['Sang'])

            # Beatmatching og tempojustering
            current_song, next_song = beatmatch_and_adjust_tempo(current_song['Sang'], next_song['Sang'])

            current_song = next_song
        else:
            print("Ingen flere sanger tilgjengelig, mikseprosessen avsluttes.")
            break

# Last inn musikkdata fra 'music_analysis'-mappen og kjør simuleringen
def main():
    # Sti til mappen med musikkfilene dine (endret til 'music_analysis')
    music_directory = '/content/drive/MyDrive/SuperDJ_Project/music_analysis'

    # Last inn musikkdata fra JSON-filene (tilpass dette hvis nødvendig)
    music_data = load_music_data_from_json(music_directory)

    # Last inn Camelot-hjulet
    camelot_wheel = generate_camelot_wheel()

    # Laste inn DJ-teknikker fra opplastede filer
    uploaded_files = [
        '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-crossfade-techniques.txt',
        '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-mixing-effects.txt',
        '/content/drive/MyDrive/SuperDJ_Project/collected_files/dj-cue-points.txt',
        '/content/drive/MyDrive/SuperDJ_Project/collected_files/mixing-db-levels.txt',
        '/content/drive/MyDrive/SuperDJ_Project/collected_files/beat-matching-app.txt'
    ]
    dj_techniques = load_uploaded_dj_techniques(uploaded_files)

    # Kjør DJ-simulering
    ai_dj_simulation(music_data, camelot_wheel, dj_techniques)

# Kjør hovedprogrammet
if __name__ == '__main__':
    main()

# Simulere DJ-sett med teknikker
def ai_dj_simulation(music_data, camelot_wheel, dj_techniques):
    played_songs = []
    current_song = random.choice(music_data)
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']})")

    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)

        if next_song:
            print(f"Neste sang valgt: {next_song['Sang']} (Camelot Key: {next_song['Camelot Key']}, BPM: {next_song['BPM']}, Energi: {next_song['Energi']})")

            # Simuler crossfade basert på metadata
            if 'crossfade' in dj_techniques:
                print(f"Simulerer crossfade mellom {current_song['Sang']} og {next_song['Sang']} basert på BPM og energi.")

            # Simuler bruk av cue-punkter
            if 'cue_points' in dj_techniques:
                print(f"Simulerer cue-point overgang mellom {current_song['Sang']} og {next_song['Sang']}.")

            # Simuler beatmatching og tempojustering basert på metadata
            if abs(current_song['BPM'] - next_song['BPM']) > 0:
                print(f"Simulerer beatmatching og tempojustering for {next_song['Sang']} for å matche {current_song['Sang']}.")

            # Oppdater til neste sang
            current_song = next_song
            played_songs.append(current_song['Sang'])
        else:
            print("Ingen flere sanger tilgjengelig, mikseprosessen avsluttes.")
            break

# Simulere DJ-sett med teknikker
def ai_dj_simulation(music_data, camelot_wheel, dj_techniques):
    played_songs = []
    current_song = random.choice(music_data)
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']})")

    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)

        if next_song:
            print(f"Neste sang valgt: {next_song['Sang']} (Camelot Key: {next_song['Camelot Key']}, BPM: {next_song['BPM']}, Energi: {next_song['Energi']})")

            # Simuler crossfade basert på metadata
            if 'crossfade' in dj_techniques:
                print(f"Simulerer crossfade mellom {current_song['Sang']} og {next_song['Sang']} basert på BPM og energi.")

            # Simuler bruk av cue-punkter
            if 'cue_points' in dj_techniques:
                print(f"Simulerer cue-point overgang mellom {current_song['Sang']} og {next_song['Sang']}.")

            # Simuler beatmatching og tempojustering basert på metadata
            if abs(current_song['BPM'] - next_song['BPM']) > 0:
                print(f"Simulerer beatmatching og tempojustering for {next_song['Sang']} for å matche {current_song['Sang']}.")

            # Oppdater til neste sang
            current_song = next_song
            played_songs.append(current_song['Sang'])
        else:
            print("Ingen flere sanger tilgjengelig, mikseprosessen avsluttes.")
            break

# Kjør simulering med logging
ai_dj_simulation(music_data, camelot_wheel, dj_techniques)

import matplotlib.pyplot as plt
import numpy as np

# Simulere DJ-sett med teknikker og visualisere tempojusteringer
def ai_dj_simulation_with_visuals(music_data, camelot_wheel, dj_techniques):
    played_songs = []
    bpm_history = []  # For å spore BPM-endringer
    energy_history = []  # For å spore energinivåer
    current_song = random.choice(music_data)

    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']})")
    bpm_history.append(current_song['BPM'])
    energy_history.append(current_song['Energi'])

    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)

        if next_song:
            print(f"Neste sang valgt: {next_song['Sang']} (Camelot Key: {next_song['Camelot Key']}, BPM: {next_song['BPM']}, Energi: {next_song['Energi']})")

            # Simuler crossfade basert på metadata
            if 'crossfade' in dj_techniques:
                print(f"Simulerer crossfade mellom {current_song['Sang']} og {next_song['Sang']} basert på BPM og energi.")

            # Simuler bruk av cue-punkter
            if 'cue_points' in dj_techniques:
                print(f"Simulerer cue-point overgang mellom {current_song['Sang']} og {next_song['Sang']}.")

            # Simuler beatmatching og tempojustering basert på metadata
            if abs(current_song['BPM'] - next_song['BPM']) > 0:
                print(f"Simulerer beatmatching og tempojustering for {next_song['Sang']} for å matche {current_song['Sang']}.")
                # Logg tempoendringen for visualisering
                bpm_history.append(next_song['BPM'])
                energy_history.append(next_song['Energi'])

            # Oppdater til neste sang
            current_song = next_song
            played_songs.append(current_song['Sang'])
        else:
            print("Ingen flere sanger tilgjengelig, mikseprosessen avsluttes.")
            break

    # Visualiser tempojusteringer med en graf
    plot_tempo_adjustments(bpm_history, energy_history)

# Funksjon for å plotte tempojusteringer og energi
def plot_tempo_adjustments(bpm_history, energy_history):
    fig, ax1 = plt.subplots()

    color = 'tab:red'
    ax1.set_xlabel('Mix Sequence')
    ax1.set_ylabel('BPM', color=color)
    ax1.plot(bpm_history, color=color, label='BPM')
    ax1.tick_params(axis='y', labelcolor=color)

    # Lag en andre y-akse for energinivåer
    ax2 = ax1.twinx()
    color = 'tab:blue'
    ax2.set_ylabel('Energy', color=color)
    ax2.plot(energy_history, color=color, label='Energy')
    ax2.tick_params(axis='y', labelcolor=color)

    # Legg til tittel og labels
    plt.title('Tempojusteringer og Energihistorikk gjennom Mixen')
    fig.tight_layout()
    plt.show()

# Kjør simuleringen med visualiseringer
ai_dj_simulation_with_visuals(music_data, camelot_wheel, dj_techniques)

import matplotlib.pyplot as plt
import numpy as np

# Simulere DJ-sett med teknikker og visualisere tempojusteringer samt en miksesekvens
def ai_dj_simulation_with_visuals_and_timeline(music_data, camelot_wheel, dj_techniques):
    played_songs = []
    bpm_history = []  # For å spore BPM-endringer
    energy_history = []  # For å spore energinivåer
    song_names = []  # For å spore sangnavn for tidslinjen
    current_song = random.choice(music_data)

    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']})")
    bpm_history.append(current_song['BPM'])
    energy_history.append(current_song['Energi'])
    song_names.append(current_song['Sang'])  # Legg til sangen i tidslinjen

    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)

        if next_song:
            print(f"Neste sang valgt: {next_song['Sang']} (Camelot Key: {next_song['Camelot Key']}, BPM: {next_song['BPM']}, Energi: {next_song['Energi']})")

            # Simuler crossfade basert på metadata
            if 'crossfade' in dj_techniques:
                print(f"Simulerer crossfade mellom {current_song['Sang']} og {next_song['Sang']} basert på BPM og energi.")

            # Simuler bruk av cue-punkter
            if 'cue_points' in dj_techniques:
                print(f"Simulerer cue-point overgang mellom {current_song['Sang']} og {next_song['Sang']}.")

            # Simuler beatmatching og tempojustering basert på metadata
            if abs(current_song['BPM'] - next_song['BPM']) > 0:
                print(f"Simulerer beatmatching og tempojustering for {next_song['Sang']} for å matche {current_song['Sang']}.")
                # Logg tempoendringen for visualisering
                bpm_history.append(next_song['BPM'])
                energy_history.append(next_song['Energi'])
                song_names.append(next_song['Sang'])  # Legg til neste sang i tidslinjen

            # Oppdater til neste sang
            current_song = next_song
            played_songs.append(current_song['Sang'])
        else:
            print("Ingen flere sanger tilgjengelig, mikseprosessen avsluttes.")
            break

    # Visualiser tempojusteringer med en graf
    plot_tempo_adjustments_with_timeline(bpm_history, energy_history, song_names)

# Funksjon for å plotte tempojusteringer, energi og en miksesekvens (tidslinje)
def plot_tempo_adjustments_with_timeline(bpm_history, energy_history, song_names):
    fig, ax1 = plt.subplots()

    color = 'tab:red'
    ax1.set_xlabel('Mix Sequence')
    ax1.set_ylabel('BPM', color=color)
    ax1.plot(bpm_history, color=color, label='BPM')
    ax1.tick_params(axis='y', labelcolor=color)

    # Lag en andre y-akse for energinivåer
    ax2 = ax1.twinx()
    color = 'tab:blue'
    ax2.set_ylabel('Energy', color=color)
    ax2.plot(energy_history, color=color, label='Energy')
    ax2.tick_params(axis='y', labelcolor=color)

    # Legg til tittel og labels
    plt.title('Tempojusteringer, Energihistorikk og Mikseoverganger')

    # Tegn en tidslinje for sangene
    for i, song in enumerate(song_names):
        ax1.text(i, bpm_history[i] + 2, song.split('_')[0], rotation=90, fontsize=8, ha='center')

    fig.tight_layout()
    plt.show()

# Kjør simuleringen med visualiseringer
ai_dj_simulation_with_visuals_and_timeline(music_data, camelot_wheel, dj_techniques)

# Funksjon for å sjekke harmonisk kompatibilitet basert på Camelot-hjulet
def is_harmonically_compatible(current_key, next_key):
    # Camelot Wheel harmonisk kompatibilitet (nøkler må være innenfor 1 trinn opp/ned eller samme)
    camelot_key_mapping = {
        '1A': ['1A', '12A', '2A'], '1B': ['1B', '12B', '2B'],
        '2A': ['1A', '2A', '3A'], '2B': ['1B', '2B', '3B'],
        '3A': ['2A', '3A', '4A'], '3B': ['2B', '3B', '4B'],
        '4A': ['3A', '4A', '5A'], '4B': ['3B', '4B', '5B'],
        '5A': ['4A', '5A', '6A'], '5B': ['4B', '5B', '6B'],
        '6A': ['5A', '6A', '7A'], '6B': ['5B', '6B', '7B'],
        '7A': ['6A', '7A', '8A'], '7B': ['6B', '7B', '8B'],
        '8A': ['7A', '8A', '9A'], '8B': ['7B', '8B', '9B'],
        '9A': ['8A', '9A', '10A'], '9B': ['8B', '9B', '10B'],
        '10A': ['9A', '10A', '11A'], '10B': ['9B', '10B', '11B'],
        '11A': ['10A', '11A', '12A'], '11B': ['10B', '11B', '12B'],
        '12A': ['11A', '12A', '1A'], '12B': ['11B', '12B', '1B']
    }
    return next_key in camelot_key_mapping.get(current_key, [])

# Oppdatert sangvalg med strengere harmonisk miksing
def choose_next_song_harmonically(current_song, music_data, camelot_wheel, played_songs):
    compatible_songs = []

    for song in music_data:
        if song['Sang'] not in played_songs:
            if is_harmonically_compatible(current_song['Camelot Key'], song['Camelot Key']):
                compatible_songs.append(song)

    # Hvis ingen harmonisk kompatible sanger finnes, prøv å velge basert på BPM og energi
    if not compatible_songs:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
        compatible_songs = [song for song in music_data if song['Sang'] not in played_songs]

    # Sorter kompatible sanger basert på nærmest BPM og energi
    compatible_songs.sort(key=lambda x: (abs(x['BPM'] - current_song['BPM']), abs(x['Energi'] - current_song['Energi'])))

    return compatible_songs[0] if compatible_songs else None

# Funksjon for å sjekke harmonisk kompatibilitet basert på Camelot-hjulet
def is_harmonically_compatible(current_key, next_key):
    # Camelot Wheel harmonisk kompatibilitet (nøkler må være innenfor 1 trinn opp/ned eller samme)
    camelot_key_mapping = {
        '1A': ['1A', '12A', '2A'], '1B': ['1B', '12B', '2B'],
        '2A': ['1A', '2A', '3A'], '2B': ['1B', '2B', '3B'],
        '3A': ['2A', '3A', '4A'], '3B': ['2B', '3B', '4B'],
        '4A': ['3A', '4A', '5A'], '4B': ['3B', '4B', '5B'],
        '5A': ['4A', '5A', '6A'], '5B': ['4B', '5B', '6B'],
        '6A': ['5A', '6A', '7A'], '6B': ['5B', '6B', '7B'],
        '7A': ['6A', '7A', '8A'], '7B': ['6B', '7B', '8B'],
        '8A': ['7A', '8A', '9A'], '8B': ['7B', '8B', '9B'],
        '9A': ['8A', '9A', '10A'], '9B': ['8B', '9B', '10B'],
        '10A': ['9A', '10A', '11A'], '10B': ['9B', '10B', '11B'],
        '11A': ['10A', '11A', '12A'], '11B': ['10B', '11B', '12B'],
        '12A': ['11A', '12A', '1A'], '12B': ['11B', '12B', '1B']
    }
    return next_key in camelot_key_mapping.get(current_key, [])

# Oppdatert sangvalg med strengere harmonisk miksing
def choose_next_song_harmonically(current_song, music_data, played_songs):
    compatible_songs = []

    for song in music_data:
        if song['Sang'] not in played_songs:
            if is_harmonically_compatible(current_song['Camelot Key'], song['Camelot Key']):
                compatible_songs.append(song)

    # Hvis ingen harmonisk kompatible sanger finnes, prøv å velge basert på BPM og energi
    if not compatible_songs:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
        compatible_songs = [song for song in music_data if song['Sang'] not in played_songs]

    # Sorter kompatible sanger basert på nærmest BPM og energi
    compatible_songs.sort(key=lambda x: (abs(x['BPM'] - current_song['BPM']), abs(x['Energi'] - current_song['Energi'])))

    return compatible_songs[0] if compatible_songs else None

# Simulere DJ-sett med tydelig output
def ai_dj_simulation(music_data, dj_techniques):
    played_songs = []
    current_song = random.choice(music_data)
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']})")
    print("="*60)

    while len(played_songs) < len(music_data):
        next_song = choose_next_song_harmonically(current_song, music_data, played_songs)

        if next_song:
            print(f"Neste sang valgt: {next_song['Sang']} (Camelot Key: {next_song['Camelot Key']}, BPM: {next_song['BPM']}, Energi: {next_song['Energi']})")

            # Simulerer crossfade basert på metadata
            if 'crossfade' in dj_techniques:
                print(f"Simulerer crossfade mellom {current_song['Sang']} og {next_song['Sang']} basert på BPM og energi.")

            # Simuler bruk av cue-punkter
            if 'cue_points' in dj_techniques:
                print(f"Simulerer cue-point overgang mellom {current_song['Sang']} og {next_song['Sang']}.")

            # Simuler beatmatching og tempojustering basert på metadata
            if abs(current_song['BPM'] - next_song['BPM']) > 0:
                print(f"Simulerer beatmatching og tempojustering for {next_song['Sang']} for å matche {current_song['Sang']}.")

            # Oppdater til neste sang
            played_songs.append(current_song['Sang'])
            current_song = next_song
        else:
            print("Ingen flere sanger tilgjengelig, mikseprosessen avsluttes.")
            break

    print(f"Antall sanger spilt: {len(played_songs)}")
    print("Spilte sanger:")
    for song in played_songs:
        print(f"- {song}")
    print("="*60)

# Kjør simuleringen
ai_dj_simulation(music_data, dj_techniques)

# Funksjon for å sjekke harmonisk kompatibilitet basert på Camelot-hjulet
def is_harmonically_compatible(current_key, next_key):
    camelot_key_mapping = {
        '1A': ['1A', '12A', '2A'], '1B': ['1B', '12B', '2B'],
        '2A': ['1A', '2A', '3A'], '2B': ['1B', '2B', '3B'],
        '3A': ['2A', '3A', '4A'], '3B': ['2B', '3B', '4B'],
        '4A': ['3A', '4A', '5A'], '4B': ['3B', '4B', '5B'],
        '5A': ['4A', '5A', '6A'], '5B': ['4B', '5B', '6B'],
        '6A': ['5A', '6A', '7A'], '6B': ['5B', '6B', '7B'],
        '7A': ['6A', '7A', '8A'], '7B': ['6B', '7B', '8B'],
        '8A': ['7A', '8A', '9A'], '8B': ['7B', '8B', '9B'],
        '9A': ['8A', '9A', '10A'], '9B': ['8B', '9B', '10B'],
        '10A': ['9A', '10A', '11A'], '10B': ['9B', '10B', '11B'],
        '11A': ['10A', '11A', '12A'], '11B': ['10B', '11B', '12B'],
        '12A': ['11A', '12A', '1A'], '12B': ['11B', '12B', '1B']
    }
    return next_key in camelot_key_mapping.get(current_key, [])

# Velg neste sang harmonisk kompatibel
def choose_next_song_harmonically(current_song, music_data, played_songs):
    compatible_songs = []

    for song in music_data:
        if song['Sang'] not in played_songs:
            if is_harmonically_compatible(current_song['Camelot Key'], song['Camelot Key']):
                compatible_songs.append(song)

    # Hvis ingen harmonisk kompatible sanger finnes, prøv å velge basert på BPM og energi
    if not compatible_songs:
        print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
        compatible_songs = [song for song in music_data if song['Sang'] not in played_songs]

    # Sorter kompatible sanger basert på nærmest BPM og energi
    compatible_songs.sort(key=lambda x: (abs(x['BPM'] - current_song['BPM']), abs(x['Energi'] - current_song['Energi'])))

    return compatible_songs[0] if compatible_songs else None

# Simulere DJ-sett med tydeligere output og unike sanger
def ai_dj_simulation(music_data, dj_techniques):
    played_songs = []
    current_song = random.choice(music_data)
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']})")
    print("="*60)

    while len(played_songs) < len(music_data):
        next_song = choose_next_song_harmonically(current_song, music_data, played_songs)

        if next_song and next_song['Sang'] not in played_songs:
            print(f"Neste sang valgt: {next_song['Sang']} (Camelot Key: {next_song['Camelot Key']}, BPM: {next_song['BPM']}, Energi: {next_song['Energi']})")

            # Simulerer crossfade basert på metadata
            if 'crossfade' in dj_techniques:
                print(f"Simulerer crossfade mellom {current_song['Sang']} og {next_song['Sang']} basert på BPM og energi.")

            # Simuler bruk av cue-punkter
            if 'cue_points' in dj_techniques:
                print(f"Simulerer cue-point overgang mellom {current_song['Sang']} og {next_song['Sang']}.")

            # Simuler beatmatching og tempojustering basert på metadata
            if abs(current_song['BPM'] - next_song['BPM']) > 0:
                print(f"Simulerer beatmatching og tempojustering for {next_song['Sang']} for å matche {current_song['Sang']}.")

            # Oppdater til neste sang
            played_songs.append(current_song['Sang'])
            current_song = next_song
        else:
            print("Ingen flere unike sanger tilgjengelig, mikseprosessen avsluttes.")
            break

    print(f"Antall unike sanger spilt: {len(played_songs)}")
    print("Spilte sanger i rekkefølge:")
    for song in played_songs:
        print(f"- {song}")
    print("="*60)

# Kjør simuleringen
ai_dj_simulation(music_data, dj_techniques)

import matplotlib.pyplot as plt
import random

# Funksjon for å velge neste sang basert på Camelot Wheel, BPM og energi
def choose_next_song(current_song, music_data, camelot_wheel, played_songs):
    available_songs = [song for song in music_data if song['Sang'] not in played_songs]

    # Prioriter harmonisk miksing ved å filtrere sanger basert på Camelot-hjulet
    harmonically_compatible_songs = []

    for song in available_songs:
        if is_harmonically_compatible(current_song['Camelot Key'], song['Camelot Key'], camelot_wheel):
            harmonically_compatible_songs.append(song)

    if harmonically_compatible_songs:
        # Hvis vi har harmonisk kompatible sanger, velg basert på BPM og energi
        next_song = min(harmonically_compatible_songs,
                        key=lambda x: abs(current_song['BPM'] - x['BPM']) + abs(current_song['Energi'] - x['Energi']))
    else:
        # Hvis ingen sanger er harmonisk kompatible, velg den nærmeste basert på BPM og energi
        next_song = min(available_songs,
                        key=lambda x: abs(current_song['BPM'] - x['BPM']) + abs(current_song['Energi'] - x['Energi']))

    return next_song

# Sjekk om Camelot-nøkler er kompatible (nær hverandre på Camelot-hjulet)
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    current_index = camelot_wheel.index(current_key)
    next_index = camelot_wheel.index(next_key)

    # Returner True hvis nøkklene er én posisjon fra hverandre
    return abs(current_index - next_index) <= 1

# Hovedfunksjon for DJ-simulering med visualiseringer
def ai_dj_simulation_with_visuals_and_timeline(music_data, camelot_wheel, dj_techniques):
    played_songs = []
    bpm_history = []  # For å spore BPM-endringer
    energy_history = []  # For å spore energinivåer
    song_names = []  # For å spore sangnavn for tidslinjen
    camelot_keys = []  # For å spore Camelot-nøkler for visualisering
    current_song = random.choice(music_data)

    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']})")
    bpm_history.append(current_song['BPM'])
    energy_history.append(current_song['Energi'])
    song_names.append(current_song['Sang'])  # Legg til sangen i tidslinjen
    camelot_keys.append(current_song['Camelot Key'])  # Legg til Camelot-nøkkelen

    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)

        if next_song:
            print(f"Neste sang valgt: {next_song['Sang']} (Camelot Key: {next_song['Camelot Key']}, BPM: {next_song['BPM']}, Energi: {next_song['Energi']})")

            # Simuler crossfade basert på metadata
            if 'crossfade' in dj_techniques:
                print(f"Simulerer crossfade mellom {current_song['Sang']} og {next_song['Sang']} basert på BPM og energi.")

            # Simuler bruk av cue-punkter
            if 'cue_points' in dj_techniques:
                print(f"Simulerer cue-point overgang mellom {current_song['Sang']} og {next_song['Sang']}.")

            # Simuler beatmatching og tempojustering basert på metadata
            if abs(current_song['BPM'] - next_song['BPM']) > 0:
                print(f"Simulerer beatmatching og tempojustering for {next_song['Sang']} for å matche {current_song['Sang']}.")
                # Logg tempoendringen for visualisering
                bpm_history.append(next_song['BPM'])
                energy_history.append(next_song['Energi'])
                song_names.append(next_song['Sang'])  # Legg til neste sang i tidslinjen
                camelot_keys.append(next_song['Camelot Key'])  # Legg til Camelot-nøkkelen

            # Oppdater til neste sang
            current_song = next_song
            played_songs.append(current_song['Sang'])
        else:
            print("Ingen flere sanger tilgjengelig, mikseprosessen avsluttes.")
            break

    # Visualiser tempojusteringer med en graf
    plot_tempo_adjustments_with_timeline(bpm_history, energy_history, song_names, camelot_keys)

# Funksjon for å plotte tempojusteringer, energi og en miksesekvens (tidslinje) med Camelot-nøkler
def plot_tempo_adjustments_with_timeline(bpm_history, energy_history, song_names, camelot_keys):
    fig, ax1 = plt.subplots()

    color = 'tab:red'
    ax1.set_xlabel('Mix Sequence')
    ax1.set_ylabel('BPM', color=color)
    ax1.plot(bpm_history, color=color, label='BPM')
    ax1.tick_params(axis='y', labelcolor=color)

    # Lag en andre y-akse for energinivåer
    ax2 = ax1.twinx()
    color = 'tab:blue'
    ax2.set_ylabel('Energy', color=color)
    ax2.plot(energy_history, color=color, label='Energy')
    ax2.tick_params(axis='y', labelcolor=color)

    # Legg til tittel og labels
    plt.title('Tempojusteringer, Energihistorikk og Mikseoverganger')

    # Tegn en tidslinje for sangene og Camelot-nøklene
    for i, (song, camelot_key) in enumerate(zip(song_names, camelot_keys)):
        ax1.text(i, bpm_history[i] + 2, f"{song.split('_')[0]} ({camelot_key})", rotation=90, fontsize=8, ha='center')

    fig.tight_layout()
    plt.show()

# Kjør simuleringen med visualiseringer
ai_dj_simulation_with_visuals_and_timeline(music_data, camelot_wheel, dj_techniques)

import pandas as pd

# Les inn musikkdata fra CSV-filen
music_data = pd.read_csv('/path/to/music_analysis.csv')  # Endre til riktig filsti
print(f"Antall sanger lastet inn: {len(music_data)}")

# Skriv ut en kort oversikt over de første sangene
print(music_data[['Sang', 'BPM', 'Camelot Key', 'Energi']].head())

# Les inn Camelot-hjulet fra tekstfilen
with open('/path/to/camelot-wheel_processed.txt', 'r') as file:
    camelot_wheel = file.readlines()
    camelot_wheel = [line.strip() for line in camelot_wheel]

print(f"Camelot-hjulet inneholder: {camelot_wheel}")

import pandas as pd

# Riktig filsti til musikkdata
music_data = pd.read_csv('/content/drive/MyDrive/SuperDJ_Project/music_analysis/music_analysis.csv')  # Endret til riktig sti
print(f"Antall sanger lastet inn: {len(music_data)}")

# Skriv ut en kort oversikt over de første sangene
print(music_data[['Sang', 'BPM', 'Camelot Key', 'Energi']].head())

# Riktig filsti til Camelot-hjulet
with open('/content/drive/MyDrive/SuperDJ_Project/collected_files/camelot-wheel_processed.txt', 'r') as file:
    camelot_wheel = file.readlines()
    camelot_wheel = [line.strip() for line in camelot_wheel]

print(f"Camelot-hjulet inneholder: {camelot_wheel}")

import pandas as pd
import re

# Riktig filsti til musikkdata
music_data = pd.read_csv('/content/drive/MyDrive/SuperDJ_Project/music_analysis/music_analysis.csv')
print(f"Antall sanger lastet inn: {len(music_data)}")
print(music_data[['Sang', 'BPM', 'Camelot Key', 'Energi']].head())

# Les inn Camelot-hjulet, og filtrer ut kun nøklene (formater som "1A", "12B", osv.)
with open('/content/drive/MyDrive/SuperDJ_Project/collected_files/camelot-wheel_processed.txt', 'r') as file:
    camelot_text = file.read()

# Bruk regex for å hente ut kun Camelot-nøkler (f.eks. "8A", "9B", osv.)
camelot_wheel = re.findall(r'\b\d{1,2}[AB]\b', camelot_text)

print(f"Camelot-hjulet inneholder nøkler: {camelot_wheel}")

import random

# Funksjon for å sjekke om to Camelot-nøkler er harmonisk kompatible
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    # Finn indexene til nøklene i Camelot-hjulet
    try:
        current_index = camelot_wheel.index(current_key)
        next_index = camelot_wheel.index(next_key)
        # Sjekk om de er naboer på Camelot-hjulet (hvis avstand er 1)
        return abs(current_index - next_index) <= 1
    except ValueError:
        return False

# Funksjon for å velge neste sang basert på harmonisk kompatibilitet, BPM og energi
def choose_next_song(current_song, music_data, camelot_wheel, played_songs):
    compatible_songs = []

    for _, song in music_data.iterrows():
        if song['Sang'] not in played_songs:
            # Sjekk om sangen er harmonisk kompatibel
            if is_harmonically_compatible(current_song['Camelot Key'], song['Camelot Key'], camelot_wheel):
                compatible_songs.append(song)

    if not compatible_songs:
        return None

    # Velg sang basert på nærmeste BPM
    next_song = min(compatible_songs, key=lambda s: abs(current_song['BPM'] - s['BPM']))

    return next_song

# Start simuleringen
def ai_dj_simulation(music_data, camelot_wheel):
    played_songs = []
    current_song = random.choice(music_data.to_dict(orient='records'))  # Velg en tilfeldig start-sang
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']})")
    played_songs.append(current_song['Sang'])

    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)

        if next_song:
            print(f"Neste sang valgt: {next_song['Sang']} (Camelot Key: {next_song['Camelot Key']}, BPM: {next_song['BPM']}, Energi: {next_song['Energi']})")
            played_songs.append(next_song['Sang'])
            current_song = next_song
        else:
            print("Ingen flere harmonisk kompatible sanger.")
            break

# Kjør simuleringen
ai_dj_simulation(music_data, camelot_wheel)

import random

# Funksjon for å sjekke om to Camelot-nøkler er harmonisk kompatible
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    # Finn indexene til nøklene i Camelot-hjulet
    try:
        current_index = camelot_wheel.index(current_key)
        next_index = camelot_wheel.index(next_key)
        # Sjekk om de er naboer på Camelot-hjulet (hvis avstand er 1)
        return abs(current_index - next_index) <= 1
    except ValueError:
        return False

# Funksjon for å velge neste sang basert på harmonisk kompatibilitet, BPM og energi
def choose_next_song(current_song, music_data, camelot_wheel, played_songs):
    compatible_songs = []

    for _, song in music_data.iterrows():
        if song['Sang'] not in played_songs:
            # Sjekk om sangen er harmonisk kompatibel
            if is_harmonically_compatible(current_song['Camelot Key'], song['Camelot Key'], camelot_wheel):
                compatible_songs.append(song)

    if not compatible_songs:
        return None

    # Velg sang basert på nærmeste BPM
    next_song = min(compatible_songs, key=lambda s: abs(current_song['BPM'] - s['BPM']))

    return next_song.to_dict()  # Konverter til dictionary for enkel tilgang til data

# Start simuleringen
def ai_dj_simulation(music_data, camelot_wheel):
    played_songs = []
    current_song = random.choice(music_data.to_dict(orient='records'))  # Velg en tilfeldig start-sang
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']})")
    played_songs.append(current_song['Sang'])

    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)

        if next_song:
            print(f"Neste sang valgt: {next_song['Sang']} (Camelot Key: {next_song['Camelot Key']}, BPM: {next_song['BPM']}, Energi: {next_song['Energi']})")
            played_songs.append(next_song['Sang'])
            current_song = next_song
        else:
            print("Ingen flere harmonisk kompatible sanger.")
            break

# Kjør simuleringen
ai_dj_simulation(music_data, camelot_wheel)

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Funksjon for å sjekke harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Funksjon for å finne sang med Camelot Key matching først
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_genre = current_song.get('Sjanger', 'Unknown')

    # 1. Camelot Key Matching
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 2. BPM og Energi Matching (med pitch-shift)
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            song = adjust_bpm(song)  # Juster BPM hvis det er under 100
            bpm_difference = abs(current_bpm - song['BPM'])
            pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
            if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                candidates.append(song)

    if candidates:
        # 3. Prioriter sjanger matching
        genre_matched_candidates = [song for song in candidates if song.get('Sjanger', 'Unknown') == current_genre]
        if genre_matched_candidates:
            selected_song = random.choice(genre_matched_candidates)
            print(f"Valgt sang basert på BPM, energi og sjanger: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        else:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")

        played_songs.append(selected_song['Sang'])
        return selected_song

    # 4. Hvis ingen kompatibel sang er funnet, velg tilfeldig sang innen ±30% BPM og energi
    print("Ingen kompatible sanger basert på BPM og energi, prøver med større toleranse (±30%).")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            bpm_difference = abs(current_bpm - song['BPM'])
            if bpm_difference <= current_bpm * 0.3:  # ±30% toleranse på BPM
                candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang innen ±30% BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 5. Til slutt, velg en tilfeldig sang
    print("Ingen sanger tilgjengelig, velger en tilfeldig sang fra de resterende.")
    remaining_songs = [song

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Funksjon for å sjekke harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Funksjon for å finne sang med Camelot Key matching først
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_genre = current_song.get('Sjanger', 'Unknown')

    # 1. Camelot Key Matching
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 2. BPM og Energi Matching (med pitch-shift)
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            song = adjust_bpm(song)  # Juster BPM hvis det er under 100
            bpm_difference = abs(current_bpm - song['BPM'])
            pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
            if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                candidates.append(song)

    if candidates:
        # 3. Prioriter sjanger matching
        genre_matched_candidates = [song for song in candidates if song.get('Sjanger', 'Unknown') == current_genre]
        if genre_matched_candidates:
            selected_song = random.choice(genre_matched_candidates)
            print(f"Valgt sang basert på BPM, energi og sjanger: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        else:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")

        played_songs.append(selected_song['Sang'])
        return selected_song

    # 4. Hvis ingen kompatibel sang er funnet, velg tilfeldig sang innen ±30% BPM og energi
    print("Ingen kompatible sanger basert på BPM og energi, prøver med større toleranse (±30%).")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            bpm_difference = abs(current_bpm - song['BPM'])
            if bpm_difference <= current_bpm * 0.3:  # ±30% toleranse på BPM
                candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang innen ±30% BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 5. Til slutt, velg en tilfeldig sang
    print("Ingen sanger tilgjengelig, velger en tilfeldig sang fra de resterende.")
    remaining_songs = [song for song in music_data if song['Sang'] not in played_songs]
    if remaining_songs:
        selected_song = random.choice(remaining_songs)
        print(f"Tilfeldig valgt sang: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song
    return None

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg flere sanger i rekkefølge til alle er spilt
    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            current_song = next_song
                else:
            break  # Avslutt hvis ingen flere sanger kan velges

    print("Spilleliste komplett. Her er rekkefølgen av spilte sanger:")
    for song in played_songs:
        print(f"- {song}")

# Hovedprogrammet som kjører analysen og velger sanger
def main():
    # Sti til mappen med JSON-filene dine
    json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'  # Bytt ut med riktig sti til JSON-filene dine

    # Last inn musikkdata fra JSON-filene
    music_data = load_music_data_from_json(json_directory)

    # Last inn Camelot-hjulet
    camelot_wheel = generate_camelot_wheel()

    # Velg sanger i rekkefølge basert på Camelot-hjulet, BPM, energi og sjanger
    select_songs_for_library(music_data, camelot_wheel)

# Kjør hovedprogrammet
if __name__ == '__main__':
    main()

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Funksjon for å sjekke harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Funksjon for å finne sang med Camelot Key matching først
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_genre = current_song.get('Sjanger', 'Unknown')

    # 1. Camelot Key Matching
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 2. BPM og Energi Matching (med pitch-shift)
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            song = adjust_bpm(song)  # Juster BPM hvis det er under 100
            bpm_difference = abs(current_bpm - song['BPM'])
            pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
            if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                candidates.append(song)

    if candidates:
        # 3. Prioriter sjanger matching
        genre_matched_candidates = [song for song in candidates if song.get('Sjanger', 'Unknown') == current_genre]
        if genre_matched_candidates:
            selected_song = random.choice(genre_matched_candidates)
            print(f"Valgt sang basert på BPM, energi og sjanger: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        else:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")

        played_songs.append(selected_song['Sang'])
        return selected_song

    # 4. Hvis ingen kompatibel sang er funnet, velg tilfeldig sang innen ±30% BPM og energi
    print("Ingen kompatible sanger basert på BPM og energi, prøver med større toleranse (±30%).")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            bpm_difference = abs(current_bpm - song['BPM'])
            if bpm_difference <= current_bpm * 0.3:  # ±30% toleranse på BPM
                candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang innen ±30% BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 5. Til slutt, velg en tilfeldig sang
    print("Ingen sanger tilgjengelig, velger en tilfeldig sang fra de resterende.")
    remaining_songs = [song for song in music_data if song['Sang'] not in played_songs]
    if remaining_songs:
        selected_song = random.choice(remaining_songs)
        print(f"Tilfeldig valgt sang: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song
    return None

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg flere sanger i rekkefølge til alle er spilt
    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            # Simulerer miksing mellom sangene
            print(f"Mikser fra {current_song['Sang']} til {next_song['Sang']} ...")
            # Beatmatching og tempojustering
            if abs(current_song['BPM'] - next_song['BPM']) > 0:
                print(f"Justerer tempo fra {current_song['BPM']} BPM til {next_song['BPM']} BPM for beatmatching.")
            # Simulerer crossfade
            print(f"Crossfader fra {current_song['Sang']} til {next_song['Sang']} ...")
            print(f"{current_song['Sang']} slutter å spille, og {next_song['Sang']} spiller fullt ut.")

            # Oppdaterer nåværende sang til neste sang
            current_song = next_song
            played_songs.append(current_song['Sang'])
        else:
            print("Ingen flere kompatible sanger tilgjengelig. Avslutter mikseprosessen.")
            break

    print("Spilleliste komplett. Her er rekkefølgen av spilte sanger:")
    for song in played_songs:
        print(f"- {song}")

# Hovedprogrammet som kjører analysen og velger sanger
def main():
    # Sti til mappen med JSON-filene dine
    json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'  # Bytt ut med riktig sti til JSON-filene dine

    # Last inn musikkdata fra JSON-filene
    music_data = load_music_data_from_json(json_directory)

    # Last inn Camelot-hjulet
    camelot_wheel = generate_camelot_wheel()

    # Velg sanger i rekkefølge basert på Camelot-hjulet, BPM, energi og sjanger
    select_songs_for_library(music_data, camelot_wheel)

# Kjør hovedprogrammet
if __name__ == '__main__':
    main()

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Funksjon for å sjekke harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Funksjon for å finne sang med Camelot Key matching først
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_genre = current_song.get('Sjanger', 'Unknown')

    # 1. Camelot Key Matching
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 2. BPM og Energi Matching (med pitch-shift)
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            song = adjust_bpm(song)  # Juster BPM hvis det er under 100
            bpm_difference = abs(current_bpm - song['BPM'])
            pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
            if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                candidates.append(song)

    if candidates:
        # 3. Prioriter sjanger matching
        genre_matched_candidates = [song for song in candidates if song.get('Sjanger', 'Unknown') == current_genre]
        if genre_matched_candidates:
            selected_song = random.choice(genre_matched_candidates)
            print(f"Valgt sang basert på BPM, energi og sjanger: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        else:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")

        played_songs.append(selected_song['Sang'])
        return selected_song

    return None

# Legg til denne funksjonen for å simulere miksetid og startposisjon
def simulate_mix_time(current_song, next_song, crossfade_time=10):
    current_song_length = random.randint(180, 300)  # Simulerer sanglengde mellom 3 til 5 minutter
    next_song_length = random.randint(180, 300)

    # Print startposisjoner
    print(f"Starter å spille '{current_song['Sang']}' fra 0s.")
    mix_start_time = random.randint(60, current_song_length - 30)  # Miksen starter et sted i sangen
    print(f"Miksen starter etter {mix_start_time}s, crossfade på {crossfade_time}s.")

    # Simulerer mikseprosessen
    print(f"Crossfader fra '{current_song['Sang']}' til '{next_song['Sang']}'...")
    mix_end_time = mix_start_time + crossfade_time
    print(f"'{current_song['Sang']}' slutter etter {mix_end_time}s, '{next_song['Sang']}' spiller fullt ut fra 0s.")

    return next_song

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg flere sanger i rekkefølge til alle er spilt
    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            # Simuler mikseprosessen med crossfade og utskrift
            current_song = simulate_mix_time(current_song, next_song)
        else:
            print("Ingen flere sanger tilgjengelig, avslutter mikseprosessen.")
            break

    print("Spilleliste komplett. Her er rekkefølgen av spilte sanger:")
    for song in played_songs:
        print(f"- {song}")

# Hovedprogrammet som kjører analysen og velger sanger
def main():
    # Sti til mappen med JSON-filene dine
    json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'  # Bytt ut med riktig sti til JSON-filene dine

        # Last inn musikkdata fra JSON-filene
    music_data = load_music_data_from_json(json_directory)

    # Last inn Camelot-hjulet
    camelot_wheel = generate_camelot_wheel()

    # Velg sanger i rekkefølge basert på Camelot-hjulet, BPM, energi og sjanger
    select_songs_for_library(music_data, camelot_wheel)

# Kjør hovedprogrammet
if __name__ == '__main__':
    main()

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Funksjon for å sjekke harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Funksjon for å finne sang med Camelot Key matching først
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_genre = current_song.get('Sjanger', 'Unknown')

    # 1. Camelot Key Matching
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 2. BPM og Energi Matching (med pitch-shift)
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            song = adjust_bpm(song)  # Juster BPM hvis det er under 100
            bpm_difference = abs(current_bpm - song['BPM'])
            pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
            if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                candidates.append(song)

    if candidates:
        # 3. Prioriter sjanger matching
        genre_matched_candidates = [song for song in candidates if song.get('Sjanger', 'Unknown') == current_genre]
        if genre_matched_candidates:
            selected_song = random.choice(genre_matched_candidates)
            print(f"Valgt sang basert på BPM, energi og sjanger: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        else:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")

        played_songs.append(selected_song['Sang'])
        return selected_song

    return None

# Legg til denne funksjonen for å simulere miksetid og dynamisk crossfade
def simulate_mix_time(current_song, next_song, max_crossfade_time=15):
    current_song_length = random.randint(180, 300)  # Simulerer sanglengde mellom 3 til 5 minutter
    next_song_length = random.randint(180, 300)

    # Beregn dynamisk crossfade basert på BPM-forskjell, energi og sjanger
    bpm_diff = abs(current_song['BPM'] - next_song['BPM'])
    energy_diff = abs(current_song['Energi'] - next_song['Energi'])

    crossfade_time = max_crossfade_time - int((bpm_diff + energy_diff) / 2)  # Juster crossfade-tid dynamisk
    if crossfade_time < 5:
        crossfade_time = 5  # Minste crossfade-tid

    # Print startposisjoner
    print(f"Starter å spille '{current_song['Sang']}' fra 0s.")
    mix_start_time = random.randint(60, current_song_length - 30)  # Miksen starter et sted i sangen
    next_song_start_time = random.randint(0, next_song_length - 30)  # Neste sang starter et sted i sangen
    print(f"Miksen starter etter {mix_start_time}s i '{current_song['Sang']}' og {next_song_start_time}s i '{next_song['Sang']}'.")

    # Simulerer mikseprosessen
    print(f"Crossfader fra '{current_song['Sang']}' til '{next_song['Sang']}' over {crossfade_time}s.")
    mix_end_time = mix_start_time + crossfade_time
    print(f"'{current_song['Sang']}' slutter etter {mix_end_time}s, '{next_song['Sang']}' spiller fullt ut fra {next_song_start_time}s.")  # Korrekt innrykk

    return next_song

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg flere sanger i rekkefølge til alle er spilt
    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            # Simuler mikseprosessen med dynamisk crossfade og utskrift
            current_song = simulate_mix_time(current_song, next_song)
        else:
            print("Ingen flere sanger tilgjengelig, avslutter mikseprosessen.")
            break

    print("Spilleliste komplett. Her er rekkefølgen av spilte sanger:")
    for song in played_songs:
        print(f"- {song}")

# Hovedprogrammet som kjører analysen og velger sanger
def main():
    # Sti til mappen med JSON-filene dine
    json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'  # Bytt ut med riktig sti til JSON-filene dine

    # Last inn musikkdata fra JSON-filene
    music_data = load_music_data_from_json(json_directory)

    # Last inn Camelot-hjulet
    camelot_wheel = generate_camelot_wheel()

    # Velg sanger i rekkefølge basert på Camelot-hjulet, BPM, energi og sjanger
    select_songs_for_library(music_data, camelot_wheel)

# Kjør hovedprogrammet
if __name__ == '__main__':
    main()

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Funksjon for å sjekke harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Funksjon for å finne sang med Camelot Key matching først
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_genre = current_song.get('Sjanger', 'Unknown')

    # 1. Camelot Key Matching
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 2. BPM og Energi Matching (med pitch-shift)
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            song = adjust_bpm(song)  # Juster BPM hvis det er under 100
            bpm_difference = abs(current_bpm - song['BPM'])
            pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
            if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                candidates.append(song)

    if candidates:
        # 3. Prioriter sjanger matching
        genre_matched_candidates = [song for song in candidates if song.get('Sjanger', 'Unknown') == current_genre]
        if genre_matched_candidates:
            selected_song = random.choice(genre_matched_candidates)
            print(f"Valgt sang basert på BPM, energi og sjanger: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        else:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")

        played_songs.append(selected_song['Sang'])
        return selected_song

    return None
# Legg til denne funksjonen for å simulere miksetid og dynamisk crossfade
def simulate_mix_time(current_song, next_song, max_crossfade_time=15):
    current_song_length = random.randint(180, 300)  # Simulerer sanglengde mellom 3 til 5 minutter
    next_song_length = random.randint(180, 300)

    # Beregn dynamisk crossfade basert på BPM-forskjell, energi og sjanger
    bpm_diff = abs(current_song['BPM'] - next_song['BPM'])
    energy_diff = abs(current_song['Energi'] - next_song['Energi'])

    crossfade_time = max_crossfade_time - int((bpm_diff + energy_diff) / 2)  # Juster crossfade-tid dynamisk
    if crossfade_time < 5:
        crossfade_time = 5  # Minste crossfade-tid

    # Print startposisjoner
    print(f"Starter å spille '{current_song['Sang']}' fra 0s.")
    mix_start_time = random.randint(60, current_song_length - 30)  # Miksen starter et sted i sangen
    next_song_start_time = random.randint(0, next_song_length - 30)  # Neste sang starter et sted i sangen
    print(f"Miksen starter etter {mix_start_time}s i '{current_song['Sang']}' og {next_song_start_time}s i '{next_song['Sang']}'.")

    # Simulerer mikseprosessen
    print(f"Crossfader fra '{current_song['Sang']}' til '{next_song['Sang']}' over {crossfade_time}s.")
    mix_end_time = mix_start_time + crossfade_time
    print(f"'{current_song['Sang']}' slutter etter {mix_end_time}s, '{next_song['Sang']}' spiller fullt ut fra {next_song_start_time}s.")

    return next_song

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Funksjon for å sjekke harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Funksjon for å finne sang med Camelot Key matching først
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_genre = current_song.get('Sjanger', 'Unknown')

    # 1. Camelot Key Matching
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 2. BPM og Energi Matching (med pitch-shift)
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            song = adjust_bpm(song)  # Juster BPM hvis det er under 100
            bpm_difference = abs(current_bpm - song['BPM'])
            pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
            if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                candidates.append(song)

    if candidates:
        # 3. Prioriter sjanger matching
        genre_matched_candidates = [song for song in candidates if song.get('Sjanger', 'Unknown') == current_genre]
        if genre_matched_candidates:
            selected_song = random.choice(genre_matched_candidates)
            print(f"Valgt sang basert på BPM, energi og sjanger: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        else:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")

        played_songs.append(selected_song['Sang'])
        return selected_song

    return None
# Legg til denne funksjonen for å simulere miksetid og dynamisk crossfade
def simulate_mix_time(current_song, next_song, max_crossfade_time=15):
    current_song_length = random.randint(180, 300)  # Simulerer sanglengde mellom 3 til 5 minutter
    next_song_length = random.randint(180, 300)

    # Beregn dynamisk crossfade basert på BPM-forskjell, energi og sjanger
    bpm_diff = abs(current_song['BPM'] - next_song['BPM'])
    energy_diff = abs(current_song['Energi'] - next_song['Energi'])

    crossfade_time = max_crossfade_time - int((bpm_diff + energy_diff) / 2)  # Juster crossfade-tid dynamisk
    if crossfade_time < 5:
        crossfade_time = 5  # Minste crossfade-tid

    # Print startposisjoner
    print(f"Starter å spille '{current_song['Sang']}' fra 0s.")
    mix_start_time = random.randint(60, current_song_length - 30)  # Miksen starter et sted i sangen
    next_song_start_time = random.randint(0, next_song_length - 30)  # Neste sang starter et sted i sangen
    print(f"Miksen starter etter {mix_start_time}s i '{current_song['Sang']}' og {next_song_start_time}s i '{next_song['Sang']}'.")

    # Simulerer mikseprosessen
    print(f"Crossfader fra '{current_song['Sang']}' til '{next_song['Sang']}' over {crossfade_time}s.")
    mix_end_time = mix_start_time + crossfade_time
    print(f"'{current_song['Sang']}' slutter etter {mix_end_time}s, '{next_song['Sang']}' spiller fullt ut fra {next_song_start_time}s.")

    return next_song

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg flere sanger i rekkefølge til alle er spilt
    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            # Simuler mikseprosessen med dynamisk crossfade og utskrift
            current_song = simulate_mix_time(current_song, next_song)
        else:
            print("Ingen flere sanger tilgjengelig, avslutter mikseprosessen.")
            break

    print("Spilleliste komplett. Her er rekkefølgen av spilte sanger:")
    for song in played_songs:
        print(f"- {song}")

# Hovedprogrammet som kjører analysen og velger sanger
def main():
    # Sti til mappen med JSON-filene dine
    json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'  # Bytt ut med riktig sti til JSON-filene dine

    # Last inn musikkdata fra JSON-filene
    music_data = load_music_data_from_json(json_directory)

    # Last inn Camelot-hjulet
    camelot_wheel = generate_camelot_wheel()

    # Velg sanger i rekkefølge basert på Camelot-hjulet, BPM, energi og sjanger
    select_songs_for_library(music_data, camelot_wheel)

# Kjør hovedprogrammet
if __name__ == '__main__':
    main()

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Funksjon for å sjekke harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Funksjon for å finne sang med Camelot Key matching først
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_genre = current_song.get('Sjanger', 'Unknown')

    # 1. Camelot Key Matching
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 2. BPM og Energi Matching (med pitch-shift)
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            song = adjust_bpm(song)  # Juster BPM hvis det er under 100
            bpm_difference = abs(current_bpm - song['BPM'])
            pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
            if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                candidates.append(song)

    if candidates:
        # 3. Prioriter sjanger matching
        genre_matched_candidates = [song for song in candidates if song.get('Sjanger', 'Unknown') == current_genre]
        if genre_matched_candidates:
            selected_song = random.choice(genre_matched_candidates)
            print(f"Valgt sang basert på BPM, energi og sjanger: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        else:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")

        played_songs.append(selected_song['Sang'])
        return selected_song

    return None
# Legg til denne funksjonen for å simulere miksetid og dynamisk crossfade
def simulate_mix_time(current_song, next_song, max_crossfade_time=15):
    current_song_length = random.randint(180, 300)  # Simulerer sanglengde mellom 3 til 5 minutter
    next_song_length = random.randint(180, 300)

    # Beregn dynamisk crossfade basert på BPM-forskjell, energi og sjanger
    bpm_diff = abs(current_song['BPM'] - next_song['BPM'])
    energy_diff = abs(current_song['Energi'] - next_song['Energi'])

    crossfade_time = max_crossfade_time - int((bpm_diff + energy_diff) / 2)  # Juster crossfade-tid dynamisk
    if crossfade_time < 5:
        crossfade_time = 5  # Minste crossfade-tid

    # Print startposisjoner
    print(f"Starter å spille '{current_song['Sang']}' fra 0s.")
    mix_start_time = random.randint(60, current_song_length - 30)  # Miksen starter et sted i sangen
    next_song_start_time = random.randint(0, next_song_length - 30)  # Neste sang starter et sted i sangen
    print(f"Miksen starter etter {mix_start_time}s i '{current_song['Sang']}' og {next_song_start_time}s i '{next_song['Sang']}'.")

    # Simulerer mikseprosessen
    print(f"Crossfader fra '{current_song['Sang']}' til '{next_song['Sang']}' over {crossfade_time}s.")
    mix_end_time = mix_start_time + crossfade_time
    print(f"'{current_song['Sang']}' slutter etter {mix_end_time}s, '{next_song['Sang']}' spiller fullt ut fra {next_song_start_time}s.")

    return next_song

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg flere sanger i rekkefølge til alle er spilt
    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            # Simuler mikseprosessen med dynamisk crossfade og utskrift
            current_song = simulate_mix_time(current_song, next_song)
        else:
            print("Ingen flere sanger tilgjengelig, avslutter mikseprosessen.")
            break

    print("Spilleliste komplett. Her er rekkefølgen av spilte sanger:")
    for song in played_songs:
        print(f"- {song}")

# Hovedprogrammet som kjører analysen og velger sanger
def main():
    # Sti til mappen med JSON-filene dine
    json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'  # Bytt ut med riktig sti til JSON-filene dine

    # Last inn musikkdata fra JSON-filene
    music_data = load_music_data_from_json(json_directory)

    # Last inn Camelot-hjulet
    camelot_wheel = generate_camelot_wheel()

    # Velg sanger i rekkefølge basert på Camelot-hjulet, BPM, energi og sjanger
    select_songs_for_library(music_data, camelot_wheel)

# Kjør hovedprogrammet
if __name__ == '__main__':
    main()

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel
# Funksjon for å sjekke harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Funksjon for å finne sang med Camelot Key matching først
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_genre = current_song.get('Sjanger', 'Unknown')

        # 1. Camelot Key Matching
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 2. BPM og Energi Matching (med pitch-shift)
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            song = adjust_bpm(song)  # Juster BPM hvis det er under 100
            bpm_difference = abs(current_bpm - song['BPM'])
            pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
            if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                candidates.append(song)

    if candidates:
        # 3. Prioriter sjanger matching
        genre_matched_candidates = [song for song in candidates if song.get('Sjanger', 'Unknown') == current_genre]
        if genre_matched_candidates:
            selected_song = random.choice(genre_matched_candidates)
            print(f"Valgt sang basert på BPM, energi og sjanger: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        else:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")

        played_songs.append(selected_song['Sang'])
        return selected_song

    return None

# Ny funksjon for å simulere miksetid og dynamisk crossfade med sjanger og energi
def simulate_mix_time_advanced(current_song, next_song, max_crossfade_time=15):
    current_song_length = random.randint(180, 300)  # Simulerer sanglengde mellom 3 til 5 minutter
    next_song_length = random.randint(180, 300)

    # Beregn dynamisk crossfade basert på BPM-forskjell, energi, sjanger og harmonisk kompatibilitet
    bpm_diff = abs(current_song['BPM'] - next_song['BPM'])
    energy_diff = abs(current_song['Energi'] - next_song['Energi'])

    # Hvis sjangrene er veldig ulike, gjør crossfaden lenger
    genre_diff = 1 if current_song.get('Sjanger') == next_song.get('Sjanger') else 3  # Øk crossfade-tiden for ulike sjangre

    # Juster crossfade-tid basert på BPM, energi og sjangerforskjell
    crossfade_time = max_crossfade_time - int((bpm_diff + energy_diff) / 2) + genre_diff
    if crossfade_time < 5:
        crossfade_time = 5  # Minste crossfade-tid

    # Print startposisjoner
    print(f"Starter å spille '{current_song['Sang']}' fra 0s.")
    mix_start_time = random.randint(60, current_song_length - 30)  # Miksen starter et sted i sangen
    next_song_start_time = random.randint(0, next_song_length - 30)  # Neste sang starter et sted i sangen
    print(f"Miksen starter etter {mix_start_time}s i '{current_song['Sang']}' og {next_song_start_time}s i '{next_song['Sang']}'.")

    # Simulerer mikseprosessen med forbedret logikk
    print(f"Crossfader fra '{current_song['Sang']}' til '{next_song['Sang']}' over {crossfade_time}s.")
    mix_end_time = mix_start_time + crossfade_time
    print(f"'{current_song['Sang']}' slutter etter {mix_end_time}s, '{next_song['Sang']}' spiller fullt ut fra {next_song_start_time}s.")

    return next_song


# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg flere sanger i rekkefølge til alle er spilt
    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            # Simuler mikseprosessen med dynamisk crossfade og utskrift
            current_song = simulate_mix_time(current_song, next_song)
        else:
            print("Ingen flere sanger tilgjengelig, avslutter mikseprosessen.")
            break

    print("Spilleliste komplett. Her er rekkefølgen av spilte sanger:")
    for song in played_songs:
        print(f"- {song}")

# Hovedprogrammet som kjører analysen og velger sanger
def main():
    # Sti til mappen med JSON-filene dine
    json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'  # Bytt ut med riktig sti til JSON-filene dine

    # Last inn musikkdata fra JSON-filene
    music_data = load_music_data_from_json(json_directory)

    # Last inn Camelot-hjulet
    camelot_wheel = generate_camelot_wheel()

    # Velg sanger i rekkefølge basert på Camelot-hjulet, BPM, energi og sjanger
    select_songs_for_library(music_data, camelot_wheel)

# Kjør hovedprogrammet
if __name__ == '__main__':
    main()

from google.colab import drive
drive.mount('/content/drive')

import matplotlib.pyplot as plt

# Data fra analysen du sendte
song_data = [
    {'song': '17843367_Push Up (Club Version)_(Club Version).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135},
    {'song': '17399871_Brembo_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222},
    {'song': '17944376_Who Was In Paris__(Original Mix).mp3', 'mix_start': 108, 'crossfade_duration': 15, 'play_duration': 123},
    {'song': '17646318_Mini Skirt On_(Original Mix).mp3', 'mix_start': 89, 'crossfade_duration': 15, 'play_duration': 104},
    {'song': '17399873_RavPower_(Original Mix).mp3', 'mix_start': 93, 'crossfade_duration': 5, 'play_duration': 98},
    {'song': '17588048_Believer_(Original Mix).mp3', 'mix_start': 76, 'crossfade_duration': 12, 'play_duration': 88},
    {'song': '17985216_Spring Girl_(Extended).mp3', 'mix_start': 158, 'crossfade_duration': 15, 'play_duration': 173},
    {'song': '17588819_Sitar_(Original Mix).mp3', 'mix_start': 117, 'crossfade_duration': 5, 'play_duration': 122},
    {'song': '17420303_Anxiete_(Original Mix).mp3', 'mix_start': 167, 'crossfade_duration': 11, 'play_duration': 178},
    {'song': '17863930_Music, Baby_(Original Mix).mp3', 'mix_start': 192, 'crossfade_duration': 15, 'play_duration': 207},
    {'song': '16149902_Own Methods (Extented Mix)_(Original Mix).mp3', 'mix_start': 99, 'crossfade_duration': 15, 'play_duration': 114},
    {'song': '17791537_Sweating on the Dancefloor_(Original Mix).mp3', 'mix_start': 109, 'crossfade_duration': 11, 'play_duration': 120},
    {'song': '17440571_Eat Sleep Rave Repeat_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222},
    {'song': '17558154_Ride or Die_(Original Mix).mp3', 'mix_start': 189, 'crossfade_duration': 15, 'play_duration': 204},
    {'song': '17906546_Black Magic_(Extended Mix).mp3', 'mix_start': 153, 'crossfade_duration': 6, 'play_duration': 159},
    {'song': '17752861_Donkers_(Original Mix).mp3', 'mix_start': 136, 'crossfade_duration': 13, 'play_duration': 149},
    {'song': '17576432_All The Things_(Original Mix).mp3', 'mix_start': 175, 'crossfade_duration': 13, 'play_duration': 188},
    {'song': '17477194_Boom Boom Boom_(Extended Mix).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135},
    {'song': '17446613_Hybrid Boom_(Original Mix).mp3', 'mix_start': 102, 'crossfade_duration': 5, 'play_duration': 107},
    {'song': '17757614_Fearless_(Phoenix Movement Remix).mp3', 'mix_start': 130, 'crossfade_duration': 12, 'play_duration': 142},
    {'song': '17564479_KOKA_(Original Mix).mp3', 'mix_start': 183, 'crossfade_duration': 9, 'play_duration': 192},
    {'song': '18081983_T.O.K.Y.O._(Extended Mix).mp3', 'mix_start': 85, 'crossfade_duration': 7, 'play_duration': 92},
    {'song': '17880959_Fuck This_(Original Mix).mp3', 'mix_start': 82, 'crossfade_duration': 11, 'play_duration': 93},
    {'song': '18420294_Got That Booty_(Extended Mix).mp3', 'mix_start': 216, 'crossfade_duration': 10, 'play_duration': 226},
    {'song': '18222120_It_s That Time (Dimension Remix)_(Original Mix).mp3', 'mix_start': 117, 'crossfade_duration': 5, 'play_duration': 122},
    {'song': '17723361_F_CK THE POLICE_(Original Mix).mp3', 'mix_start': 190, 'crossfade_duration': 15, 'play_duration': 205},
    {'song': '17399872_Ashika_(Original Mix).mp3', 'mix_start': 161, 'crossfade_duration': 15, 'play_duration': 176},
    {'song': '17951244_Everytime I_m In The Streets_(Original Mix).mp3', 'mix_start': 157, 'crossfade_duration': 7, 'play_duration': 164},
    {'song': '17923279_Fine Day Anthem_(Extended Mix).mp3', 'mix_start': 118, 'crossfade_duration': 7, 'play_duration': 125},
    {'song': '17536420_1vs1 (Joann remix) feat. Joann_(Original Mix).mp3', 'mix_start': 201, 'crossfade_duration': 15, 'play_duration': 216},
    {'song': '17951242_The Ladies Gon Feel Me_(Original Mix).mp3', 'mix_start': 127, 'crossfade_duration': 11, 'play_duration': 138},
    {'song': '17997183_My Gasoline_(Extended Mix).mp3', 'mix_start': 0, 'crossfade_duration': 0, 'play_duration': 0} # siste sang, ingen miksepunkt
]

# Funksjon for å visualisere mikseprosessen
def visualize_mix(song_data):
    fig, ax = plt.subplots(figsize=(15, 12))

    # Variabel for å holde styr på den totale varigheten av hele miksen
    total_duration = 0

    for i, song in enumerate(song_data):
        mix_start = song['mix_start']
        crossfade_duration = song['crossfade_duration']
        play_duration = song['play_duration']
        song_name = song['song']

        # Plot sangen som en horisontal linje
        ax.plot([total_duration, total_duration + play_duration], [i, i], color='blue', linewidth=6, alpha=0.6)

        # Marker crossfade-segmentet på linjen
        ax.plot([total_duration + mix_start, total_duration + mix_start + crossfade_duration], [i, i], color='yellow', linewidth=6, alpha=0.8)

        # Legg til sangnavnet
        ax.text(total_duration + play_duration / 2, i, song_name, va='center', ha='right', fontsize=10, color='black', weight='bold')

        # Oppdater total varighet for neste sang
        total_duration += play_duration

    # Tilpass grafen
    ax.set_xlabel('Tid (sekunder)')
    ax.set_yticks(range(len(song_data)))
    ax.set_yticklabels([f'Sang {i+1}' for i in range(len(song_data))])
    ax.set_title('Visualisering av Mikseprosessen')
    plt.tight_layout()
    plt.show()

# Kjør visualiseringen
visualize_mix(song_data)

import matplotlib.pyplot as plt

# Data fra analysen du sendte
song_data = [
    {'song': '17843367_Push Up (Club Version)_(Club Version).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135},
    {'song': '17399871_Brembo_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222},
    {'song': '17944376_Who Was In Paris__(Original Mix).mp3', 'mix_start': 108, 'crossfade_duration': 15, 'play_duration': 123},
    {'song': '17646318_Mini Skirt On_(Original Mix).mp3', 'mix_start': 89, 'crossfade_duration': 15, 'play_duration': 104},
    {'song': '17399873_RavPower_(Original Mix).mp3', 'mix_start': 93, 'crossfade_duration': 5, 'play_duration': 98},
    {'song': '17588048_Believer_(Original Mix).mp3', 'mix_start': 76, 'crossfade_duration': 12, 'play_duration': 88},
    {'song': '17985216_Spring Girl_(Extended).mp3', 'mix_start': 158, 'crossfade_duration': 15, 'play_duration': 173},
    {'song': '17588819_Sitar_(Original Mix).mp3', 'mix_start': 117, 'crossfade_duration': 5, 'play_duration': 122},
    {'song': '17420303_Anxiete_(Original Mix).mp3', 'mix_start': 167, 'crossfade_duration': 11, 'play_duration': 178},
    {'song': '17863930_Music, Baby_(Original Mix).mp3', 'mix_start': 192, 'crossfade_duration': 15, 'play_duration': 207},
    {'song': '16149902_Own Methods (Extented Mix)_(Original Mix).mp3', 'mix_start': 99, 'crossfade_duration': 15, 'play_duration': 114},
    {'song': '17791537_Sweating on the Dancefloor_(Original Mix).mp3', 'mix_start': 109, 'crossfade_duration': 11, 'play_duration': 120},
    {'song': '17440571_Eat Sleep Rave Repeat_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222},
    {'song': '17558154_Ride or Die_(Original Mix).mp3', 'mix_start': 189, 'crossfade_duration': 15, 'play_duration': 204},
    {'song': '17906546_Black Magic_(Extended Mix).mp3', 'mix_start': 153, 'crossfade_duration': 6, 'play_duration': 159},
    {'song': '17752861_Donkers_(Original Mix).mp3', 'mix_start': 136, 'crossfade_duration': 13, 'play_duration': 149},
    {'song': '17576432_All The Things_(Original Mix).mp3', 'mix_start': 175, 'crossfade_duration': 13, 'play_duration': 188},
    {'song': '17477194_Boom Boom Boom_(Extended Mix).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135},
    {'song': '17446613_Hybrid Boom_(Original Mix).mp3', 'mix_start': 102, 'crossfade_duration': 5, 'play_duration': 107},
    {'song': '17757614_Fearless_(Phoenix Movement Remix).mp3', 'mix_start': 130, 'crossfade_duration': 12, 'play_duration': 142},
    {'song': '17564479_KOKA_(Original Mix).mp3', 'mix_start': 183, 'crossfade_duration': 9, 'play_duration': 192},
    {'song': '18081983_T.O.K.Y.O._(Extended Mix).mp3', 'mix_start': 85, 'crossfade_duration': 7, 'play_duration': 92},
    {'song': '17880959_Fuck This_(Original Mix).mp3', 'mix_start': 82, 'crossfade_duration': 11, 'play_duration': 93},
    {'song': '18420294_Got That Booty_(Extended Mix).mp3', 'mix_start': 216, 'crossfade_duration': 10, 'play_duration': 226},
    {'song': '18222120_It_s That Time (Dimension Remix)_(Original Mix).mp3', 'mix_start': 117, 'crossfade_duration': 5, 'play_duration': 122},
    {'song': '17723361_F_CK THE POLICE_(Original Mix).mp3', 'mix_start': 190, 'crossfade_duration': 15, 'play_duration': 205},
    {'song': '17399872_Ashika_(Original Mix).mp3', 'mix_start': 161, 'crossfade_duration': 15, 'play_duration': 176},
    {'song': '17951244_Everytime I_m In The Streets_(Original Mix).mp3', 'mix_start': 157, 'crossfade_duration': 7, 'play_duration': 164},
    {'song': '17923279_Fine Day Anthem_(Extended Mix).mp3', 'mix_start': 118, 'crossfade_duration': 7, 'play_duration': 125},
    {'song': '17536420_1vs1 (Joann remix) feat. Joann_(Original Mix).mp3', 'mix_start': 201, 'crossfade_duration': 15, 'play_duration': 216},
    {'song': '17951242_The Ladies Gon Feel Me_(Original Mix).mp3', 'mix_start': 127, 'crossfade_duration': 11, 'play_duration': 138},
    {'song': '17997183_My Gasoline_(Extended Mix).mp3', 'mix_start': 0, 'crossfade_duration': 0, 'play_duration': 0} # siste sang, ingen miksepunkt
]

# Funksjon for å visualisere mikseprosessen
def visualize_mix(song_data):
    fig, ax = plt.subplots(figsize=(15, 12))

    # Variabel for å holde styr på den totale varigheten av hele miksen
    total_duration = 0

    for i, song in enumerate(song_data):
        mix_start = song['mix_start']
        crossfade_duration = song['crossfade_duration']
        play_duration = song['play_duration']
        song_name = song['song']

        # Plot sangen som en horisontal linje
        ax.plot([total_duration, total_duration + play_duration], [i, i], color='blue', linewidth=6, alpha=0.6)

        # Marker crossfade-segmentet på linjen
        ax.plot([total_duration + mix_start, total_duration + mix_start + crossfade_duration], [i, i], color='yellow', linewidth=6, alpha=0.8)

        # Legg til sangnavnet
        ax.text(total_duration + play_duration / 2, i, song_name, va='center', ha='right', fontsize=10, color='black', weight='bold')

        # Oppdater total varighet for neste sang
        total_duration += play_duration

    # Tilpass grafen
    ax.set_xlabel('Tid (sekunder)')
    ax.set_yticks(range(len(song_data)))
    ax.set_yticklabels([f'Sang {i+1}' for i in range(len(song_data))])
    ax.set_title('Visualisering av Mikseprosessen')
    plt.tight_layout()
    plt.show()

# Kjør visualiseringen
visualize_mix(song_data)

import matplotlib.pyplot as plt
import numpy as np

# Data fra analysen du sendte, inkludert BPM og volum for illustrasjon
song_data = [
    {'song': '17843367_Push Up (Club Version)_(Club Version).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135, 'bpm': 161.5, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17399871_Brembo_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17944376_Who Was In Paris__(Original Mix).mp3', 'mix_start': 108, 'crossfade_duration': 15, 'play_duration': 123, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17646318_Mini Skirt On_(Original Mix).mp3', 'mix_start': 89, 'crossfade_duration': 15, 'play_duration': 104, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17399873_RavPower_(Original Mix).mp3', 'mix_start': 93, 'crossfade_duration': 5, 'play_duration': 98, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17588048_Believer_(Original Mix).mp3', 'mix_start': 76, 'crossfade_duration': 12, 'play_duration': 88, 'bpm': 129.2, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17985216_Spring Girl_(Extended).mp3', 'mix_start': 158, 'crossfade_duration': 15, 'play_duration': 173, 'bpm': 123.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17588819_Sitar_(Original Mix).mp3', 'mix_start': 117, 'crossfade_duration': 5, 'play_duration': 122, 'bpm': 123.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17420303_Anxiete_(Original Mix).mp3', 'mix_start': 167, 'crossfade_duration': 11, 'play_duration': 178, 'bpm': 143.6, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17863930_Music, Baby_(Original Mix).mp3', 'mix_start': 192, 'crossfade_duration': 15, 'play_duration': 207, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '16149902_Own Methods (Extented Mix)_(Original Mix).mp3', 'mix_start': 99, 'crossfade_duration': 15, 'play_duration': 114, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17791537_Sweating on the Dancefloor_(Original Mix).mp3', 'mix_start': 109, 'crossfade_duration': 11, 'play_duration': 120, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17440571_Eat Sleep Rave Repeat_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222, 'bpm': 143.6, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17558154_Ride or Die_(Original Mix).mp3', 'mix_start': 189, 'crossfade_duration': 15, 'play_duration': 204, 'bpm': 143.6, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17906546_Black Magic_(Extended Mix).mp3', 'mix_start': 153, 'crossfade_duration': 6, 'play_duration': 159, 'bpm': 143.6, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17752861_Donkers_(Original Mix).mp3', 'mix_start': 136, 'crossfade_duration': 13, 'play_duration': 149, 'bpm': 161.5, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17576432_All The Things_(Original Mix).mp3', 'mix_start': 175, 'crossfade_duration': 13, 'play_duration': 188, 'bpm': 166.7, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17477194_Boom Boom Boom_(Extended Mix).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135, 'bpm': 161.5, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17446613_Hybrid Boom_(Original Mix).mp3', 'mix_start': 102, 'crossfade_duration': 5, 'play_duration': 107, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17757614_Fearless_(Phoenix Movement Remix).mp3', 'mix_start': 130, 'crossfade_duration': 12, 'play_duration': 142, 'bpm': 129.2, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17564479_KOKA_(Original Mix).mp3', 'mix_start': 183, 'crossfade_duration': 9, 'play_duration': 192, 'bpm': 123.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '18081983_T.O.K.Y.O._(Extended Mix).mp3', 'mix_start': 85, 'crossfade_duration': 7, 'play_duration': 92, 'bpm': 136.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17880959_Fuck This_(Original Mix).mp3', 'mix_start': 82, 'crossfade_duration': 11, 'play_duration': 93, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '18420294_Got That Booty_(Extended Mix).mp3', 'mix_start': 216, 'crossfade_duration': 10, 'play_duration': 226, 'bpm': 161.5, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '18222120_It_s That Time (Dimension Remix)_(Original Mix).mp3', 'mix_start': 117, 'crossfade_duration': 5, 'play_duration': 122, 'bpm': 172.3, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17723361_F_CK THE POLICE_(Original Mix).mp3', 'mix_start': 190, 'crossfade_duration': 15, 'play_duration': 205, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17399872_Ashika_(Original Mix).mp3', 'mix_start': 161, 'crossfade_duration': 15, 'play_duration': 176, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17951244_Everytime I_m In The Streets_(Original Mix).mp3', 'mix_start': 157, 'crossfade_duration': 7, 'play_duration': 164, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17923279_Fine Day Anthem_(Extended Mix).mp3', 'mix_start': 118, 'crossfade_duration': 7, 'play_duration': 125, 'bpm': 136.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17536420_1vs1 (Joann remix) feat. Joann_(Original Mix).mp3', 'mix_start': 201, 'crossfade_duration': 15, 'play_duration': 216, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17951242_The Ladies Gon Feel Me_(Original Mix).mp3', 'mix_start': 127, 'crossfade_duration': 11, 'play_duration': 138, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17997183_My Gasoline_(Extended Mix).mp3', 'mix_start': 0, 'crossfade_duration': 0, 'play_duration': 0, 'bpm': 143.6, 'volume_start': 0.0, 'volume_end': 0.0} # siste sang, ingen miksepunkt
]

# Funksjon for å visualisere mikseprosessen med detaljer som BPM og volum
def visualize_mix(song_data):
    fig, ax = plt.subplots(figsize=(15, 12))
    total_duration = 0

    for i, song in enumerate(song_data):
        mix_start = song['mix_start']
        crossfade_duration = song['crossfade_duration']
        play_duration = song['play_duration']
        song_name = song['song']
        bpm = song['bpm']
        volume_start = song['volume_start']
        volume_end = song['volume_end']

        # Plot sangen som en horisontal linje
        ax.plot([total_duration, total_duration + play_duration], [i, i], color='blue', linewidth=6, alpha=0.6)

        # Marker crossfade-segmentet på linjen
        ax.plot([total_duration + mix_start, total_duration + mix_start + crossfade_duration], [i, i], color='yellow', linewidth=6, alpha=0.8)

        # Marker BPM-endringer med en linje
        ax.plot([total_duration, total_duration + play_duration], [i + 0.1, i + 0.1], color='red', linewidth=2, alpha=0.6)
        ax.text(total_duration + play_duration / 2, i + 0.15, f'BPM: {bpm}', va='center', ha='center', fontsize=8, color='red')

        # Visualisere volumkurven (forenklet)
        ax.plot([total_duration, total_duration + play_duration], [i - 0.1, i - 0.1], color='green', linewidth=2, alpha=0.6)
        ax.text(total_duration + play_duration / 2, i - 0.15, f'Volum: {volume_start} -> {volume_end}', va='center', ha='center', fontsize=8, color='green')

        # Legg til sangnavnet
        ax.text(total_duration + play_duration / 2, i, song_name, va='center', ha='right', fontsize=10, color='black', weight='bold')

        # Oppdater total varighet for neste sang
        total_duration += play_duration

    # Tilpass grafen
    ax.set_xlabel('Tid (sekunder)')
    ax.set_yticks(range(len(song_data)))
    ax.set_yticklabels([f'Sang {i+1}' for i in range(len(song_data))])
    ax.set_title('Visualisering av Mikseprosessen med BPM og Volum')
    plt.tight_layout()
    plt.show()

# Kjør visualiseringen
visualize_mix(song_data)

pip install matplotlib

import matplotlib.pyplot as plt
import matplotlib.animation as animation

# Komplett data fra analysen inkludert BPM og volum for visualisering
song_data = [
    {'song': '17843367_Push Up (Club Version)_(Club Version).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135, 'bpm': 161.5, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17399871_Brembo_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17944376_Who Was In Paris__(Original Mix).mp3', 'mix_start': 108, 'crossfade_duration': 15, 'play_duration': 123, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17646318_Mini Skirt On_(Original Mix).mp3', 'mix_start': 89, 'crossfade_duration': 15, 'play_duration': 104, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17399873_RavPower_(Original Mix).mp3', 'mix_start': 93, 'crossfade_duration': 5, 'play_duration': 98, 'bpm': 151.5, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17588048_Believer_(Original Mix).mp3', 'mix_start': 76, 'crossfade_duration': 12, 'play_duration': 88, 'bpm': 129.2, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17985216_Spring Girl_(Extended).mp3', 'mix_start': 158, 'crossfade_duration': 15, 'play_duration': 173, 'bpm': 123.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17588819_Sitar_(Original Mix).mp3', 'mix_start': 117, 'crossfade_duration': 5, 'play_duration': 122, 'bpm': 123.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17420303_Anxiete_(Original Mix).mp3', 'mix_start': 167, 'crossfade_duration': 11, 'play_duration': 178, 'bpm': 143.6, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17863930_Music, Baby_(Original Mix).mp3', 'mix_start': 192, 'crossfade_duration': 15, 'play_duration': 207, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '16149902_Own Methods (Extented Mix)_(Original Mix).mp3', 'mix_start': 99, 'crossfade_duration': 15, 'play_duration': 114, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17791537_Sweating on the Dancefloor_(Original Mix).mp3', 'mix_start': 109, 'crossfade_duration': 11, 'play_duration': 120, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17440571_Eat Sleep Rave Repeat_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222, 'bpm': 143.6, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17558154_Ride or Die_(Original Mix).mp3', 'mix_start': 189, 'crossfade_duration': 15, 'play_duration': 204, 'bpm': 143.6, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17906546_Black Magic_(Extended Mix).mp3', 'mix_start': 153, 'crossfade_duration': 6, 'play_duration': 159, 'bpm': 143.6, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17752861_Donkers_(Original Mix).mp3', 'mix_start': 136, 'crossfade_duration': 13, 'play_duration': 149, 'bpm': 161.5, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17576432_All The Things_(Original Mix).mp3', 'mix_start': 175, 'crossfade_duration': 13, 'play_duration': 188, 'bpm': 166.7, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17477194_Boom Boom Boom_(Extended Mix).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135, 'bpm': 161.5, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17446613_Hybrid Boom_(Original Mix).mp3', 'mix_start': 102, 'crossfade_duration': 5, 'play_duration': 107, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17757614_Fearless_(Phoenix Movement Remix).mp3', 'mix_start': 130, 'crossfade_duration': 12, 'play_duration': 142, 'bpm': 129.2, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17564479_KOKA_(Original Mix).mp3', 'mix_start': 183, 'crossfade_duration': 9, 'play_duration': 192, 'bpm': 123.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '18081983_T.O.K.Y.O._(Extended Mix).mp3', 'mix_start': 85, 'crossfade_duration': 7, 'play_duration': 92, 'bpm': 136.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17880959_Fuck This_(Original Mix).mp3', 'mix_start': 82, 'crossfade_duration': 11, 'play_duration': 93, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '18420294_Got That Booty_(Extended Mix).mp3', 'mix_start': 216, 'crossfade_duration': 10, 'play_duration': 226, 'bpm': 161.5, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '18222120_It_s That Time (Dimension Remix)_(Original Mix).mp3', 'mix_start': 117, 'crossfade_duration': 5, 'play_duration': 122, 'bpm': 172.3, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17723361_F_CK THE POLICE_(Original Mix).mp3', 'mix_start': 190, 'crossfade_duration': 15, 'play_duration': 205, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17399872_Ashika_(Original Mix).mp3', 'mix_start': 161, 'crossfade_duration': 15, 'play_duration': 176, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17951244_Everytime I_m In The Streets_(Original Mix).mp3', 'mix_start': 157, 'crossfade_duration': 7, 'play_duration': 164, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17923279_Fine Day Anthem_(Extended Mix).mp3', 'mix_start': 118, 'crossfade_duration': 7, 'play_duration': 125, 'bpm': 136.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17536420_1vs1 (Joann remix) feat. Joann_(Original Mix).mp3', 'mix_start': 201, 'crossfade_duration': 15, 'play_duration': 216, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17951242_The Ladies Gon Feel Me_(Original Mix).mp3', 'mix_start': 127, 'crossfade_duration': 11, 'play_duration': 138, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17997183_My Gasoline_(Extended Mix).mp3', 'mix_start': 0, 'crossfade_duration': 0, 'play_duration': 0, 'bpm': 0, 'volume_start': 0.0, 'volume_end': 0.0}
]

def animate_mix(song_data):
    fig, ax = plt.subplots(figsize=(15, 8))

    def init():
        ax.clear()
        ax.set_xlim(0, sum([song['play_duration'] for song in song_data]))
        ax.set_ylim(0, len(song_data))
        ax.set_xlabel('Tid (sekunder)')
        ax.set_yticks(range(len(song_data)))
        ax.set_yticklabels([f'Sang {i+1}' for i in range(len(song_data))])
        ax.set_title('Visualisering av Mikseprosessen')

    def update(frame):
        ax.clear()
        total_duration = 0
        for i, song in enumerate(song_data):
            mix_start = song['mix_start']
            crossfade_duration = song['crossfade_duration']
            play_duration = song['play_duration']
            song_name = song['song']
            bpm = song['bpm']
            volume_start = song['volume_start']
            volume_end = song['volume_end']

            # Plot sangen som en horisontal linje
            ax.plot([total_duration, total_duration + play_duration], [i, i], color='blue', linewidth=6, alpha=0.6)

            # Marker crossfade-segmentet på linjen
            ax.plot([total_duration + mix_start, total_duration + mix_start + crossfade_duration], [i, i], color='yellow', linewidth=6, alpha=0.8)

            # Tekst for sangdetaljer
            ax.text(total_duration + play_duration / 2, i, f'{song_name} | BPM: {bpm}', va='center', ha='right', fontsize=10, color='black', weight='bold')

            # Volumjustering
            ax.annotate(f'Vol: {volume_start} -> {volume_end}',
                        xy=(total_duration + mix_start + crossfade_duration / 2, i + 0.1),
                        xytext=(5, 0),
                        textcoords='offset points',
                        arrowprops=dict(arrowstyle='->', color='green'))

            total_duration += play_duration

        ax.set_xlim(0, sum([song['play_duration'] for song in song_data]))
        ax.set_ylim(0, len(song_data))
        ax.set_xlabel('Tid (sekunder)')
        ax.set_yticks(range(len(song_data)))
        ax.set_yticklabels([f'Sang {i+1}' for i in range(len(song_data))])
        ax.set_title('Visualisering av Mikseprosessen')

    anim = animation.FuncAnimation(fig, update, init_func=init, frames=range(len(song_data)), interval=1000, repeat=False)
    plt.show()

# Kjør animasjonen
animate_mix(song_data)

import matplotlib.pyplot as plt
import matplotlib.animation as animation

# Komplett data fra analysen inkludert BPM og volum for visualisering
song_data = [
    {'song': '17843367_Push Up (Club Version)_(Club Version).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135, 'bpm': 161.5, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17399871_Brembo_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17944376_Who Was In Paris__(Original Mix).mp3', 'mix_start': 108, 'crossfade_duration': 15, 'play_duration': 123, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17646318_Mini Skirt On_(Original Mix).mp3', 'mix_start': 89, 'crossfade_duration': 15, 'play_duration': 104, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17399873_RavPower_(Original Mix).mp3', 'mix_start': 93, 'crossfade_duration': 5, 'play_duration': 98, 'bpm': 151.5, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17588048_Believer_(Original Mix).mp3', 'mix_start': 76, 'crossfade_duration': 12, 'play_duration': 88, 'bpm': 129.2, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17985216_Spring Girl_(Extended).mp3', 'mix_start': 158, 'crossfade_duration': 15, 'play_duration': 173, 'bpm': 123.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17588819_Sitar_(Original Mix).mp3', 'mix_start': 117, 'crossfade_duration': 5, 'play_duration': 122, 'bpm': 123.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17420303_Anxiete_(Original Mix).mp3', 'mix_start': 167, 'crossfade_duration': 11, 'play_duration': 178, 'bpm': 143.6, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17863930_Music, Baby_(Original Mix).mp3', 'mix_start': 192, 'crossfade_duration': 15, 'play_duration': 207, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '16149902_Own Methods (Extented Mix)_(Original Mix).mp3', 'mix_start': 99, 'crossfade_duration': 15, 'play_duration': 114, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17791537_Sweating on the Dancefloor_(Original Mix).mp3', 'mix_start': 109, 'crossfade_duration': 11, 'play_duration': 120, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17440571_Eat Sleep Rave Repeat_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222, 'bpm': 143.6, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17558154_Ride or Die_(Original Mix).mp3', 'mix_start': 189, 'crossfade_duration': 15, 'play_duration': 204, 'bpm': 143.6, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17906546_Black Magic_(Extended Mix).mp3', 'mix_start': 153, 'crossfade_duration': 6, 'play_duration': 159, 'bpm': 143.6, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17752861_Donkers_(Original Mix).mp3', 'mix_start': 136, 'crossfade_duration': 13, 'play_duration': 149, 'bpm': 161.5, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17576432_All The Things_(Original Mix).mp3', 'mix_start': 175, 'crossfade_duration': 13, 'play_duration': 188, 'bpm': 166.7, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17477194_Boom Boom Boom_(Extended Mix).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135, 'bpm': 161.5, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17446613_Hybrid Boom_(Original Mix).mp3', 'mix_start': 102, 'crossfade_duration': 5, 'play_duration': 107, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17757614_Fearless_(Phoenix Movement Remix).mp3', 'mix_start': 130, 'crossfade_duration': 12, 'play_duration': 142, 'bpm': 129.2, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17564479_KOKA_(Original Mix).mp3', 'mix_start': 183, 'crossfade_duration': 9, 'play_duration': 192, 'bpm': 123.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '18081983_T.O.K.Y.O._(Extended Mix).mp3', 'mix_start': 85, 'crossfade_duration': 7, 'play_duration': 92, 'bpm': 136.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17880959_Fuck This_(Original Mix).mp3', 'mix_start': 82, 'crossfade_duration': 11, 'play_duration': 93, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '18420294_Got That Booty_(Extended Mix).mp3', 'mix_start': 216, 'crossfade_duration': 10, 'play_duration': 226, 'bpm': 161.5, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '18222120_It_s That Time (Dimension Remix)_(Original Mix).mp3', 'mix_start': 117, 'crossfade_duration': 5, 'play_duration': 122, 'bpm': 172.3, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17723361_F_CK THE POLICE_(Original Mix).mp3', 'mix_start': 190, 'crossfade_duration': 15, 'play_duration': 205, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17399872_Ashika_(Original Mix).mp3', 'mix_start': 161, 'crossfade_duration': 15, 'play_duration': 176, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17951244_Everytime I_m In The Streets_(Original Mix).mp3', 'mix_start': 157, 'crossfade_duration': 7, 'play_duration': 164, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17923279_Fine Day Anthem_(Extended Mix).mp3', 'mix_start': 118, 'crossfade_duration': 7, 'play_duration': 125, 'bpm': 136.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17536420_1vs1 (Joann remix) feat. Joann_(Original Mix).mp3', 'mix_start': 201, 'crossfade_duration': 15, 'play_duration': 216, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17951242_The Ladies Gon Feel Me_(Original Mix).mp3', 'mix_start': 127, 'crossfade_duration': 11, 'play_duration': 138, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17997183_My Gasoline_(Extended Mix).mp3', 'mix_start': 0, 'crossfade_duration': 0, 'play_duration': 0, 'bpm': 0, 'volume_start': 0.0, 'volume_end': 0.0}
]

def animate_mix(song_data):
    fig, ax = plt.subplots(figsize=(15, 8))

    def init():
        ax.clear()
        ax.set_xlim(0, sum([song['play_duration'] for song in song_data]))
        ax.set_ylim(0, len(song_data))
        ax.set_xlabel('Tid (sekunder)')
        ax.set_yticks(range(len(song_data)))
        ax.set_yticklabels([f'Sang {i+1}' for i in range(len(song_data))])
        ax.set_title('Visualisering av Mikseprosessen')

    def update(frame):
        ax.clear()
        total_duration = 0
        for i, song in enumerate(song_data):
            mix_start = song['mix_start']
            crossfade_duration = song['crossfade_duration']
            play_duration = song['play_duration']
            song_name = song['song']
            bpm = song['bpm']
            volume_start = song['volume_start']
            volume_end = song['volume_end']

            # Plot sangen som en horisontal linje
            ax.plot([total_duration, total_duration + play_duration], [i, i], color='blue', linewidth=6, alpha=0.6)

            # Marker crossfade-segmentet på linjen
            ax.plot([total_duration + mix_start, total_duration + mix_start + crossfade_duration], [i, i], color='yellow', linewidth=6, alpha=0.8)

            # Tekst for sangdetaljer
            ax.text(total_duration + play_duration / 2, i, f'{song_name} | BPM: {bpm}', va='center', ha='right', fontsize=10, color='black', weight='bold')

            # Volumjustering
            ax.annotate(f'Vol: {volume_start} -> {volume_end}',
                        xy=(total_duration + mix_start + crossfade_duration / 2, i + 0.1),
                        xytext=(5, 0),
                        textcoords='offset points',
                        arrowprops=dict(arrowstyle='->', color='green'))

            total_duration += play_duration

        ax.set_xlim(0, sum([song['play_duration'] for song in song_data]))
        ax.set_ylim(0, len(song_data))
        ax.set_xlabel('Tid (sekunder)')
        ax.set_yticks(range(len(song_data)))
        ax.set_yticklabels([f'Sang {i+1}' for i in range(len(song_data))])
        ax.set_title('Visualisering av Mikseprosessen')

    anim = animation.FuncAnimation(fig, update, init_func=init, frames=range(len(song_data)), interval=1000, repeat=False)
    plt.show()

# Kjør animasjonen
anim = animate_mix(song_data)

import matplotlib.pyplot as plt
from matplotlib import animation

# Data fra analysen inkludert BPM og volum for visualisering
song_data = [
    {'song': '17843367_Push Up (Club Version)_(Club Version).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135, 'bpm': 161.5, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17399871_Brembo_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17944376_Who Was In Paris__(Original Mix).mp3', 'mix_start': 108, 'crossfade_duration': 15, 'play_duration': 123, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    # Legg til flere sanger her...
]

def animate_mix(song_data):
    fig, ax = plt.subplots(figsize=(15, 8))

    def init():
        ax.clear()
        ax.set_xlim(0, sum([song['play_duration'] for song in song_data]) + 100)  # Juster x-aksen litt ekstra
        ax.set_ylim(0, len(song_data))
        ax.set_xlabel('Tid (sekunder)')
        ax.set_yticks(range(len(song_data)))
        ax.set_yticklabels([f'Sang {i+1}' for i in range(len(song_data))])
        ax.set_title('Visualisering av Mikseprosessen')
        return ax,

    def update(frame):
        ax.clear()
        total_duration = 0
        for i, song in enumerate(song_data):
            mix_start = song['mix_start']
            crossfade_duration = song['crossfade_duration']
            play_duration = song['play_duration']
            song_name = song['song']
            bpm = song['bpm']
            volume_start = song['volume_start']
            volume_end = song['volume_end']

            # Plot sangen som en horisontal linje
            ax.plot([total_duration, total_duration + play_duration], [i, i], color='blue', linewidth=6, alpha=0.6)

            # Marker crossfade-segmentet på linjen
            ax.plot([total_duration + mix_start, total_duration + mix_start + crossfade_duration], [i, i], color='yellow', linewidth=6, alpha=0.8)

            # Tekst for sangdetaljer
            ax.text(total_duration + play_duration / 2, i, f'{song_name} | BPM: {bpm}', va='center', ha='right', fontsize=10, color='black', weight='bold')

            # Volumjustering
            ax.annotate(f'Vol: {volume_start} -> {volume_end}',
                        xy=(total_duration + mix_start + crossfade_duration / 2, i + 0.1),
                        xytext=(5, 0),
                        textcoords='offset points',
                        arrowprops=dict(arrowstyle='->', color='green'))

            total_duration += play_duration

        ax.set_xlim(0, sum([song['play_duration'] for song in song_data]) + 100)  # Juster x-aksen litt ekstra
        ax.set_ylim(0, len(song_data))
        ax.set_xlabel('Tid (sekunder)')
        ax.set_yticks(range(len(song_data)))
        ax.set_yticklabels([f'Sang {i+1}' for i in range(len(song_data))])
        ax.set_title('Visualisering av Mikseprosessen')
        return ax,

    anim = animation.FuncAnimation(fig, update, init_func=init, frames=len(song_data), interval=1000, blit=False)
    plt.show()

# Kjør animasjonen
animate_mix(song_data)

import matplotlib.pyplot as plt
import matplotlib.animation as animation

# Data fra analysen inkludert BPM og volum for visualisering
song_data = [
    {'song': '17843367_Push Up (Club Version)_(Club Version).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135, 'bpm': 161.5, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17399871_Brembo_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17944376_Who Was In Paris__(Original Mix).mp3', 'mix_start': 108, 'crossfade_duration': 15, 'play_duration': 123, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17646318_Mini Skirt On_(Original Mix).mp3', 'mix_start': 89, 'crossfade_duration': 15, 'play_duration': 104, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17399873_RavPower_(Original Mix).mp3', 'mix_start': 93, 'crossfade_duration': 5, 'play_duration': 98, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17588048_Believer_(Original Mix).mp3', 'mix_start': 76, 'crossfade_duration': 12, 'play_duration': 88, 'bpm': 129.2, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17985216_Spring Girl_(Extended).mp3', 'mix_start': 158, 'crossfade_duration': 15, 'play_duration': 173, 'bpm': 123.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17588819_Sitar_(Original Mix).mp3', 'mix_start': 117, 'crossfade_duration': 5, 'play_duration': 122, 'bpm': 123.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17420303_Anxiete_(Original Mix).mp3', 'mix_start': 167, 'crossfade_duration': 11, 'play_duration': 178, 'bpm': 143.6, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17863930_Music, Baby_(Original Mix).mp3', 'mix_start': 192, 'crossfade_duration': 15, 'play_duration': 207, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '16149902_Own Methods (Extented Mix)_(Original Mix).mp3', 'mix_start': 99, 'crossfade_duration': 15, 'play_duration': 114, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17791537_Sweating on the Dancefloor_(Original Mix).mp3', 'mix_start': 109, 'crossfade_duration': 11, 'play_duration': 120, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17440571_Eat Sleep Rave Repeat_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222, 'bpm': 143.6, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17558154_Ride or Die_(Original Mix).mp3', 'mix_start': 189, 'crossfade_duration': 15, 'play_duration': 204, 'bpm': 143.6, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17906546_Black Magic_(Extended Mix).mp3', 'mix_start': 153, 'crossfade_duration': 6, 'play_duration': 159, 'bpm': 143.6, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17752861_Donkers_(Original Mix).mp3', 'mix_start': 136, 'crossfade_duration': 13, 'play_duration': 149, 'bpm': 161.5, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17576432_All The Things_(Original Mix).mp3', 'mix_start': 175, 'crossfade_duration': 13, 'play_duration': 188, 'bpm': 166.7, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17477194_Boom Boom Boom_(Extended Mix).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135, 'bpm': 161.5, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17446613_Hybrid Boom_(Original Mix).mp3', 'mix_start': 102, 'crossfade_duration': 5, 'play_duration': 107, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17757614_Fearless_(Phoenix Movement Remix).mp3', 'mix_start': 130, 'crossfade_duration': 12, 'play_duration': 142, 'bpm': 129.2, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17564479_KOKA_(Original Mix).mp3', 'mix_start': 183, 'crossfade_duration': 9, 'play_duration': 192, 'bpm': 123.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '18081983_T.O.K.Y.O._(Extended Mix).mp3', 'mix_start': 85, 'crossfade_duration': 7, 'play_duration': 92, 'bpm': 136.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17880959_Fuck This_(Original Mix).mp3', 'mix_start': 82, 'crossfade_duration': 11, 'play_duration': 93, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '18420294_Got That Booty_(Extended Mix).mp3', 'mix_start': 216, 'crossfade_duration': 10, 'play_duration': 226, 'bpm': 161.5, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '18222120_It_s That Time (Dimension Remix)_(Original Mix).mp3', 'mix_start': 117, 'crossfade_duration': 5, 'play_duration': 122, 'bpm': 172.3, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17723361_F_CK THE POLICE_(Original Mix).mp3', 'mix_start': 190, 'crossfade_duration': 15, 'play_duration': 205, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17399872_Ashika_(Original Mix).mp3', 'mix_start': 161, 'crossfade_duration': 15, 'play_duration': 176, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17951244_Everytime I_m In The Streets_(Original Mix).mp3', 'mix_start': 157, 'crossfade_duration': 7, 'play_duration': 164, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17923279_Fine Day Anthem_(Extended Mix).mp3', 'mix_start': 118, 'crossfade_duration': 7, 'play_duration': 125, 'bpm': 136.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17536420_1vs1 (Joann remix) feat. Joann_(Original Mix).mp3', 'mix_start': 201, 'crossfade_duration': 15, 'play_duration': 216, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17951242_The Ladies Gon Feel Me_(Original Mix).mp3', 'mix_start': 127, 'crossfade_duration': 11, 'play_duration': 138, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17997183_My Gasoline_(Extended Mix).mp3', 'mix_start': 0, 'crossfade_duration': 0, 'play_duration': 0, 'bpm': 0.0, 'volume_start': 0.0, 'volume_end': 0.0}  # siste sang, ingen miksepunkt
]

# Funksjon for å animere mikseprosessen
def animate_mix(song_data):
    fig, ax = plt.subplots(figsize=(15, 8))

    total_duration = 0

    def update(frame):
        ax.clear()  # Clear previous frame

        song = song_data[frame]
        mix_start = song['mix_start']
        crossfade_duration = song['crossfade_duration']
        play_duration = song['play_duration']
        song_name = song['song']
        bpm = song['bpm']
        volume_start = song['volume_start']
        volume_end = song['volume_end']

        # Plot sangen som en horisontal linje
        ax.plot([total_duration, total_duration + play_duration], [frame, frame], color='blue', linewidth=6, alpha=0.6)

        # Marker crossfade-segmentet på linjen
        ax.plot([total_duration + mix_start, total_duration + mix_start + crossfade_duration], [frame, frame], color='yellow', linewidth=6, alpha=0.8)

        # Tekst for sangdetaljer
        ax.text(total_duration + play_duration / 2, frame, f'{song_name} | BPM: {bpm}', va='center', ha='right', fontsize=10, color='black', weight='bold')

        # Volumjustering
        ax.annotate(f'Vol: {volume_start} -> {volume_end}',
                    xy=(total_duration + mix_start + crossfade_duration / 2, frame + 0.1),
                    xytext=(5, 0),
                    textcoords='offset points',
                    arrowprops=dict(arrowstyle='->', color='green'))

        # Oppdatere aksene
        ax.set_xlabel('Tid (sekunder)')
        ax.set_yticks(range(len(song_data)))
        ax.set_yticklabels([f'Sang {i+1}' for i in range(len(song_data))])
        ax.set_title('Visualisering av Mikseprosessen')

    anim = animation.FuncAnimation(fig, update, frames=len(song_data), interval=1000, blit=False)
    plt.show()

# Kjør animasjonen
animate_mix(song_data)

import matplotlib.pyplot as plt
import matplotlib.animation as animation

# Data fra analysen inkludert BPM og volum for visualisering
song_data = [
    {'song': '17843367_Push Up (Club Version)_(Club Version).mp3', 'mix_start': 124, 'crossfade_duration': 11, 'play_duration': 135, 'bpm': 161.5, 'volume_start': 1.0, 'volume_end': 0.0},
    {'song': '17399871_Brembo_(Original Mix).mp3', 'mix_start': 207, 'crossfade_duration': 15, 'play_duration': 222, 'bpm': 152.0, 'volume_start': 0.0, 'volume_end': 1.0},
    {'song': '17944376_Who Was In Paris__(Original Mix).mp3', 'mix_start': 108, 'crossfade_duration': 15, 'play_duration': 123, 'bpm': 152.0, 'volume_start': 1.0, 'volume_end': 0.0},
    # Inkluder flere sanger her...
]

# Funksjon for å animere mikseprosessen
def animate_mix(song_data):
    fig, ax = plt.subplots(figsize=(15, 8))

    total_duration = 0

    def update(frame):
        ax.clear()  # Clear previous frame
        song = song_data[frame]
        mix_start = song['mix_start']
        crossfade_duration = song['crossfade_duration']
        play_duration = song['play_duration']
        song_name = song['song']
        bpm = song['bpm']
        volume_start = song['volume_start']
        volume_end = song['volume_end']

        # Debug print
        print(f"Animating song: {song_name} at frame {frame}")

        # Plot sangen som en horisontal linje
        ax.plot([total_duration, total_duration + play_duration], [frame, frame], color='blue', linewidth=6, alpha=0.6)

        # Marker crossfade-segmentet på linjen
        ax.plot([total_duration + mix_start, total_duration + mix_start + crossfade_duration], [frame, frame], color='yellow', linewidth=6, alpha=0.8)

        # Tekst for sangdetaljer
        ax.text(total_duration + play_duration / 2, frame, f'{song_name} | BPM: {bpm}', va='center', ha='right', fontsize=10, color='black', weight='bold')

        # Volumjustering
        ax.annotate(f'Vol: {volume_start} -> {volume_end}',
                    xy=(total_duration + mix_start + crossfade_duration / 2, frame + 0.1),
                    xytext=(5, 0),
                    textcoords='offset points',
                    arrowprops=dict(arrowstyle='->', color='green'))

        # Oppdatere aksene
        ax.set_xlabel('Tid (sekunder)')
        ax.set_yticks(range(len(song_data)))
        ax.set_yticklabels([f'Sang {i+1}' for i in range(len(song_data))])
        ax.set_title('Visualisering av Mikseprosessen')

    # Lagre animasjonen i en variabel
    anim = animation.FuncAnimation(fig, update, frames=len(song_data), interval=1000, blit=False)
    plt.show()

# Kjør animasjonen
animate_mix(song_data)

!pip install essentia

import essentia
import essentia.standard as es

# Funksjon for å analysere en sang og returnere resultater
def analyze_song(audio_file_path):
    # Last inn lyden
    loader = es.MonoLoader(filename=audio_file_path)
    audio = loader()

    # Ekstraher BPM
    rhythm_extractor = es.RhythmExtractor2013()
    bpm, _, _, _, _ = rhythm_extractor(audio)

    # Ekstraher Toneart og Camelot Key
    key_extractor = es.KeyExtractor()
    key, scale, strength = key_extractor(audio)

    # Ekstraher energiprofil
    energy = es.Energy()
    song_energy = energy(audio)

    # Analyser spektrum for å finne bass, mellomtone, og diskant nivåer
    spectrum = es.Spectrum()
    spectral_centroid = es.SpectralCentroidTime()
    spectral_bands = es.SpectralBands()
    spec = spectrum(audio)
    centroid = spectral_centroid(spec)
    bands = spectral_bands(spec)

    # Returner analysen
    return {
        'BPM': bpm,
        'Toneart': key + ' ' + scale,
        'Energi': song_energy,
        'Spektral Sentroid': centroid,
        'Bass': bands[0],
        'Mellomtone': bands[1],
        'Diskant': bands[2]
    }

# Liste over sanger som skal analyseres
audio_file_paths = [
    '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3',
    '/content/drive/My Drive/SuperDJ_Project/music_library/18222120_It_s That Time (Dimension Remix)_(Original Mix).mp3',
    '/content/drive/My Drive/SuperDJ_Project/music_library/16149902_Own Methods (Extented Mix)_(Original Mix).mp3',
    '/content/drive/My Drive/SuperDJ_Project/music_library/17985216_Spring Girl_(Extended).mp3',
    '/content/drive/My Drive/SuperDJ_Project/music_library/17588048_Believer_(Original Mix).mp3'
]

# Kjør analysen på alle sanger
for audio_file_path in audio_file_paths:
    try:
        analysis_result = analyze_song(audio_file_path)
        print(f"Analyseresultat for {audio_file_path}:")
        print(analysis_result)
        print("\n" + "-"*40 + "\n")
    except Exception as e:
        print(f"Feil ved analyse av {audio_file_path}: {e}")

# Installer og importer nødvendige moduler
!pip install essentia
import essentia
from essentia.standard import MonoLoader, Spectrum, Windowing, FFT
import matplotlib.pyplot as plt

# Filsti til musikkfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Laster inn musikkfilen
try:
    loader = MonoLoader(filename=audio_file_path)
    audio = loader()
    print("Musikkfil lastet inn vellykket.")
except Exception as e:
    print(f"Feil ved lasting av musikkfilen: {e}")
    audio = None

# Hvis filen ble lastet inn vellykket, fortsett med analysen
if audio is not None:
    # Initialiserer algoritmer
    windowing = Windowing(type='hann')
    spectrum = Spectrum()
    fft = FFT()  # Outputter et komplekst FFT vektor

    # Henter et vindu fra lyden og utfører FFT
    frame = windowing(audio[:1024])  # Vi tar en frame av 1024 samples
    spec = spectrum(fft(frame))

    # Plotter spekteret
    plt.figure(figsize=(10, 6))
    plt.plot(spec)
    plt.title('Spektralanalyse av musikkfilen')
    plt.xlabel('Frekvens')
    plt.ylabel('Amplitud')
    plt.show()

    # Print grunnleggende informasjon
    print(f"Spektralanalyse fullført for {audio_file_path}")

# Installer og importer nødvendige moduler
!pip install essentia
import essentia
from essentia.standard import MonoLoader, Windowing, FFT, CartesianToPolar
import matplotlib.pyplot as plt

# Filsti til musikkfilen du vil analysere
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'

# Laster inn musikkfilen
try:
    loader = MonoLoader(filename=audio_file_path)
    audio = loader()
    print("Musikkfil lastet inn vellykket.")
except Exception as e:
    print(f"Feil ved lasting av musikkfilen: {e}")
    audio = None

# Hvis filen ble lastet inn vellykket, fortsett med analysen
if audio is not None:
    # Initialiserer algoritmer
    windowing = Windowing(type='hann')
    fft = FFT()  # Outputter et komplekst FFT vektor
    c2p = CartesianToPolar()  # Konverterer FFT resultatet til amplitude og fase

    # Henter et vindu fra lyden og utfører FFT
    frame = windowing(audio[:1024])  # Vi tar en frame av 1024 samples
    fft_result = fft(frame)
    magnitude, phase = c2p(fft_result)  # Henter magnitude (amplitude) fra FFT

    # Plotter spekteret
    plt.figure(figsize=(10, 6))
    plt.plot(magnitude)
    plt.title('Spektralanalyse av musikkfilen')
    plt.xlabel('Frekvens')
    plt.ylabel('Amplitud')
    plt.show()

    # Print grunnleggende informasjon
    print(f"Spektralanalyse fullført for {audio_file_path}")

import essentia
import essentia.standard as es

def analyze_song_with_essentia(audio_file_path):
    # Laste inn musikkfilen
    loader = es.MonoLoader(filename=audio_file_path)
    audio = loader()

    # Utføre harmonisk analyse
    key_extractor = es.KeyExtractor()
    key, scale, strength = key_extractor(audio)
    camelot_key = convert_to_camelot_key(key, scale)  # Funksjon for å konvertere til Camelot Key

    # BPM-deteksjon
    rhythm_extractor = es.RhythmExtractor2013()
    bpm, _, _, _, _ = rhythm_extractor(audio)

    # Resultat
    result = {
        'file': audio_file_path,
        'key': key,
        'scale': scale,
        'camelot_key': camelot_key,
        'bpm': bpm
    }

    return result

def convert_to_camelot_key(key, scale):
    camelot_wheel = {
        'C': '8B', 'C#': '3B', 'D': '10B', 'D#': '5B', 'E': '12B', 'F': '7B',
        'F#': '2B', 'G': '9B', 'G#': '4B', 'A': '11B', 'A#': '6B', 'B': '1B'
    }

    if scale == 'minor':
        camelot_wheel = {k: v.replace('B', 'A') for k, v in camelot_wheel.items()}

    return camelot_wheel.get(key, 'Unknown')

# Teste funksjonen på en fil
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
result = analyze_song_with_essentia(audio_file_path)
print(result)

import essentia
import essentia.standard as es
import numpy as np

def identify_sections(audio_file_path):
    # Last inn musikkfilen
    loader = es.MonoLoader(filename=audio_file_path)
    audio = loader()

    # Utfør onset detection
    w = es.Windowing(type='hann')
    fft = es.FFT()
    c2p = es.CartesianToPolar()
    od = es.OnsetDetection(method='hfc')

    onsets = es.Onsets()
    onset_times = []

    # Beregn onset detection funksjon
    pool = essentia.Pool()
    for frame in es.FrameGenerator(audio, frameSize=1024, hopSize=512):
        mag, phase = c2p(fft(w(frame)))
        pool.add('onset.hfc', od(mag, phase))

    # Finn onset-tider
    onset_times = onsets(essentia.array([pool['onset.hfc']]), [1])

    # Beregn energiprofil
    frame_size = 2048
    hop_size = 512
    rmse = es.RMS()
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        energy_profile.append(rmse(frame))

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Identifiser seksjoner basert på energiprofil og onsets
    sections = []
    section_start_time = 0
    for i, onset in enumerate(onset_times):
        if i == 0:
            continue
        section_end_time = onset
        avg_energy = np.mean(energy_profile[int(section_start_time * sr / hop_size):int(section_end_time * sr / hop_size)])

        if avg_energy < 0.2:
            section_label = 'Intro/Outro'
        elif avg_energy < 0.5:
            section_label = 'Verse'
        elif avg_energy < 0.8:
            section_label = 'Build-up'
        else:
            section_label = 'Drop'

        sections.append({
            'start': section_start_time,
            'end': section_end_time,
            'label': section_label
        })

        section_start_time = section_end_time

    # Siste seksjon til slutten av sangen
    sections.append({
        'start': section_start_time,
        'end': len(audio) / sr,
        'label': 'Outro'
    })

    return sections

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
sections = identify_sections(audio_file_path)
print(sections)

import essentia
import essentia.standard as es
import numpy as np

def identify_sections(audio_file_path):
    # Last inn musikkfilen
    loader = es.MonoLoader(filename=audio_file_path)
    audio = loader()
    sr = loader.paramValue('sampleRate')  # Hent ut samplingsraten

    # Utfør onset detection
    w = es.Windowing(type='hann')
    fft = es.FFT()
    c2p = es.CartesianToPolar()
    od = es.OnsetDetection(method='hfc')

    onsets = es.Onsets()
    onset_times = []

    # Beregn onset detection funksjon
    pool = essentia.Pool()
    for frame in es.FrameGenerator(audio, frameSize=1024, hopSize=512):
        mag, phase = c2p(fft(w(frame)))
        pool.add('onset.hfc', od(mag, phase))

    # Finn onset-tider
    onset_times = onsets(essentia.array([pool['onset.hfc']]), [1])

    # Beregn energiprofil
    frame_size = 2048
    hop_size = 512
    rmse = es.RMS()
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        energy_profile.append(rmse(frame))

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Identifiser seksjoner basert på energiprofil og onsets
    sections = []
    section_start_time = 0
    for i, onset in enumerate(onset_times):
        if i == 0:
            continue
        section_end_time = onset
        avg_energy = np.mean(energy_profile[int(section_start_time * sr / hop_size):int(section_end_time * sr / hop_size)])

        if avg_energy < 0.2:
            section_label = 'Intro/Outro'
        elif avg_energy < 0.5:
            section_label = 'Verse'
        elif avg_energy < 0.8:
            section_label = 'Build-up'
        else:
            section_label = 'Drop'

        sections.append({
            'start': section_start_time,
            'end': section_end_time,
            'label': section_label
        })

        section_start_time = section_end_time

    # Siste seksjon til slutten av sangen
    sections.append({
        'start': section_start_time,
        'end': len(audio) / sr,
        'label': 'Outro'
    })

    return sections

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
sections = identify_sections(audio_file_path)
print(sections)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def identify_sections_improved(audio_file_path):
    # Last inn musikkfilen
    loader = es.MonoLoader(filename=audio_file_path)
    audio = loader()
    sr = loader.paramValue('sampleRate')

    # Utfør onset detection med flere metoder
    od_complex = es.OnsetDetection(method='complex')
    od_hfc = es.OnsetDetection(method='hfc')
    w = es.Windowing(type='hann')
    fft = es.FFT()
    c2p = es.CartesianToPolar()

    onsets = es.Onsets()
    onset_times = []

    # Beregn onset detection funksjon
    pool = essentia.Pool()
    for frame in es.FrameGenerator(audio, frameSize=1024, hopSize=512):
        mag, phase = c2p(fft(w(frame)))
        pool.add('onset.hfc', od_hfc(mag, phase))
        pool.add('onset.complex', od_complex(mag, phase))

    # Kombiner flere onset deteksjoner
    onset_times = onsets(essentia.array([pool['onset.hfc'], pool['onset.complex']]), [1, 1])

    # Beregn energiprofil med flere metoder
    frame_size = 2048
    hop_size = 512
    rmse = es.RMS()
    spectral_flux = es.SpectralFlux()
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        rms_energy = rmse(frame)
        flux = spectral_flux(frame)
        energy_profile.append(rms_energy + flux)  # Kombinere RMS og SpectralFlux

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Identifiser seksjoner basert på energiprofil og onsets
    sections = []
    section_start_time = 0
    for i, onset in enumerate(onset_times):
        if i == 0:
            continue
        section_end_time = onset
        avg_energy = np.mean(energy_profile[int(section_start_time * sr / hop_size):int(section_end_time * sr / hop_size)])

        if avg_energy < 0.2:
            section_label = 'Intro/Outro'
        elif avg_energy < 0.5:
            section_label = 'Verse'
        elif avg_energy < 0.8:
            section_label = 'Build-up'
        else:
            section_label = 'Drop'

        sections.append({
            'start': section_start_time,
            'end': section_end_time,
            'label': section_label
        })

        section_start_time = section_end_time

    # Siste seksjon til slutten av sangen
    sections.append({
        'start': section_start_time,
        'end': len(audio) / sr,
        'label': 'Outro'
    })

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile)) * hop_size / sr, energy_profile)
    plt.xlabel('Time (s)')
    plt.ylabel('Normalized Energy Profile')
    plt.title('Energy Profile of the Track')
    plt.show()

    return sections

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
sections = identify_sections_improved(audio_file_path)
print(sections)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def identify_sections_improved(audio_file_path):
    # Last inn musikkfilen
    loader = es.MonoLoader(filename=audio_file_path)
    audio = loader()
    sr = loader.paramValue('sampleRate')

    # Utfør onset detection med flere metoder
    od_complex = es.OnsetDetection(method='complex')
    od_hfc = es.OnsetDetection(method='hfc')
    w = es.Windowing(type='hann')
    fft = es.FFT()
    c2p = es.CartesianToPolar()

    onsets = es.Onsets()
    onset_times = []

    # Beregn onset detection funksjon
    pool = essentia.Pool()
    for frame in es.FrameGenerator(audio, frameSize=1024, hopSize=512):
        mag, phase = c2p(fft(w(frame)))
        pool.add('onset.hfc', od_hfc(mag, phase))
        pool.add('onset.complex', od_complex(mag, phase))

    # Kombiner flere onset deteksjoner
    onset_times = onsets(essentia.array([pool['onset.hfc'], pool['onset.complex']]), [1, 1])

    # Beregn energiprofil med flere metoder
    frame_size = 2048
    hop_size = 512
    rmse = es.RMS()
    flux = es.Flux()  # Bruk Flux i stedet for SpectralFlux
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        rms_energy = rmse(frame)
        frame_flux = flux(frame)
        energy_profile.append(rms_energy + frame_flux)  # Kombinere RMS og Flux

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Identifiser seksjoner basert på energiprofil og onsets
    sections = []
    section_start_time = 0
    for i, onset in enumerate(onset_times):
        if i == 0:
            continue
        section_end_time = onset
        avg_energy = np.mean(energy_profile[int(section_start_time * sr / hop_size):int(section_end_time * sr / hop_size)])

        if avg_energy < 0.2:
            section_label = 'Intro/Outro'
        elif avg_energy < 0.5:
            section_label = 'Verse'
        elif avg_energy < 0.8:
            section_label = 'Build-up'
        else:
            section_label = 'Drop'

        sections.append({
            'start': section_start_time,
            'end': section_end_time,
            'label': section_label
        })

        section_start_time = section_end_time

    # Siste seksjon til slutten av sangen
    sections.append({
        'start': section_start_time,
        'end': len(audio) / sr,
        'label': 'Outro'
    })

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile)) * hop_size / sr, energy_profile)
    plt.xlabel('Time (s)')
    plt.ylabel('Normalized Energy Profile')
    plt.title('Energy Profile of the Track')
    plt.show()

    return sections

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
sections = identify_sections_improved(audio_file_path)
print(sections)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def identify_sections_improved_granularity(audio_file_path):
    # Last inn musikkfilen
    loader = es.MonoLoader(filename=audio_file_path)
    audio = loader()
    sr = loader.paramValue('sampleRate')

    # Utfør onset detection med flere metoder
    od_complex = es.OnsetDetection(method='complex')
    od_hfc = es.OnsetDetection(method='hfc')
    w = es.Windowing(type='hann')
    fft = es.FFT()
    c2p = es.CartesianToPolar()

    onsets = es.Onsets()
    onset_times = []

    # Beregn onset detection funksjon
    pool = essentia.Pool()
    for frame in es.FrameGenerator(audio, frameSize=1024, hopSize=512):
        mag, phase = c2p(fft(w(frame)))
        pool.add('onset.hfc', od_hfc(mag, phase))
        pool.add('onset.complex', od_complex(mag, phase))

    # Kombiner flere onset deteksjoner
    onset_times = onsets(essentia.array([pool['onset.hfc'], pool['onset.complex']]), [1, 1])

    # Beregn energiprofil med flere metoder
    frame_size = 2048
    hop_size = 512
    rmse = es.RMS()
    flux = es.Flux()  # Bruk Flux i stedet for SpectralFlux
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        rms_energy = rmse(frame)
        frame_flux = flux(frame)
        energy_profile.append(rms_energy + frame_flux)  # Kombinere RMS og Flux

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Smoothing av energiprofilen
    smooth_window = 5  # Juster dette tallet for å kontrollere hvor mye glatthet du vil ha
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window)/smooth_window, mode='same')

    # Identifiser seksjoner basert på den glatte energiprofilen og onsets
    sections = []
    section_start_time = 0
    for i, onset in enumerate(onset_times):
        if i == 0:
            continue
        section_end_time = onset
        avg_energy = np.mean(energy_profile_smoothed[int(section_start_time * sr / hop_size):int(section_end_time * sr / hop_size)])

        # Justere energinivå terskler
        if avg_energy < 0.3:  # Økt terskel fra 0.2 til 0.3
            section_label = 'Intro/Outro'
        elif avg_energy < 0.6:  # Økt terskel fra 0.5 til 0.6
            section_label = 'Verse'
        elif avg_energy < 0.85:  # Økt terskel fra 0.8 til 0.85
            section_label = 'Build-up'
        else:
            section_label = 'Drop'

        sections.append({
            'start': section_start_time,
            'end': section_end_time,
            'label': section_label
        })

        section_start_time = section_end_time

    # Siste seksjon til slutten av sangen
    sections.append({
        'start': section_start_time,
        'end': len(audio) / sr,
        'label': 'Outro'
    })

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile_smoothed)) * hop_size / sr, energy_profile_smoothed)
    plt.xlabel('Time (s)')
    plt.ylabel('Smoothed Normalized Energy Profile')
    plt.title('Smoothed Energy Profile of the Track')
    plt.show()

    return sections

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
sections = identify_sections_improved_granularity(audio_file_path)
print(sections)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def identify_sections_with_chorus(audio_file_path):
    # Last inn musikkfilen
    loader = es.MonoLoader(filename=audio_file_path)
    audio = loader()
    sr = loader.paramValue('sampleRate')

    # Utfør onset detection med flere metoder
    od_complex = es.OnsetDetection(method='complex')
    od_hfc = es.OnsetDetection(method='hfc')
    w = es.Windowing(type='hann')
    fft = es.FFT()
    c2p = es.CartesianToPolar()

    onsets = es.Onsets()
    onset_times = []

    # Beregn onset detection funksjon
    pool = essentia.Pool()
    for frame in es.FrameGenerator(audio, frameSize=1024, hopSize=512):
        mag, phase = c2p(fft(w(frame)))
        pool.add('onset.hfc', od_hfc(mag, phase))
        pool.add('onset.complex', od_complex(mag, phase))

    # Kombiner flere onset deteksjoner
    onset_times = onsets(essentia.array([pool['onset.hfc'], pool['onset.complex']]), [1, 1])

    # Beregn energiprofil med flere metoder
    frame_size = 2048
    hop_size = 512
    rmse = es.RMS()
    flux = es.Flux()  # Bruk Flux i stedet for SpectralFlux
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        rms_energy = rmse(frame)
        frame_flux = flux(frame)
        energy_profile.append(rms_energy + frame_flux)  # Kombinere RMS og Flux

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Smoothing av energiprofilen
    smooth_window = 5  # Juster dette tallet for å kontrollere hvor mye glatthet du vil ha
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window)/smooth_window, mode='same')

    # Identifiser seksjoner basert på den glatte energiprofilen og onsets
    sections = []
    section_start_time = 0
    for i, onset in enumerate(onset_times):
        if i == 0:
            continue
        section_end_time = onset
        avg_energy = np.mean(energy_profile_smoothed[int(section_start_time * sr / hop_size):int(section_end_time * sr / hop_size)])

        # Ny grense for chorus og justering av andre seksjoner
        if avg_energy < 0.3:
            section_label = 'Intro/Outro'
        elif avg_energy < 0.5:
            section_label = 'Verse'
        elif avg_energy < 0.7:  # Identifiserer "Chorus"
            section_label = 'Chorus'
        elif avg_energy < 0.85:
            section_label = 'Build-up'
        else:
            section_label = 'Drop'

        sections.append({
            'start': section_start_time,
            'end': section_end_time,
            'label': section_label
        })

        section_start_time = section_end_time

    # Siste seksjon til slutten av sangen
    sections.append({
        'start': section_start_time,
        'end': len(audio) / sr,
        'label': 'Outro'
    })

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile_smoothed)) * hop_size / sr, energy_profile_smoothed)
    plt.xlabel('Time (s)')
    plt.ylabel('Smoothed Normalized Energy Profile')
    plt.title('Smoothed Energy Profile of the Track')
    plt.show()

    return sections

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
sections = identify_sections_with_chorus(audio_file_path)
print(sections)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def identify_sections_with_chorus_reduced(audio_file_path):
    # Last inn musikkfilen
    loader = es.MonoLoader(filename=audio_file_path)
    audio = loader()
    sr = loader.paramValue('sampleRate')

    # Utfør onset detection med flere metoder
    od_complex = es.OnsetDetection(method='complex')
    od_hfc = es.OnsetDetection(method='hfc')
    w = es.Windowing(type='hann')
    fft = es.FFT()
    c2p = es.CartesianToPolar()

    onsets = es.Onsets()
    onset_times = []

    # Beregn onset detection funksjon
    pool = essentia.Pool()
    for frame in es.FrameGenerator(audio, frameSize=1024, hopSize=512):
        mag, phase = c2p(fft(w(frame)))
        pool.add('onset.hfc', od_hfc(mag, phase))
        pool.add('onset.complex', od_complex(mag, phase))

    # Kombiner flere onset deteksjoner
    onset_times = onsets(essentia.array([pool['onset.hfc'], pool['onset.complex']]), [1, 1])

    # Beregn energiprofil med flere metoder
    frame_size = 2048
    hop_size = 512
    rmse = es.RMS()
    flux = es.Flux()
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        rms_energy = rmse(frame)
        frame_flux = flux(frame)
        energy_profile.append(rms_energy + frame_flux)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Smoothing av energiprofilen
    smooth_window = 20  # Øk glattingen for å redusere antall seksjoner
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window)/smooth_window, mode='same')

    # Identifiser seksjoner basert på den glatte energiprofilen og onsets
    sections = []
    section_start_time = 0
    for i, onset in enumerate(onset_times):
        if i == 0:
            continue
        section_end_time = onset
        avg_energy = np.mean(energy_profile_smoothed[int(section_start_time * sr / hop_size):int(section_end_time * sr / hop_size)])

        # Justere energinivå terskler og bruke færre kategorier
        if avg_energy < 0.2:
            section_label = 'Intro/Outro'
        elif avg_energy < 0.5:
            section_label = 'Verse'
        elif avg_energy < 0.7:  # Identifiserer "Chorus"
            section_label = 'Chorus'
        else:
            section_label = 'Drop'

        # Unngå å legge til små, like etterfølgende seksjoner
        if sections and sections[-1]['label'] == section_label:
            sections[-1]['end'] = section_end_time
        else:
            sections.append({
                'start': section_start_time,
                'end': section_end_time,
                'label': section_label
            })

        section_start_time = section_end_time

    # Siste seksjon til slutten av sangen
    if sections and sections[-1]['label'] == 'Outro':
        sections[-1]['end'] = len(audio) / sr
    else:
        sections.append({
            'start': section_start_time,
            'end': len(audio) / sr,
            'label': 'Outro'
        })

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile_smoothed)) * hop_size / sr, energy_profile_smoothed)
    plt.xlabel('Time (s)')
    plt.ylabel('Smoothed Normalized Energy Profile')
    plt.title('Smoothed Energy Profile of the Track')
    plt.show()

    return sections

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
sections = identify_sections_with_chorus_reduced(audio_file_path)

# Skrive ut en strukturert og kort oversikt over seksjonene
for section in sections:
    print(f"Start: {section['start']:.2f} s, End: {section['end']:.2f} s, Label: {section['label']}")

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def improved_energy_profile_analysis(audio_file_path):
    # Last inn musikkfilen
    loader = es.MonoLoader(filename=audio_file_path)
    audio = loader()
    sr = loader.paramValue('sampleRate')

    # Forhåndsdefinerte Essentia-algoritmer
    w = es.Windowing(type='hann')
    fft = es.FFT()
    rmse = es.RMS()
    flux = es.Flux()
    spectral_centroid = es.Centroid(range=(0, sr/2))
    zerocrossingrate = es.ZeroCrossingRate()
    spectral_contrast = es.SpectralContrast()

    # Beregn energiprofil med flere funksjoner
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)

        # Flux
        frame_flux = flux(frame)

        # FFT for spektrale funksjoner
        mag_spectrum = np.abs(fft(w(frame)))

        # Spectral Centroid
        centroid_value = spectral_centroid(mag_spectrum)

        # Zero Crossing Rate
        zero_crossings = zerocrossingrate(frame)

        # Spectral Contrast
        contrast_value = spectral_contrast(mag_spectrum)[0]  # Tar gjennomsnittlig kontrast

        # Kombinerer alle funksjonene
        combined_energy = rms_energy + frame_flux + centroid_value + zero_crossings + contrast_value
        energy_profile.append(combined_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Smoothing av energiprofilen
    smooth_window = 20
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window)/smooth_window, mode='same')

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile_smoothed)) * hop_size / sr, energy_profile_smoothed)
    plt.xlabel('Time (s)')
    plt.ylabel('Smoothed Normalized Energy Profile')
    plt.title('Improved Energy Profile of the Track')
    plt.show()

    return energy_profile_smoothed

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = improved_energy_profile_analysis(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def improved_energy_profile_analysis(audio_file_path):
    # Last inn musikkfilen og konverter til mono
    loader = es.MonoLoader(filename=audio_file_path)
    audio = loader()
    sr = loader.paramValue('sampleRate')

    # Forhåndsdefinerte Essentia-algoritmer
    w = es.Windowing(type='hann')
    fft = es.FFT()
    rmse = es.RMS()
    flux = es.Flux()
    spectral_centroid = es.Centroid(range=(0, sr/2))
    zerocrossingrate = es.ZeroCrossingRate()
    spectral_contrast = es.SpectralContrast()

    # Beregn energiprofil med flere funksjoner
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)

        # Flux
        frame_flux = flux(frame)

        # FFT for spektrale funksjoner
        mag_spectrum = np.abs(fft(w(frame)))

        # Spectral Centroid
        centroid_value = spectral_centroid(mag_spectrum)

        # Zero Crossing Rate
        zero_crossings = zerocrossingrate(frame)

        # Spectral Contrast
        contrast_value = spectral_contrast(mag_spectrum)[0]  # Tar gjennomsnittlig kontrast

        # Kombinerer alle funksjonene
        combined_energy = rms_energy + frame_flux + centroid_value + zero_crossings + contrast_value
        energy_profile.append(combined_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Smoothing av energiprofilen
    smooth_window = 20
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window)/smooth_window, mode='same')

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile_smoothed)) * hop_size / sr, energy_profile_smoothed)
    plt.xlabel('Time (s)')
    plt.ylabel('Smoothed Normalized Energy Profile')
    plt.title('Improved Energy Profile of the Track')
    plt.show()

    return energy_profile_smoothed

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = improved_energy_profile_analysis(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def improved_energy_profile_analysis(audio_file_path):
    # Last inn musikkfilen
    loader = es.MonoLoader(filename=audio_file_path, sampleRate=44100)  # Laster inn i mono
    audio = loader()
    sr = loader.paramValue('sampleRate')

    # Hvis lyden er stereo, konverter til mono
    if len(audio.shape) > 1 and audio.shape[1] == 2:
        audio = np.mean(audio, axis=1)

    # Forhåndsdefinerte Essentia-algoritmer
    w = es.Windowing(type='hann')
    fft = es.FFT()
    rmse = es.RMS()
    flux = es.Flux()
    spectral_centroid = es.Centroid(range=(0, sr/2))
    zerocrossingrate = es.ZeroCrossingRate()
    spectral_contrast = es.SpectralContrast()

    # Beregn energiprofil med flere funksjoner
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)

        # Flux
        frame_flux = flux(frame)

        # FFT for spektrale funksjoner
        mag_spectrum = np.abs(fft(w(frame)))

        # Spectral Centroid
        centroid_value = spectral_centroid(mag_spectrum)

        # Zero Crossing Rate
        zero_crossings = zerocrossingrate(frame)

        # Spectral Contrast
        contrast_value = spectral_contrast(mag_spectrum)[0]  # Tar gjennomsnittlig kontrast

        # Kombinerer alle funksjonene
        combined_energy = rms_energy + frame_flux + centroid_value + zero_crossings + contrast_value
        energy_profile.append(combined_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Smoothing av energiprofilen
    smooth_window = 20
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window)/smooth_window, mode='same')

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile_smoothed)) * hop_size / sr, energy_profile_smoothed)
    plt.xlabel('Time (s)')
    plt.ylabel('Smoothed Normalized Energy Profile')
    plt.title('Improved Energy Profile of the Track')
    plt.show()

    return energy_profile_smoothed

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = improved_energy_profile_analysis(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def improved_energy_profile_analysis(audio_file_path):
    # Last inn musikkfilen
    loader = es.MonoLoader(filename=audio_file_path)
    audio = loader()
    sr = loader.paramValue('sampleRate')

    # Hvis audio ikke er en en-dimensjonal array, konverter til mono
    if audio.ndim > 1:
        audio = np.mean(audio, axis=1)

    # Forhåndsdefinerte Essentia-algoritmer
    w = es.Windowing(type='hann')
    fft = es.FFT()
    rmse = es.RMS()
    flux = es.Flux()
    spectral_centroid = es.Centroid(range=(0, sr/2))
    zerocrossingrate = es.ZeroCrossingRate()
    spectral_contrast = es.SpectralContrast()

    # Beregn energiprofil med flere funksjoner
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)

        # Flux
        frame_flux = flux(frame)

        # FFT for spektrale funksjoner
        mag_spectrum = np.abs(fft(w(frame)))

        # Spectral Centroid
        centroid_value = spectral_centroid(mag_spectrum)

        # Zero Crossing Rate
        zero_crossings = zerocrossingrate(frame)

        # Spectral Contrast
        contrast_value = spectral_contrast(mag_spectrum)[0]  # Tar gjennomsnittlig kontrast

        # Kombinerer alle funksjonene
        combined_energy = rms_energy + frame_flux + centroid_value + zero_crossings + contrast_value
        energy_profile.append(combined_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Smoothing av energiprofilen
    smooth_window = 20
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window)/smooth_window, mode='same')

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile_smoothed)) * hop_size / sr, energy_profile_smoothed)
    plt.xlabel('Time (s)')
    plt.ylabel('Smoothed Normalized Energy Profile')
    plt.title('Improved Energy Profile of the Track')
    plt.show()

    return energy_profile_smoothed

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = improved_energy_profile_analysis(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def basic_energy_profile_analysis(audio_file_path):
    # Last inn musikkfilen med AudioLoader for å få kontroll over kanaler
    loader = es.AudioLoader(filename=audio_file_path, sampleRate=44100)
    audio, sr = loader()

    # Hvis lyden er stereo (2 kanaler), konverter til mono
    if len(audio.shape) > 1:
        audio = np.mean(audio, axis=1)

    # Forhåndsdefinerte Essentia-algoritmer
    rmse = es.RMS()

    # Beregn energiprofil kun med RMS
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Smoothing av energiprofilen
    smooth_window = 20
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window)/smooth_window, mode='same')

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile_smoothed)) * hop_size / sr, energy_profile_smoothed)
    plt.xlabel('Time (s)')
    plt.ylabel('Smoothed Normalized Energy Profile')
    plt.title('Basic Energy Profile of the Track')
    plt.show()

    return energy_profile_smoothed

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = basic_energy_profile_analysis(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def basic_rms_energy_profile(audio_file_path):
    # Last inn musikkfilen med AudioLoader for å få kontroll over kanaler
    loader = es.AudioLoader(filename=audio_file_path, sampleRate=44100)
    audio, sr = loader()

    # Hvis lyden er stereo (2 kanaler), konverter til mono
    if len(audio.shape) > 1:
        audio = np.mean(audio, axis=1)

    # Forhåndsdefinerte Essentia-algoritmer
    rmse = es.RMS()

    # Beregn energiprofil kun med RMS
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile)) * hop_size / sr, energy_profile)
    plt.xlabel('Time (s)')
    plt.ylabel('Normalized RMS Energy')
    plt.title('Basic RMS Energy Profile of the Track')
    plt.show()

    return energy_profile

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = basic_rms_energy_profile(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def basic_rms_energy_profile(audio_file_path):
    # Last inn musikkfilen med AudioLoader uten å spesifisere sampleRate
    loader = es.AudioLoader(filename=audio_file_path)
    audio, sr = loader()

    # Hvis lyden er stereo (2 kanaler), konverter til mono
    if len(audio.shape) > 1:
        audio = np.mean(audio, axis=1)

    # Forhåndsdefinerte Essentia-algoritmer
    rmse = es.RMS()

    # Beregn energiprofil kun med RMS
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile)) * hop_size / sr, energy_profile)
    plt.xlabel('Time (s)')
    plt.ylabel('Normalized RMS Energy')
    plt.title('Basic RMS Energy Profile of the Track')
    plt.show()

    return energy_profile

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = basic_rms_energy_profile(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def basic_rms_energy_profile(audio_file_path):
    # Last inn musikkfilen med AudioLoader
    loader = es.AudioLoader(filename=audio_file_path)
    audio = loader()  # Laster inn lydfilen
    sr = loader.paramValue('sampleRate')  # Henter samplingsfrekvensen

    # Hvis lyden er stereo (2 kanaler), konverter til mono
    if len(audio.shape) > 1:
        audio = np.mean(audio, axis=1)

    # Forhåndsdefinerte Essentia-algoritmer
    rmse = es.RMS()

    # Beregn energiprofil kun med RMS
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile)) * hop_size / sr, energy_profile)
    plt.xlabel('Time (s)')
    plt.ylabel('Normalized RMS Energy')
    plt.title('Basic RMS Energy Profile of the Track')
    plt.show()

    return energy_profile

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = basic_rms_energy_profile(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def basic_rms_energy_profile(audio_file_path):
    # Last inn musikkfilen med AudioLoader
    loader = es.AudioLoader(filename=audio_file_path)
    audio, sr, _ = loader()  # Laster inn lydfilen og henter samplingsfrekvensen

    # Hvis lyden er stereo (2 kanaler), konverter til mono
    if len(audio.shape) > 1:
        audio = np.mean(audio, axis=1)

    # Forhåndsdefinerte Essentia-algoritmer
    rmse = es.RMS()

    # Beregn energiprofil kun med RMS
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile)) * hop_size / sr, energy_profile)
    plt.xlabel('Time (s)')
    plt.ylabel('Normalized RMS Energy')
    plt.title('Basic RMS Energy Profile of the Track')
    plt.show()

    return energy_profile

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = basic_rms_energy_profile(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def basic_rms_energy_profile(audio_file_path):
    # Last inn musikkfilen med AudioLoader
    loader = es.AudioLoader(filename=audio_file_path)
    audio, sr, _ = loader()  # Laster inn lydfilen og henter samplingsfrekvensen

    # Hvis lyden er stereo (2 kanaler), konverter til mono
    if len(audio.shape) > 1:
        audio = np.mean(audio, axis=1)

    # Forhåndsdefinerte Essentia-algoritmer
    rmse = es.RMS()

    # Beregn energiprofil kun med RMS
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile)) * hop_size / sr, energy_profile)
    plt.xlabel('Time (s)')
    plt.ylabel('Normalized RMS Energy')
    plt.title('Basic RMS Energy Profile of the Track')
    plt.show()

    return energy_profile

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = basic_rms_energy_profile(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def basic_rms_energy_profile(audio_file_path):
    # Last inn musikkfilen med AudioLoader
    loader = es.AudioLoader(filename=audio_file_path)
    audio, sr = loader()  # Laster inn lydfilen og henter samplingsfrekvensen

    # Hvis lyden er stereo (2 kanaler), konverter til mono
    if audio.ndim > 1 and audio.shape[1] == 2:
        audio = np.mean(audio, axis=1)

    # Forhåndsdefinerte Essentia-algoritmer
    rmse = es.RMS()

    # Beregn energiprofil kun med RMS
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile)) * hop_size / sr, energy_profile)
    plt.xlabel('Time (s)')
    plt.ylabel('Normalized RMS Energy')
    plt.title('Basic RMS Energy Profile of the Track')
    plt.show()

    return energy_profile

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = basic_rms_energy_profile(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def basic_rms_energy_profile(audio_file_path):
    # Last inn musikkfilen med AudioLoader
    loader = es.AudioLoader(filename=audio_file_path)
    audio = loader()  # Laster inn lydfilen som en enkelt variabel
    sr = es.AudioLoader(filename=audio_file_path)()  # Henter samplingsfrekvensen

    # Hvis lyden er stereo (2 kanaler), konverter til mono
    if audio.ndim > 1:
        audio = np.mean(audio, axis=1)

    # Forhåndsdefinerte Essentia-algoritmer
    rmse = es.RMS()

    # Beregn energiprofil kun med RMS
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile)) * hop_size / sr, energy_profile)
    plt.xlabel('Time (s)')
    plt.ylabel('Normalized RMS Energy')
    plt.title('Basic RMS Energy Profile of the Track')
    plt.show()

    return energy_profile

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = basic_rms_energy_profile(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def basic_rms_energy_profile(audio_file_path):
    # Last inn musikkfilen med AudioLoader
    loader = es.AudioLoader(filename=audio_file_path)
    audio, _ = loader()  # Laster inn lydsignalet
    sr = loader.paramValue('sampleRate')  # Henter samplingsfrekvensen fra metadata

    # Hvis lyden er stereo (2 kanaler), konverter til mono
    if audio.ndim > 1:
        audio = np.mean(audio, axis=1)

    # Forhåndsdefinerte Essentia-algoritmer
    rmse = es.RMS()

    # Beregn energiprofil kun med RMS
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile)) * hop_size / sr, energy_profile)
    plt.xlabel('Time (s)')
    plt.ylabel('Normalized RMS Energy')
    plt.title('Basic RMS Energy Profile of the Track')
    plt.show()

    return energy_profile

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = basic_rms_energy_profile(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def basic_rms_energy_profile(audio_file_path):
    # Last inn musikkfilen med AudioLoader
    loader = es.AudioLoader(filename=audio_file_path)
    audio, sr, _ = loader()  # Laster inn lydsignalet, samplingsfrekvensen, og ignorerer metadata

    # Hvis lyden er stereo (2 kanaler), konverter til mono
    if audio.ndim > 1:
        audio = np.mean(audio, axis=1)

    # Forhåndsdefinerte Essentia-algoritmer
    rmse = es.RMS()

    # Beregn energiprofil kun med RMS
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile)) * hop_size / sr, energy_profile)
    plt.xlabel('Time (s)')
    plt.ylabel('Normalized RMS Energy')
    plt.title('Basic RMS Energy Profile of the Track')
    plt.show()

    return energy_profile

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = basic_rms_energy_profile(audio_file_path)

import essentia
import essentia.standard as es

def inspect_audio_loader(audio_file_path):
    # Last inn musikkfilen med AudioLoader
    loader = es.AudioLoader(filename=audio_file_path)
    loaded_audio = loader()  # Laster inn lydsignalet

    # Skriv ut type og antall elementer i det returnerte objektet
    print(f"Type of returned object: {type(loaded_audio)}")
    print(f"Number of elements returned: {len(loaded_audio)}")

    # Iterer gjennom elementene for å se hva de inneholder
    for i, item in enumerate(loaded_audio):
        print(f"Element {i}: Type = {type(item)}, Length = {len(item) if hasattr(item, '__len__') else 'N/A'}")

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
inspect_audio_loader(audio_file_path)

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def basic_rms_energy_profile(audio_file_path):
    # Last inn musikkfilen med AudioLoader
    loader = es.AudioLoader(filename=audio_file_path)
    audio, sr = loader()[:2]  # Henter kun de to første elementene: lydsignalet og samplingsfrekvensen

    # Hvis lyden er stereo (2 kanaler), konverter til mono
    if audio.ndim > 1:
        audio = np.mean(audio, axis=1)

    # Forhåndsdefinerte Essentia-algoritmer
    rmse = es.RMS()

    # Beregn energiprofil kun med RMS
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        # RMS Energy
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Visualisere energiprofilen
    plt.plot(np.arange(len(energy_profile)) * hop_size / sr, energy_profile)
    plt.xlabel('Time (s)')
    plt.ylabel('Normalized RMS Energy')
    plt.title('Basic RMS Energy Profile of the Track')
    plt.show()

    return energy_profile

# Test koden med musikkfilen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
energy_profile = basic_rms_energy_profile(audio_file_path)

def identify_sections_from_energy_profile(audio_file_path):
    # Last inn og beregn RMS-energiprofilen
    loader = es.AudioLoader(filename=audio_file_path)
    audio, sr = loader()[:2]
    if audio.ndim > 1:
        audio = np.mean(audio, axis=1)

    rmse = es.RMS()
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Identifisere seksjoner
    sections = []
    current_section = {'start': 0, 'label': 'Unknown'}

    for i in range(len(energy_profile)):
        time = i * hop_size / sr
        energy = energy_profile[i]

        # Definere terskler og etiketter
        if energy < 0.3:
            label = 'Intro/Outro'
        elif energy < 0.6:
            label = 'Verse/Breakdown'
        elif energy < 0.8:
            label = 'Build-up'
        else:
            label = 'Drop/Chorus'

        # Hvis vi bytter seksjon, lagre forrige seksjon
        if current_section['label'] != label:
            current_section['end'] = time
            sections.append(current_section)
            current_section = {'start': time, 'label': label}

    # Legg til siste seksjon
    current_section['end'] = len(audio) / sr
    sections.append(current_section)

    return sections

# Test seksjonsidentifikasjon
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
sections = identify_sections_from_energy_profile(audio_file_path)
for section in sections:
    print(f"Start: {section['start']:.2f}s, End: {section['end']:.2f}s, Label: {section['label']}")

import essentia
import essentia.standard as es
import numpy as np
import matplotlib.pyplot as plt

def identify_sections_from_energy_profile(audio_file_path):
    # Last inn og beregn RMS-energiprofilen
    loader = es.AudioLoader(filename=audio_file_path)
    audio, sr = loader()[:2]
    if audio.ndim > 1:
        audio = np.mean(audio, axis=1)

    rmse = es.RMS()
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Smooth energiprofilen med et gjennomsnittsvindu
    smooth_window = 50  # Størrelse på vinduet
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window) / smooth_window, mode='same')

    # Identifisere seksjoner
    sections = []
    current_section = {'start': 0, 'label': 'Unknown'}
    min_section_duration = 2  # Minimum varighet i sekunder

    for i in range(len(energy_profile_smoothed)):
        time = i * hop_size / sr
        energy = energy_profile_smoothed[i]

        # Definere terskler og etiketter
        if energy < 0.3:
            label = 'Intro/Outro'
        elif energy < 0.6:
            label = 'Verse/Breakdown'
        elif energy < 0.8:
            label = 'Build-up'
        else:
            label = 'Drop/Chorus'

        # Hvis vi bytter seksjon, lagre forrige seksjon hvis den er lang nok
        if current_section['label'] != label:
            if (time - current_section['start']) >= min_section_duration:
                current_section['end'] = time
                sections.append(current_section)
            current_section = {'start': time, 'label': label}

    # Legg til siste seksjon hvis den er lang nok
    if (len(audio) / sr - current_section['start']) >= min_section_duration:
        current_section['end'] = len(audio) / sr
        sections.append(current_section)

    return sections

# Test seksjonsidentifikasjon
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
sections = identify_sections_from_energy_profile(audio_file_path)
for section in sections:
    print(f"Start: {section['start']:.2f}s, End: {section['end']:.2f}s, Label: {section['label']}")

def identify_sections_with_adjustments(audio_file_path):
    # Last inn og beregn RMS-energiprofilen
    loader = es.AudioLoader(filename=audio_file_path)
    audio, sr = loader()[:2]
    if audio.ndim > 1:
        audio = np.mean(audio, axis=1)

    rmse = es.RMS()
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Juster smoothing av energiprofilen
    smooth_window = 100  # Juster størrelsen på smoothing-vinduet
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window) / smooth_window, mode='same')

    # Identifisere seksjoner med justerte terskler
    sections = []
    current_section = {'start': 0, 'label': 'Unknown'}
    min_section_duration = 5  # Økt minimum varighet i sekunder

    for i in range(len(energy_profile_smoothed)):
        time = i * hop_size / sr
        energy = energy_profile_smoothed[i]

        # Justerte terskler og etiketter
        if energy < 0.2:  # Justert nedre terskel for Intro/Outro
            label = 'Intro/Outro'
        elif energy < 0.5:  # Justert midtre terskel for Verse/Breakdown
            label = 'Verse/Breakdown'
        elif energy < 0.7:  # Justert øvre terskel for Build-up
            label = 'Build-up'
        else:
            label = 'Drop/Chorus'

        # Hvis vi bytter seksjon, lagre forrige seksjon hvis den er lang nok
        if current_section['label'] != label:
            if (time - current_section['start']) >= min_section_duration:
                current_section['end'] = time
                sections.append(current_section)
            current_section = {'start': time, 'label': label}

    # Legg til siste seksjon hvis den er lang nok
    if (len(audio) / sr - current_section['start']) >= min_section_duration:
        current_section['end'] = len(audio) / sr
        sections.append(current_section)

    return sections

# Test seksjonsidentifikasjon med justeringer
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
sections = identify_sections_with_adjustments(audio_file_path)
for section in sections:
    print(f"Start: {section['start']:.2f}s, End: {section['end']:.2f}s, Label: {section['label']}")

def identify_sections_with_adjustments(audio_file_path):
    # Last inn og beregn RMS-energiprofilen
    loader = es.AudioLoader(filename=audio_file_path)
    audio, sr = loader()[:2]
    if audio.ndim > 1:
        audio = np.mean(audio, axis=1)

    rmse = es.RMS()
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Juster smoothing av energiprofilen
    smooth_window = 100  # Juster størrelsen på smoothing-vinduet
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window) / smooth_window, mode='same')

    # Identifisere seksjoner med justerte terskler
    sections = []
    current_section = {'start': 0, 'label': 'Unknown'}
    min_section_duration = 5  # Økt minimum varighet i sekunder

    for i in range(len(energy_profile_smoothed)):
        time = i * hop_size / sr
        energy = energy_profile_smoothed[i]

        # Justerte terskler og etiketter
        if energy < 0.2:  # Justert nedre terskel for Intro/Outro
            label = 'Intro/Outro'
        elif energy < 0.5:  # Justert midtre terskel for Verse/Breakdown
            label = 'Verse/Breakdown'
        elif energy < 0.7:  # Justert øvre terskel for Build-up
            label = 'Build-up'
        else:
            label = 'Drop/Chorus'

        # Hvis vi bytter seksjon, lagre forrige seksjon hvis den er lang nok
        if current_section['label'] != label:
            if (time - current_section['start']) >= min_section_duration:
                current_section['end'] = time
                sections.append(current_section)
            current_section = {'start': time, 'label': label}

    # Legg til siste seksjon hvis den er lang nok
    if (len(audio) / sr - current_section['start']) >= min_section_duration:
        current_section['end'] = len(audio) / sr
        sections.append(current_section)

    return sections

# Test seksjonsidentifikasjon med justeringer
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
sections = identify_sections_with_adjustments(audio_file_path)
for section in sections:
    print(f"Start: {section['start']:.2f}s, End: {section['end']:.2f}s, Label: {section['label']}")

def identify_sections_with_beat_detection(audio_file_path):
    # Last inn og beregn RMS-energiprofilen
    loader = es.AudioLoader(filename=audio_file_path)
    audio, sr = loader()[:2]
    if audio.ndim > 1:
        audio = np.mean(audio, axis=1)

    # Beregn beats
    rhythm_extractor = es.RhythmExtractor2013(method="multifeature")
    bpm, beats, beats_confidence, _, _ = rhythm_extractor(audio)

    rmse = es.RMS()
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Smooth energiprofilen med et gjennomsnittsvindu
    smooth_window = 100
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window) / smooth_window, mode='same')

    # Identifisere seksjoner med hensyn til beat detection
    sections = []
    current_section = {'start': 0, 'label': 'Intro/Verse'}
    min_section_duration = 8  # Minimum varighet i sekunder

    for i in range(len(energy_profile_smoothed)):
        time = i * hop_size / sr
        energy = energy_profile_smoothed[i]

        # Justerte terskler og etiketter
        if energy < 0.2:
            label = 'Intro/Verse'
        elif energy < 0.5:
            label = 'Build-up'
        elif energy < 0.7 and time in beats:
            label = 'Pre-Drop'
        else:
            label = 'Drop/Chorus'

        # Hvis vi bytter seksjon, lagre forrige seksjon hvis den er lang nok
        if current_section['label'] != label:
            if (time - current_section['start']) >= min_section_duration:
                current_section['end'] = time
                sections.append(current_section)
            current_section = {'start': time, 'label': label}

    # Legg til siste seksjon hvis den er lang nok
    if (len(audio) / sr - current_section['start']) >= min_section_duration:
        current_section['end'] = len(audio) / sr
        sections.append(current_section)

    return sections

# Test seksjonsidentifikasjon med beat detection
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/18420294_Got That Booty_(Extended Mix).mp3'
sections = identify_sections_with_beat_detection(audio_file_path)
for section in sections:
    print(f"Start: {section['start']:.2f}s, End: {section['end']:.2f}s, Label: {section['label']}")

def identify_sections_with_beat_detection(audio_file_path):
    # Last inn og beregn RMS-energiprofilen
    loader = es.AudioLoader(filename=audio_file_path)
    audio, sr = loader()[:2]
    if audio.ndim > 1:
        audio = np.mean(audio, axis=1)

    # Beregn beats
    rhythm_extractor = es.RhythmExtractor2013(method="multifeature")
    bpm, beats, beats_confidence, _, _ = rhythm_extractor(audio)

    rmse = es.RMS()
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Smooth energiprofilen med et gjennomsnittsvindu
    smooth_window = 100
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window) / smooth_window, mode='same')

    # Identifisere seksjoner med hensyn til beat detection
    sections = []
    current_section = {'start': 0, 'label': 'Intro/Verse'}
    min_section_duration = 8  # Minimum varighet i sekunder

    for i in range(len(energy_profile_smoothed)):
        time = i * hop_size / sr
        energy = energy_profile_smoothed[i]

        # Justerte terskler og etiketter
        if energy < 0.2:
            label = 'Intro/Verse'
        elif energy < 0.5:
            label = 'Build-up'
        elif energy < 0.7 and time in beats:
            label = 'Pre-Drop'
        else:
            label = 'Drop/Chorus'

        # Hvis vi bytter seksjon, lagre forrige seksjon hvis den er lang nok
        if current_section['label'] != label:
            if (time - current_section['start']) >= min_section_duration:
                current_section['end'] = time
                sections.append(current_section)
            current_section = {'start': time, 'label': label}

    # Legg til siste seksjon hvis den er lang nok
    if (len(audio) / sr - current_section['start']) >= min_section_duration:
        current_section['end'] = len(audio) / sr
        sections.append(current_section)

    return sections

# Test seksjonsidentifikasjon med beat detection på den nye sangen
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/17564479_KOKA_(Original Mix).mp3'
sections = identify_sections_with_beat_detection(audio_file_path)
for section in sections:
    print(f"Start: {section['start']:.2f}s, End: {section['end']:.2f}s, Label: {section['label']}")

def analyze_multiple_songs(song_paths):
    results = {}
    for audio_file_path in song_paths:
        print(f"\nAnalyserer sang: {audio_file_path}")
        sections = identify_sections_with_beat_detection(audio_file_path)
        results[audio_file_path] = sections
        for section in sections:
            print(f"Start: {section['start']:.2f}s, End: {section['end']:.2f}s, Label: {section['label']}")
    return results

# Filstier til de fire sangene
song_paths = [
    '/content/drive/My Drive/SuperDJ_Project/music_library/17588048_Believer_(Original Mix).mp3',
    '/content/drive/My Drive/SuperDJ_Project/music_library/17477194_Boom Boom Boom_(Extended Mix).mp3',
    '/content/drive/My Drive/SuperDJ_Project/music_library/17788126_GATE_(Original Mix).mp3',
    '/content/drive/My Drive/SuperDJ_Project/music_library/17588819_Sitar_(Original Mix).mp3'
]

# Analyser de fire sangene
results = analyze_multiple_songs(song_paths)

import essentia
import essentia.standard as es
import numpy as np

def identify_sections_with_beat_detection(audio_file_path):
    # Last inn og beregn RMS-energiprofilen
    loader = es.AudioLoader(filename=audio_file_path)
    audio, sr = loader()[:2]
    if audio.ndim > 1:
        audio = np.mean(audio, axis=1)

    # Beregn beats
    rhythm_extractor = es.RhythmExtractor2013(method="multifeature")
    bpm, beats, beats_confidence, _, _ = rhythm_extractor(audio)

    rmse = es.RMS()
    frame_size = 2048
    hop_size = 512
    energy_profile = []

    for frame in es.FrameGenerator(audio, frameSize=frame_size, hopSize=hop_size):
        rms_energy = rmse(frame)
        energy_profile.append(rms_energy)

    # Normaliser energiprofilen
    energy_profile = np.array(energy_profile)
    energy_profile /= np.max(energy_profile)

    # Smooth energiprofilen med et gjennomsnittsvindu
    smooth_window = 100
    energy_profile_smoothed = np.convolve(energy_profile, np.ones(smooth_window) / smooth_window, mode='same')

    # Identifisere seksjoner med hensyn til beat detection
    sections = []
    current_section = {'start': 0, 'label': 'Intro/Verse'}
    min_section_duration = 8  # Minimum varighet i sekunder

    for i in range(len(energy_profile_smoothed)):
        time = i * hop_size / sr
        energy = energy_profile_smoothed[i]

        # Justerte terskler og etiketter
        if energy < 0.2:
            label = 'Intro/Verse'
        elif energy < 0.5:
            label = 'Build-up'
        elif energy < 0.7 and time in beats:
            label = 'Pre-Drop'
        else:
            label = 'Drop/Chorus'

        # Hvis vi bytter seksjon, lagre forrige seksjon hvis den er lang nok
        if current_section['label'] != label:
            if (time - current_section['start']) >= min_section_duration:
                current_section['end'] = time
                sections.append(current_section)
            current_section = {'start': time, 'label': label}

    # Legg til siste seksjon hvis den er lang nok
    if (len(audio) / sr - current_section['start']) >= min_section_duration:
        current_section['end'] = len(audio) / sr
        sections.append(current_section)

    return sections

def analyze_multiple_songs(song_paths):
    results = {}
    for audio_file_path in song_paths:
        print(f"\nAnalyserer sang: {audio_file_path}")
        sections = identify_sections_with_beat_detection(audio_file_path)
        results[audio_file_path] = sections
        for section in sections:
            print(f"Start: {section['start']:.2f}s, End: {section['end']:.2f}s, Label: {section['label']}")
    return results

# Filstier til de fire sangene
song_paths = [
    '/content/drive/My Drive/SuperDJ_Project/music_library/17588048_Believer_(Original Mix).mp3',
    '/content/drive/My Drive/SuperDJ_Project/music_library/17477194_Boom Boom Boom_(Extended Mix).mp3',
    '/content/drive/My Drive/SuperDJ_Project/music_library/17788126_GATE_(Original Mix).mp3',
    '/content/drive/My Drive/SuperDJ_Project/music_library/17588819_Sitar_(Original Mix).mp3'
]

# Analyser de fire sangene
results = analyze_multiple_songs(song_paths)

!git clone https://github.com/cburmeister/beatport.git

!pip install -r beatport/requirements.txt

!pip install eyed3

import eyed3

# Path til en MP3-fil i din Google Drive-mappe
audio_file_path = '/content/drive/My Drive/SuperDJ_Project/music_library/17588048_Believer_(Original Mix).mp3'

# Laste inn MP3-filen
audiofile = eyed3.load(audio_file_path)

# Ekstrahere metadata
print(f"Title: {audiofile.tag.title}")
print(f"Artist: {audiofile.tag.artist}")
print(f"Album: {audiofile.tag.album}")
print(f"BPM: {audiofile.tag.bpm}")
print(f"Genre: {audiofile.tag.genre}")

from beatport import Beatport

# Liste med Beatport spor-ID-er
track_ids = [17588048, 17477194, 17788126, 17588819]

# Hente metadata for hver sang ved hjelp av Beatport-biblioteket
for track_id in track_ids:
    track = Beatport().track(track_id)
    print(f"Metadata for Track ID {track_id}:")
    print(track)
    print("\n")

# Commented out IPython magic to ensure Python compatibility.
# Naviger til katalogen hvor beatport er klonet
# %cd /content/beatport

# Installer biblioteket
!pip install .

from beatport import Beatport

# Test om vi kan opprette en Beatport-objekt
bp = Beatport()

from beatport.api import Beatport

!mv /content/beatport/beatport.py /content/beatport/beatport_api.py

from beatport_api import Beatport

!ls /content/beatport

from beatport_api import Beatport

!cat /content/beatport/beatport_api.py

# Sørg for at Python finner beatport_api
import sys
sys.path.append('/content/beatport')

# Importer nødvendige klasser fra beatport_api
from beatport_api import Tracks, Artists, Genres, Search

# Eksempel på å hente spor fra Beatport ved å bruke en spor-ID
track_id = 17588048
track = Tracks(id=track_id)
track_data = track.data
print(track_data)

from google.colab import drive
drive.mount('/content/drive')

pip install mido

import mido

# Sett opp MIDI-utgang
midi_out = mido.open_output('Mixxx')

# Send MIDI-melding for å starte avspilling
play_msg = mido.Message('note_on', note=60)
midi_out.send(play_msg)

# Send flere meldinger her for andre kontroller

!pip install python-rtmidi

import mido

# Sett opp MIDI-utgang
midi_out = mido.open_output('Mixxx')

# Send MIDI-melding for å starte avspilling
play_msg = mido.Message('note_on', note=60)
midi_out.send(play_msg)

# Send flere meldinger her for andre kontroller

from google.colab import drive
drive.mount('/content/drive')

with open('/content/drive/MyDrive/SuperDJ_Project/mixxx_data_extract.py', 'w') as f:
    f.write('''import sqlite3

!ls /content/drive/MyDrive/SuperDJ_Project/

with open('/content/drive/MyDrive/SuperDJ_Project/mixxx_data_extract.py', 'w') as f:
    f.write('''import sqlite3

# Koble til Mixxx-databasen
conn = sqlite3.connect('/content/drive/MyDrive/SuperDJ_Project/mixxx_data/mixxxdb.sqlite')
cursor = conn.cursor()

# Hent relevant musikkdata fra databasen (BPM, artist, tittel, toneart)
cursor.execute("SELECT bpm, artist, title, key FROM track_locations")
tracks = cursor.fetchall()

# Skriv ut informasjonen om musikken
for track in tracks:
    bpm, artist, title, key = track
    print(f'Title: {title}, Artist: {artist}, BPM: {bpm}, Key: {key}')

conn.close()
''')

with open('/content/drive/MyDrive/SuperDJ_Project/mixxx_data_extract.py', 'w') as f:
    f.write('''import sqlite3

# Koble til Mixxx-databasen
conn = sqlite3.connect('/content/drive/MyDrive/SuperDJ_Project/mixxx_data/mixxxdb.sqlite')
cursor = conn.cursor()

# Hent relevant musikkdata fra databasen (BPM, artist, tittel, toneart)
cursor.execute("SELECT bpm, artist, title, key FROM track_locations")
tracks = cursor.fetchall()

# Skriv ut informasjonen om musikken
for track in tracks:
    bpm, artist, title, key = track
    print(f'Title: {title}, Artist: {artist}, BPM: {bpm}, Key: {key}')

conn.close()
'''  # Dette er hvor strengen avsluttes

import sqlite3

# Koble til Mixxx-databasen
conn = sqlite3.connect('/content/drive/MyDrive/SuperDJ_Project/mixxx_files/mixxxdb.sqlite')
cursor = conn.cursor()

# Hent relevant musikkdata fra databasen (BPM, artist, tittel, toneart)
cursor.execute("SELECT bpm, artist, title, key FROM track_locations")
tracks = cursor.fetchall()

# Skriv ut informasjonen om musikken
for track in tracks:
    bpm, artist, title, key = track
    print(f'Title: {title}, Artist: {artist}, BPM: {bpm}, Key: {key}')

conn.close()

# Koble til Mixxx-databasen
conn = sqlite3.connect('/content/drive/MyDrive/SuperDJ_Project/mixxx_files/mixxxdb.sqlite')
cursor = conn.cursor()

# Vis strukturen til 'track_locations'-tabellen
cursor.execute("PRAGMA table_info(track_locations)")
columns = cursor.fetchall()

# Skriv ut kolonnenavnene
for column in columns:
    print(column)

conn.close()

# Koble til Mixxx-databasen
conn = sqlite3.connect('/content/drive/MyDrive/SuperDJ_Project/mixxx_files/mixxxdb.sqlite')
cursor = conn.cursor()

# Vis alle tabellene i databasen
cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
tables = cursor.fetchall()

# Skriv ut alle tabellene
for table in tables:
    print(table)

conn.close()

# Koble til Mixxx-databasen
conn = sqlite3.connect('/content/drive/MyDrive/SuperDJ_Project/mixxx_files/mixxxdb.sqlite')
cursor = conn.cursor()

# Vis kolonnene i 'library'-tabellen
cursor.execute("PRAGMA table_info(library)")
columns = cursor.fetchall()

# Skriv ut kolonnenavnene
for column in columns:
    print(column)

conn.close()

# Koble til Mixxx-databasen
conn = sqlite3.connect('/content/drive/MyDrive/SuperDJ_Project/mixxx_files/mixxxdb.sqlite')
cursor = conn.cursor()

# Vis kolonnene i 'track_analysis'-tabellen
cursor.execute("PRAGMA table_info(track_analysis)")
columns = cursor.fetchall()

# Skriv ut kolonnenavnene
for column in columns:
    print(column)

conn.close()

import sqlite3

# Koble til Mixxx-databasen
conn = sqlite3.connect('/content/drive/MyDrive/SuperDJ_Project/mixxx_files/mixxxdb.sqlite')
cursor = conn.cursor()

# Hent relevant musikkdata fra 'library'-tabellen (BPM, artist, tittel, toneart)
cursor.execute("SELECT artist, title, bpm, key FROM library")
tracks = cursor.fetchall()

# Skriv ut informasjonen om musikken
for track in tracks:
    artist, title, bpm, key = track
    print(f'Title: {title}, Artist: {artist}, BPM: {bpm}, Key: {key}')

conn.close()

import sqlite3
import csv

# Koble til Mixxx-databasen
conn = sqlite3.connect('/content/drive/MyDrive/SuperDJ_Project/mixxx_files/mixxxdb.sqlite')
cursor = conn.cursor()

# Hent relevant musikkdata fra 'library'-tabellen
cursor.execute("SELECT artist, title, bpm, key FROM library WHERE bpm > 0.0")
tracks = cursor.fetchall()

# Filtrer bort spor som ikke har artist eller tittel
filtered_tracks = [track for track in tracks if track[0] and track[1]]  # Filtrer ut der artist og title ikke er tomme

# Skriv data til CSV-fil
with open('/content/drive/MyDrive/SuperDJ_Project/music_data_clean.csv', 'w', newline='') as csvfile:
    csvwriter = csv.writer(csvfile)
    csvwriter.writerow(['Artist', 'Title', 'BPM', 'Key'])  # Header
    csvwriter.writerows(filtered_tracks)

conn.close()
print("Data eksportert til music_data_clean.csv")

import os
import json
import random

# Funksjon for å laste inn musikkdata fra JSON-filene
def load_music_data_from_json(directory):
    music_data = []
    for file_name in os.listdir(directory):
        if file_name.endswith('.json'):  # Vi leser kun JSON-filene
            file_path = os.path.join(directory, file_name)
            with open(file_path, 'r') as f:
                music_data.append(json.load(f))
    return music_data

# Funksjon for å justere BPM for sanger med BPM under 100 (dobling)
def adjust_bpm(song):
    if song['BPM'] < 100:
        song['BPM'] *= 2
    return song

# Generer Camelot-hjulet
def generate_camelot_wheel():
    camelot_wheel = {
        '1A': ['1A', '12A', '2A', '1B'], '2A': ['2A', '1A', '3A', '2B'],
        '3A': ['3A', '2A', '4A', '3B'], '4A': ['4A', '3A', '5A', '4B'],
        '5A': ['5A', '4A', '6A', '5B'], '6A': ['6A', '5A', '7A', '6B'],
        '7A': ['7A', '6A', '8A', '7B'], '8A': ['8A', '7A', '9A', '8B'],
        '9A': ['9A', '8A', '10A', '9B'], '10A': ['10A', '9A', '11A', '10B'],
        '11A': ['11A', '10A', '12A', '11B'], '12A': ['12A', '11A', '1A', '12B'],
        '1B': ['1B', '12B', '2B', '1A'], '2B': ['2B', '1B', '3B', '2A'],
        '3B': ['3B', '2B', '4B', '3A'], '4B': ['4B', '3B', '5B', '4A'],
        '5B': ['5B', '4B', '6B', '5A'], '6B': ['6B', '5B', '7B', '6A'],
        '7B': ['7B', '6B', '8B', '7A'], '8B': ['8B', '7B', '9B', '8A'],
        '9B': ['9B', '8B', '10B', '9A'], '10B': ['10B', '9B', '11B', '10A'],
        '11B': ['11B', '10B', '12B', '11A'], '12B': ['12B', '11B', '1B', '12A']
    }
    return camelot_wheel

# Funksjon for å sjekke harmonisk kompatibilitet mellom to sanger
def is_harmonically_compatible(current_key, next_key, camelot_wheel):
    compatible_keys = camelot_wheel.get(current_key, [])
    return next_key in compatible_keys

# Funksjon for å finne sang med Camelot Key matching først
def choose_next_song(current_song, music_data, camelot_wheel, played_songs, bpm_tolerance=25, max_pitch_shift=12):
    current_key = current_song['Camelot Key']
    current_bpm = current_song['BPM']
    current_genre = current_song.get('Sjanger', 'Unknown')

    # 1. Camelot Key Matching
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            next_key = song['Camelot Key']
            if is_harmonically_compatible(current_key, next_key, camelot_wheel):
                song = adjust_bpm(song)  # Juster BPM hvis det er under 100
                if abs(song['BPM'] - current_bpm) <= bpm_tolerance:
                    candidates.append(song)

    if candidates:
        selected_song = random.choice(candidates)
        print(f"Valgt sang: {selected_song['Sang']} (Camelot Key: {selected_song['Camelot Key']}, BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        played_songs.append(selected_song['Sang'])
        return selected_song

    # 2. BPM og Energi Matching (med pitch-shift)
    print("Ingen kompatible sanger funnet basert på Camelot-hjulet, prøver med BPM og energi.")
    candidates = []
    for song in music_data:
        if song['Sang'] not in played_songs and song['Sang'] != current_song['Sang']:
            song = adjust_bpm(song)  # Juster BPM hvis det er under 100
            bpm_difference = abs(current_bpm - song['BPM'])
            pitch_shift = (bpm_difference / song['BPM']) * 100  # Beregn pitch-shift
            if abs(pitch_shift) <= max_pitch_shift:  # Sjekk om pitch-shift er akseptabel
                candidates.append(song)

    if candidates:
        # 3. Prioriter sjanger matching
        genre_matched_candidates = [song for song in candidates if song.get('Sjanger', 'Unknown') == current_genre]
        if genre_matched_candidates:
            selected_song = random.choice(genre_matched_candidates)
            print(f"Valgt sang basert på BPM, energi og sjanger: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")
        else:
            selected_song = random.choice(candidates)
            print(f"Valgt sang basert på BPM og energi: {selected_song['Sang']} (BPM: {selected_song['BPM']}, Energi: {selected_song['Energi']}, Sjanger: {selected_song.get('Sjanger', 'Unknown')})")

        played_songs.append(selected_song['Sang'])
        return selected_song

    return None

# Funksjon for å simulere miksetid og dynamisk crossfade
def simulate_mix_time(current_song, next_song, max_crossfade_time=15):
    current_song_length = random.randint(180, 300)  # Simulerer sanglengde mellom 3 til 5 minutter
    next_song_length = random.randint(180, 300)

    # Beregn dynamisk crossfade basert på BPM-forskjell, energi og sjanger
    bpm_diff = abs(current_song['BPM'] - next_song['BPM'])
    energy_diff = abs(current_song['Energi'] - next_song['Energi'])

    crossfade_time = max_crossfade_time - int((bpm_diff + energy_diff) / 2)  # Juster crossfade-tid dynamisk
    if crossfade_time < 5:
        crossfade_time = 5  # Minste crossfade-tid

    # Print startposisjoner
    print(f"Starter å spille '{current_song['Sang']}' fra 0s.")
    mix_start_time = random.randint(60, current_song_length - 30)  # Miksen starter et sted i sangen
    next_song_start_time = random.randint(0, next_song_length - 30)  # Neste sang starter et sted i sangen
    print(f"Miksen starter etter {mix_start_time}s i '{current_song['Sang']}' og {next_song_start_time}s i '{next_song['Sang']}'.")

    # Simulerer mikseprosessen
    print(f"Crossfader fra '{current_song['Sang']}' til '{next_song['Sang']}' over {crossfade_time}s.")
    mix_end_time = mix_start_time + crossfade_time
    print(f"'{current_song['Sang']}' slutter etter {mix_end_time}s, '{next_song['Sang']}' spiller fullt ut fra {next_song_start_time}s.")

    return next_song

# Test Camelot-basert sangvalg for hele musikkbiblioteket
def select_songs_for_library(music_data, camelot_wheel):
    played_songs = []  # Hold oversikt over spilte sanger

    # Velg den første sangen tilfeldig
    current_song = random.choice(music_data)
    played_songs.append(current_song['Sang'])
    print(f"Start med sang: {current_song['Sang']} (Camelot Key: {current_song['Camelot Key']}, BPM: {current_song['BPM']}, Energi: {current_song['Energi']}, Sjanger: {current_song.get('Sjanger', 'Unknown')})")

    # Velg flere sanger i rekkefølge til alle er spilt
    while len(played_songs) < len(music_data):
        next_song = choose_next_song(current_song, music_data, camelot_wheel, played_songs)
        if next_song:
            # Simuler mikseprosessen med dynamisk crossfade og utskrift
            current_song = simulate_mix_time(current_song, next_song)
        else:
            print("Ingen flere sanger tilgjengelig, avslutter mikseprosessen.")
            break

    print("Spilleliste komplett. Her er rekkefølgen av spilte sanger:")
    for song in played_songs:
        print(f"- {song}")

# Hovedprogrammet som kjører analysen og velger sanger
def main():
    # Sti til mappen med JSON-filene dine
    json_directory = '/content/drive/My Drive/SuperDJ_Project/music_analysis'  # Bytt ut med riktig sti til JSON-filene dine

    # Last inn musikkdata fra JSON-filene
    music_data = load_music_data_from_json(json_directory)

    # Last inn Camelot-hjulet
    camelot_wheel = generate_camelot_wheel()

    # Velg sanger i rekkefølge basert på Camelot-hjulet, BPM, energi og sjanger
    select_songs_for_library(music_data, camelot_wheel)

# Kjør hovedprogrammet
if __name__ == '__main__':
    main()

import sqlite3
import csv
import os

# Stier til Mixxx-databasen og CSV-filen
mixxx_db_path = '/content/drive/MyDrive/SuperDJ_Project/mixxx_files/mixxxdb.sqlite'  # Stien til Mixxx-databasen
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/music_data_clean.csv'  # Stien til CSV-filen

# Funksjon for å hente musikkdata fra Mixxx-databasen
def extract_data_from_mixxx_db(mixxx_db_path):
    conn = sqlite3.connect(mixxx_db_path)
    cursor = conn.cursor()

    # Oppdatert SQL-spørring med flere kolonner
    query = '''
    SELECT
        library.id AS song_id,
        library.title AS title,
        library.artist AS artist,
        library.bpm AS bpm,
        library.key AS key,
        library.duration AS duration,
        library.cuepoint AS cue_point,
        library.gain AS gain,
        library.beatgrid_locked AS beatgrid_locked,
        library.playcount AS play_count,            -- Antall ganger spilt
        library.last_played AS last_played,          -- Når sangen sist ble spilt
        library.rating AS rating,                    -- Brukervurdering
        library.comment AS comment                   -- Kommentarer/merkinger
    FROM library;
    '''

    cursor.execute(query)

    music_data = []
    for row in cursor.fetchall():
        track_id, title, artist, bpm, key, duration, cue_point, gain, beatgrid_locked, play_count, last_played, rating, comment = row
        music_data.append({
            'ID': track_id,
            'Artist': artist,
            'Title': title,
            'Duration': duration,
            'BPM': bpm,
            'Key': key,
            'Cue Point': cue_point,
            'Gain': gain,
            'Beatgrid Locked': beatgrid_locked,
            'Play Count': play_count,
            'Last Played': last_played,
            'Rating': rating,
            'Comment': comment
        })

    conn.close()
    return music_data

# Funksjon for å eksportere musikkdata til CSV
def export_to_csv(music_data, csv_file_path):
    fieldnames = ['ID', 'Artist', 'Title', 'Duration', 'BPM', 'Key', 'Cue Point', 'Gain', 'Beatgrid Locked',
                  'Play Count', 'Last Played', 'Rating', 'Comment']

    with open(csv_file_path, mode='w', newline='') as file:
        writer = csv.DictWriter(file, fieldnames=fieldnames)
        writer.writeheader()
        for track in music_data:
            writer.writerow(track)

# Hovedfunksjon for å kjøre hele prosessen
def main():
    # Hent data fra Mixxx-databasen
    music_data = extract_data_from_mixxx_db(mixxx_db_path)

    # Eksporter data til CSV
    export_to_csv(music_data, csv_file_path)
    print(f"Musikkdata eksportert til {csv_file_path}")

# Kjør hovedfunksjonen
if __name__ == '__main__':
    main()

import sqlite3
import csv
import os

# Stier til Mixxx-databasen og CSV-filen
mixxx_db_path = '/content/drive/MyDrive/SuperDJ_Project/mixxx_files/mixxxdb.sqlite'
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/music_data_clean.csv'

# Funksjon for å hente musikkdata fra Mixxx-databasen
def extract_data_from_mixxx_db(mixxx_db_path):
    conn = sqlite3.connect(mixxx_db_path)
    cursor = conn.cursor()

    # Forenklet SQL-spørring for å unngå kolonner som kanskje ikke eksisterer
    query = '''
    SELECT
        library.id AS song_id,
        library.title AS title,
        library.artist AS artist,
        library.bpm AS bpm,
        library.key AS key,
        library.duration AS duration
    FROM library;
    '''

    cursor.execute(query)

    music_data = []
    for row in cursor.fetchall():
        track_id, title, artist, bpm, key, duration = row
        music_data.append({
            'ID': track_id,
            'Artist': artist,
            'Title': title,
            'Duration': duration,
            'BPM': bpm,
            'Key': key
        })

    conn.close()
    return music_data

# Funksjon for å eksportere musikkdata til CSV
def export_to_csv(music_data, csv_file_path):
    fieldnames = ['ID', 'Artist', 'Title', 'Duration', 'BPM', 'Key']

    with open(csv_file_path, mode='w', newline='') as file:
        writer = csv.DictWriter(file, fieldnames=fieldnames)
        writer.writeheader()
        for track in music_data:
            writer.writerow(track)

# Hovedfunksjon for å kjøre hele prosessen
def main():
    # Hent data fra Mixxx-databasen
    music_data = extract_data_from_mixxx_db(mixxx_db_path)

    # Eksporter data til CSV
    export_to_csv(music_data, csv_file_path)
    print(f"Musikkdata eksportert til {csv_file_path}")

# Kjør hovedfunksjonen
if __name__ == '__main__':
    main()

import sqlite3
import csv
import os

# Stier til Mixxx-databasen og CSV-filen på Google Drive
mixxx_db_path = '/content/drive/MyDrive/SuperDJ_Project/mixxx_files/mixxxdb.sqlite'  # Oppdater med riktig sti
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/music_data_clean.csv'  # Sti til CSV-filen

# Funksjon for å hente musikkdata fra Mixxx-databasen
def extract_data_from_mixxx_db(mixxx_db_path):
    conn = sqlite3.connect(mixxx_db_path)
    cursor = conn.cursor()

    # Henter nødvendige felter fra Mixxx-biblioteket
    query = '''
    SELECT
        id, artist, title, duration, bpm, key, cuepoint, gain, beatgrid_locked
    FROM library
    '''

    cursor.execute(query)

    music_data = []
    for row in cursor.fetchall():
        track_id, artist, title, duration, bpm, key, cue_point, gain, beatgrid_locked = row
        music_data.append({
            'ID': track_id,
            'Artist': artist,
            'Title': title,
            'Duration': duration,
            'BPM': bpm,
            'Key': key,
            'Cue Point': cue_point,
            'Gain': gain,
            'Beatgrid Locked': beatgrid_locked
        })

    conn.close()
    return music_data

# Funksjon for å eksportere musikkdata til CSV
def export_to_csv(music_data, csv_file_path):
    with open(csv_file_path, mode='w', newline='') as file:
        writer = csv.DictWriter(file, fieldnames=['ID', 'Artist', 'Title', 'Duration', 'BPM', 'Key', 'Cue Point', 'Gain', 'Beatgrid Locked'])
        writer.writeheader()
        for track in music_data:
            writer.writerow(track)

# Hovedfunksjon for å kjøre hele prosessen
def main():
    # Hent data fra Mixxx-databasen
    music_data = extract_data_from_mixxx_db(mixxx_db_path)

    # Eksporter data til CSV
    export_to_csv(music_data, csv_file_path)
    print(f"Musikkdata eksportert til {csv_file_path}")

# Kjør hovedfunksjonen
if __name__ == '__main__':
    main()

import sqlite3

# Sti til Mixxx-databasen
mixxx_db_path = '/content/drive/MyDrive/SuperDJ_Project/mixxx_files/mixxxdb.sqlite'

# Funksjon for å hente kolonneinformasjon fra Mixxx-databasen
def list_columns_in_library(mixxx_db_path):
    conn = sqlite3.connect(mixxx_db_path)
    cursor = conn.cursor()

    # Henter kolonneinformasjon fra library-tabellen
    cursor.execute('PRAGMA table_info(library);')
    columns = cursor.fetchall()

    # Lukk forbindelsen
    conn.close()

    # Returner kolonnenavnene
    return [column[1] for column in columns]

# Kjør funksjonen for å liste kolonner
columns = list_columns_in_library(mixxx_db_path)
print("Tilgjengelige kolonner i library-tabellen:", columns)

import sqlite3
import csv

# Stier til Mixxx-databasen og CSV-filen på Google Drive
mixxx_db_path = '/content/drive/MyDrive/SuperDJ_Project/mixxx_files/mixxxdb.sqlite'  # Sti til Mixxx-databasen
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/music_data_clean.csv'  # Sti til den eksisterende CSV-filen

# Funksjon for å hente musikkdata fra Mixxx-databasen
def extract_data_from_mixxx_db(mixxx_db_path):
    conn = sqlite3.connect(mixxx_db_path)
    cursor = conn.cursor()

    # Oppdatert SQL-spørring med de ønskede kolonnene
    query = '''
    SELECT
        id, artist, title, genre, location, duration, bitrate, samplerate,
        cuepoint, bpm, wavesummaryhex, channels, datetime_added, mixxx_deleted,
        played, header_parsed, filetype, replaygain, timesplayed, rating, key,
        beats, beats_version, bpm_lock, beats_sub_version, keys, keys_version,
        keys_sub_version, key_id, grouping, replaygain_peak, tracktotal, color,
        last_played_at, source_synchronized_ms
    FROM library;
    '''

    cursor.execute(query)

    music_data = []
    for row in cursor.fetchall():
        music_data.append({
            'ID': row[0],
            'Artist': row[1],
            'Title': row[2],
            'Genre': row[3],
            'Location': row[4],
            'Duration': row[5],
            'Bitrate': row[6],
            'Samplerate': row[7],
            'Cuepoint': row[8],
            'BPM': row[9],
            'Wave Summary': row[10],
            'Channels': row[11],
            'Date Added': row[12],
            'Mixxx Deleted': row[13],
            'Played': row[14],
            'Header Parsed': row[15],
            'Filetype': row[16],
            'Replaygain': row[17],
            'Times Played': row[18],
            'Rating': row[19],
            'Key': row[20],
            'Beats': row[21],
            'Beats Version': row[22],
            'BPM Lock': row[23],
            'Beats Sub Version': row[24],
            'Keys': row[25],
            'Keys Version': row[26],
            'Keys Sub Version': row[27],
            'Key ID': row[28],
            'Grouping': row[29],
            'Replaygain Peak': row[30],
            'Track Total': row[31],
            'Color': row[32],
            'Last Played At': row[33],
            'Source Synchronized MS': row[34]
        })

    conn.close()
    return music_data

# Funksjon for å eksportere musikkdata til CSV
def export_to_csv(music_data, csv_file_path):
    with open(csv_file_path, mode='w', newline='') as file:
        fieldnames = ['ID', 'Artist', 'Title', 'Genre', 'Location', 'Duration', 'Bitrate',
                      'Samplerate', 'Cuepoint', 'BPM', 'Wave Summary', 'Channels', 'Date Added',
                      'Mixxx Deleted', 'Played', 'Header Parsed', 'Filetype', 'Replaygain',
                      'Times Played', 'Rating', 'Key', 'Beats', 'Beats Version', 'BPM Lock',
                      'Beats Sub Version', 'Keys', 'Keys Version', 'Keys Sub Version', 'Key ID',
                      'Grouping', 'Replaygain Peak', 'Track Total', 'Color', 'Last Played At',
                      'Source Synchronized MS']
        writer = csv.DictWriter(file, fieldnames=fieldnames)
        writer.writeheader()
        for track in music_data:
            writer.writerow(track)

# Hovedfunksjon for å kjøre hele prosessen
def main():
    # Hent data fra Mixxx-databasen
    music_data = extract_data_from_mixxx_db(mixxx_db_path)

    # Eksporter data til CSV
    export_to_csv(music_data, csv_file_path)
    print(f"Musikkdata eksportert til {csv_file_path}")

# Kjør hovedfunksjonen
if __name__ == '__main__':
    main()

import sqlite3
import csv

# Stier til Mixxx-databasen og CSV-filen på Google Drive
mixxx_db_path = '/content/drive/MyDrive/SuperDJ_Project/mixxx_files/mixxxdb.sqlite'  # Sti til Mixxx-databasen
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/music_data_clean.csv'  # Sti til den eksisterende CSV-filen

# Funksjon for å hente musikkdata fra Mixxx-databasen
def extract_data_from_mixxx_db(mixxx_db_path):
    conn = sqlite3.connect(mixxx_db_path)
    cursor = conn.cursor()

    # Oppdatert SQL-spørring med de ønskede kolonnene
    query = '''
    SELECT
        id, artist, title, genre, location, duration, bitrate, samplerate,
        cuepoint, bpm, wavesummaryhex, channels, datetime_added, mixxx_deleted,
        played, header_parsed, filetype, replaygain, timesplayed, rating, key,
        beats, beats_version, bpm_lock, beats_sub_version, keys, keys_version,
        keys_sub_version, key_id, grouping, replaygain_peak, tracktotal, color,
        last_played_at, source_synchronized_ms
    FROM library;
    '''

    cursor.execute(query)

    music_data = []
    for row in cursor.fetchall():
        music_data.append({
            'ID': row[0],
            'Artist': row[1],
            'Title': row[2],
            'Genre': row[3],
            'Location': row[4],
            'Duration': row[5],
            'Bitrate': row[6],
            'Samplerate': row[7],
            'Cuepoint': row[8],
            'BPM': row[9],
            'Wave Summary': row[10],
            'Channels': row[11],
            'Date Added': row[12],
            'Mixxx Deleted': row[13],
            'Played': row[14],
            'Header Parsed': row[15],
            'Filetype': row[16],
            'Replaygain': row[17],
            'Times Played': row[18],
            'Rating': row[19],
            'Key': row[20],
            'Beats': row[21],
            'Beats Version': row[22],
            'BPM Lock': row[23],
            'Beats Sub Version': row[24],
            'Keys': row[25],
            'Keys Version': row[26],
            'Keys Sub Version': row[27],
            'Key ID': row[28],
            'Grouping': row[29],
            'Replaygain Peak': row[30],
            'Track Total': row[31],
            'Color': row[32],
            'Last Played At': row[33],
            'Source Synchronized MS': row[34]
        })

    conn.close()
    return music_data

# Funksjon for å eksportere musikkdata til CSV
def export_to_csv(music_data, csv_file_path):
    with open(csv_file_path, mode='w', newline='') as file:
        fieldnames = ['ID', 'Artist', 'Title', 'Genre', 'Location', 'Duration', 'Bitrate',
                      'Samplerate', 'Cuepoint', 'BPM', 'Wave Summary', 'Channels', 'Date Added',
                      'Mixxx Deleted', 'Played', 'Header Parsed', 'Filetype', 'Replaygain',
                      'Times Played', 'Rating', 'Key', 'Beats', 'Beats Version', 'BPM Lock',
                      'Beats Sub Version', 'Keys', 'Keys Version', 'Keys Sub Version', 'Key ID',
                      'Grouping', 'Replaygain Peak', 'Track Total', 'Color', 'Last Played At',
                      'Source Synchronized MS']
        writer = csv.DictWriter(file, fieldnames=fieldnames)
        writer.writeheader()
        for track in music_data:
            writer.writerow(track)

# Hovedfunksjon for å kjøre hele prosessen
def main():
    # Hent data fra Mixxx-databasen
    music_data = extract_data_from_mixxx_db(mixxx_db_path)

    # Eksporter data til CSV
    export_to_csv(music_data, csv_file_path)
    print(f"Musikkdata eksportert til {csv_file_path}")

# Kjør hovedfunksjonen
if __name__ == '__main__':
    main()

import pandas as pd

# Sti til den eksisterende CSV-filen
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/music_data_clean.csv'  # Oppdater med riktig sti hvis nødvendig

# Funksjon for å beregne energi basert på BPM og andre data
def calculate_energy(bpm, key):
    if bpm > 150:
        return "High"
    elif bpm > 120:
        return "Medium"
    else:
        return "Low"

# Funksjon for å estimere stemning basert på tonart (key)
def estimate_mood(key):
    major_keys = ['C', 'D', 'E', 'F', 'G', 'A', 'B']
    minor_keys = ['Cm', 'Dm', 'Em', 'Fm', 'Gm', 'Am', 'Bm']

    if key in major_keys:
        return "Happy"
    elif key in minor_keys:
        return "Somber"
    else:
        return "Neutral"

# Funksjon for å oppdatere CSV-filen med energi og stemningsnivå
def update_csv_with_energy_and_mood(csv_file_path):
    # Les inn den eksisterende CSV-filen med Pandas
    df = pd.read_csv(csv_file_path)

    # Beregn energi og stemning basert på eksisterende data
    df['Energy'] = df.apply(lambda row: calculate_energy(row['BPM'], row['Key']), axis=1)
    df['Mood'] = df.apply(lambda row: estimate_mood(row['Key']), axis=1)

    # Lagre oppdatert data tilbake til CSV-filen
    df.to_csv(csv_file_path, index=False)
    print(f"CSV-fil oppdatert med energi- og stemningskolonner og lagret til {csv_file_path}")

# Kjør oppdateringen
update_csv_with_energy_and_mood(csv_file_path)

import pandas as pd
import random

# Funksjon for å velge 30 sanger basert på harmoni, energi og stemning
def choose_songs_for_mixing(library, num_songs=30):
    # Sorter biblioteket etter energinivå og stemning for bedre valg
    sorted_library = library.sort_values(by=['Energy', 'Mood'], ascending=[False, True])

    # Velg 30 sanger tilfeldig, men vi kan justere kriteriene (høyere energi først)
    selected_songs = sorted_library.sample(n=num_songs)
    return selected_songs

# Funksjon for å simulere miksing av de valgte sangene
def simulate_mixing(selected_songs):
    print(f"Simulerer miksing av {len(selected_songs)} sanger.\n")

    for i in range(len(selected_songs) - 1):
        current_song = selected_songs.iloc[i]
        next_song = selected_songs.iloc[i + 1]

        # Simulerer en miks basert på energi og stemning
        print(f"Mikser '{current_song['Title']}' av {current_song['Artist']} "
              f"(Energi: {current_song['Energy']}, Stemning: {current_song['Mood']}) "
              f"med '{next_song['Title']}' av {next_song['Artist']} "
              f"(Energi: {next_song['Energy']}, Stemning: {next_song['Mood']})\n")

# Hovedfunksjon som leser biblioteket, velger sanger og simulerer miksing
def main():
    # Les inn data fra den oppdaterte CSV-filen
    csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/music_data_clean.csv'
    music_library = pd.read_csv(csv_file_path)

    # Velg 30 sanger for miksing basert på kriteriene
    selected_songs = choose_songs_for_mixing(music_library, num_songs=30)

    # Simuler miksing av de valgte sangene
    simulate_mixing(selected_songs)

# Kjør hovedfunksjonen
if __name__ == '__main__':
    main()

import pandas as pd
import random

# Funksjon for å velge 30 sanger basert på harmoni, energi og stemning
def choose_songs_for_mixing(library, num_songs=30):
    # Sorter biblioteket etter energinivå og stemning for bedre valg
    sorted_library = library.sort_values(by=['Energy', 'Mood'], ascending=[False, True])

    # Velg 30 sanger tilfeldig, men vi kan justere kriteriene (høyere energi først)
    selected_songs = sorted_library.sample(n=num_songs)
    return selected_songs

# Funksjon for å simulere miksetid og dynamisk crossfade
def simulate_mixing(selected_songs):
    print(f"Simulerer miksing av {len(selected_songs)} sanger.\n")

    for i in range(len(selected_songs) - 1):
        current_song = selected_songs.iloc[i]
        next_song = selected_songs.iloc[i + 1]

        # Beregn dynamisk crossfade basert på BPM og energi
        bpm_diff = abs(current_song['BPM'] - next_song['BPM'])
        energy_diff = abs(current_song['Energy'] - next_song['Energy'])

        # Sett dynamisk crossfade-tid basert på BPM- og energi-forskjeller
        crossfade_time = max(5, 15 - int((bpm_diff + energy_diff) / 2))
        cue_point_start = random.randint(30, 60)  # Antatt startpunkt for miksen i sekunder
        cue_point_next = random.randint(0, 30)  # Antatt startpunkt for neste sang

        # Print informasjon om hver miks
        print(f"Mikser '{current_song['Title']}' av {current_song['Artist']} "
              f"(Energi: {current_song['Energy']}, Stemning: {current_song['Mood']}, BPM: {current_song['BPM']}) "
              f"med '{next_song['Title']}' av {next_song['Artist']} "
              f"(Energi: {next_song['Energy']}, Stemning: {next_song['Mood']}, BPM: {next_song['BPM']})")
        print(f" - Crossfade-tid: {crossfade_time} sekunder")
        print(f" - Cue-punkter: Start ved {cue_point_start}s i '{current_song['Title']}' og {cue_point_next}s i '{next_song['Title']}'\n")

# Hovedfunksjon som leser biblioteket, velger sanger og simulerer miksing
def main():
    # Les inn data fra den oppdaterte CSV-filen
    csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/music_data_clean.csv'
    music_library = pd.read_csv(csv_file_path)

    # Velg 30 sanger for miksing basert på kriteriene
    selected_songs = choose_songs_for_mixing(music_library, num_songs=30)

    # Simuler miksing av de valgte sangene
    simulate_mixing(selected_songs)

# Kjør hovedfunksjonen
if __name__ == '__main__':
    main()

import pandas as pd
import random

# Funksjon for å velge 30 sanger basert på harmoni, energi og stemning
def choose_songs_for_mixing(library, num_songs=30):
    # Forsikre oss om at Energy og BPM er numeriske
    library['Energy'] = pd.to_numeric(library['Energy'], errors='coerce')
    library['BPM'] = pd.to_numeric(library['BPM'], errors='coerce')

    # Sorter biblioteket etter energinivå og stemning for bedre valg
    sorted_library = library.sort_values(by=['Energy', 'Mood'], ascending=[False, True])

    # Velg 30 sanger tilfeldig, men vi kan justere kriteriene (høyere energi først)
    selected_songs = sorted_library.sample(n=num_songs)
    return selected_songs

# Funksjon for å simulere miksetid og dynamisk crossfade
def simulate_mixing(selected_songs):
    print(f"Simulerer miksing av {len(selected_songs)} sanger.\n")

    for i in range(len(selected_songs) - 1):
        current_song = selected_songs.iloc[i]
        next_song = selected_songs.iloc[i + 1]

        # Beregn dynamisk crossfade basert på BPM og energi
        bpm_diff = abs(current_song['BPM'] - next_song['BPM'])
        energy_diff = abs(current_song['Energy'] - next_song['Energy'])

        # Sett dynamisk crossfade-tid basert på BPM- og energi-forskjeller
        crossfade_time = max(5, 15 - int((bpm_diff + energy_diff) / 2))
        cue_point_start = random.randint(30, 60)  # Antatt startpunkt for miksen i sekunder
        cue_point_next = random.randint(0, 30)  # Antatt startpunkt for neste sang

        # Print informasjon om hver miks
        print(f"Mikser '{current_song['Title']}' av {current_song['Artist']} "
              f"(Energi: {current_song['Energy']}, Stemning: {current_song['Mood']}, BPM: {current_song['BPM']}) "
              f"med '{next_song['Title']}' av {next_song['Artist']} "
              f"(Energi: {next_song['Energy']}, Stemning: {next_song['Mood']}, BPM: {next_song['BPM']})")
        print(f" - Crossfade-tid: {crossfade_time} sekunder")
        print(f" - Cue-punkter: Start ved {cue_point_start}s i '{current_song['Title']}' og {cue_point_next}s i '{next_song['Title']}'\n")

# Hovedfunksjon som leser biblioteket, velger sanger og simulerer miksing
def main():
    # Les inn data fra den oppdaterte CSV-filen
    csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/music_data_clean.csv'
    music_library = pd.read_csv(csv_file_path)

    # Velg 30 sanger for miksing basert på kriteriene
    selected_songs = choose_songs_for_mixing(music_library, num_songs=30)

    # Simuler miksing av de valgte sangene
    simulate_mixing(selected_songs)

# Kjør hovedfunksjonen
if __name__ == '__main__':
    main()

import pandas as pd
import random

# Funksjon for å velge 30 sanger basert på harmoni, energi og stemning
def choose_songs_for_mixing(library, num_songs=30):
    # Forsikre oss om at Energy og BPM er numeriske og håndterer NaN-verdier
    library['Energy'] = pd.to_numeric(library['Energy'], errors='coerce').fillna(0)  # Sett NaN til 0
    library['BPM'] = pd.to_numeric(library['BPM'], errors='coerce').fillna(120)  # Sett NaN til 120 (standard BPM)

    # Sorter biblioteket etter energinivå og stemning for bedre valg
    sorted_library = library.sort_values(by=['Energy', 'Mood'], ascending=[False, True])

    # Velg 30 sanger tilfeldig, men vi kan justere kriteriene (høyere energi først)
    selected_songs = sorted_library.sample(n=num_songs)
    return selected_songs

# Funksjon for å simulere miksetid og dynamisk crossfade
def simulate_mixing(selected_songs):
    print(f"Simulerer miksing av {len(selected_songs)} sanger.\n")

    for i in range(len(selected_songs) - 1):
        current_song = selected_songs.iloc[i]
        next_song = selected_songs.iloc[i + 1]

        # Beregn dynamisk crossfade basert på BPM og energi
        bpm_diff = abs(current_song['BPM'] - next_song['BPM'])
        energy_diff = abs(current_song['Energy'] - next_song['Energy'])

        # Sett dynamisk crossfade-tid basert på BPM- og energi-forskjeller
        crossfade_time = max(5, 15 - int((bpm_diff + energy_diff) / 2))
        cue_point_start = random.randint(30, 60)  # Antatt startpunkt for miksen i sekunder
        cue_point_next = random.randint(0, 30)  # Antatt startpunkt for neste sang

        # Print informasjon om hver miks
        print(f"Mikser '{current_song['Title']}' av {current_song['Artist']} "
              f"(Energi: {current_song['Energy']}, Stemning: {current_song['Mood']}, BPM: {current_song['BPM']}) "
              f"med '{next_song['Title']}' av {next_song['Artist']} "
              f"(Energi: {next_song['Energy']}, Stemning: {next_song['Mood']}, BPM: {next_song['BPM']})")
        print(f" - Crossfade-tid: {crossfade_time} sekunder")
        print(f" - Cue-punkter: Start ved {cue_point_start}s i '{current_song['Title']}' og {cue_point_next}s i '{next_song['Title']}'\n")

# Hovedfunksjon som leser biblioteket, velger sanger og simulerer miksing
def main():
    # Les inn data fra den oppdaterte CSV-filen
    csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/music_data_clean.csv'
    music_library = pd.read_csv(csv_file_path)

    # Velg 30 sanger for miksing basert på kriteriene
    selected_songs = choose_songs_for_mixing(music_library, num_songs=30)

    # Simuler miksing av de valgte sangene
    simulate_mixing(selected_songs)

# Kjør hovedfunksjonen
if __name__ == '__main__':
    main()

import pandas as pd

# Sti til CSV-filen i Google Drive-mappen
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/MIXXX_Test_playlist.csv'

# Les inn spillelisten fra CSV-filen
playlist = pd.read_csv(csv_file_path)

# Vis noen eksempler fra spillelisten for å få oversikt
print(playlist.head())

# Legg til felter som Energi og Stemning
playlist['Energy'] = 'Medium'  # Du kan bruke et annet system her
playlist['Mood'] = 'Happy'     # Samme gjelder stemning

# Vis oppdatert spilleliste
print(playlist.head())

# Lagre den oppdaterte CSV-filen tilbake til Google Drive
updated_csv_path = '/content/drive/MyDrive/SuperDJ_Project/analysert_playlist.csv'
playlist.to_csv(updated_csv_path, index=False)

print(f"Oppdatert spilleliste lagret som {updated_csv_path}")

import pandas as pd

# Oppdater filstien til spillelisten (CSV-fil)
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/MIXXX Test playlist.csv'

# Les inn spillelisten fra CSV-filen
playlist = pd.read_csv(csv_file_path)

# Vis noen eksempler fra spillelisten for å få oversikt
print("Noen eksempler fra spillelisten:")
print(playlist.head())

# Her kan du legge til analyse av spillelisten
# For eksempel sortere etter BPM, energi eller stemning hvis disse dataene finnes

# Funksjon for å analysere spillelisten basert på stemning og energi
def analyze_playlist(playlist):
    # Sjekk om nødvendige kolonner finnes
    if 'BPM' in playlist.columns and 'Energy' in playlist.columns and 'Mood' in playlist.columns:
        # Sorter spillelisten basert på energi og stemning
        sorted_playlist = playlist.sort_values(by=['Energy', 'Mood'], ascending=[False, True])
        print("\nAnalysert spilleliste sortert etter energi og stemning:")
        print(sorted_playlist[['Artist', 'Title', 'BPM', 'Energy', 'Mood']].head(10))
        return sorted_playlist
    else:
        print("Spillelisten har ikke nødvendige kolonner for analyse.")
        return playlist

# Analyser spillelisten
analyzed_playlist = analyze_playlist(playlist)

# Lagre den analyserte spillelisten som en ny CSV-fil
output_csv_path = '/content/drive/MyDrive/SuperDJ_Project/Analyzed_Playlist.csv'
analyzed_playlist.to_csv(output_csv_path, index=False)
print(f"\nAnalysert spilleliste lagret til {output_csv_path}")

import pandas as pd

# Filsti til den opprinnelige spillelisten
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/MIXXX Test playlist.csv'

# Sti til output CSV-filen som vil inneholde den oppdaterte analysen
output_csv_path = '/content/drive/MyDrive/SuperDJ_Project/Analyzed_MIXXX_Test_Playlist.csv'

# Funksjon for å beregne energi basert på BPM
def calculate_energy(bpm):
    try:
        bpm = float(bpm)
        if bpm > 150:
            return "High"
        elif bpm > 120:
            return "Medium"
        else:
            return "Low"
    except ValueError:
        return "Unknown"

# Funksjon for å estimere stemning basert på toneart (key)
def estimate_mood(key):
    major_keys = ['C', 'D', 'E', 'F', 'G', 'A', 'B']
    minor_keys = ['Cm', 'Dm', 'Em', 'Fm', 'Gm', 'Am', 'Bm']

    if key in major_keys:
        return "Happy"
    elif key in minor_keys:
        return "Somber"
    else:
        return "Neutral"

# Funksjon for å oppdatere spillelisten med energi og stemningsnivå
def update_playlist_with_energy_and_mood(csv_file_path, output_csv_path):
    # Les inn den eksisterende spillelisten med Pandas
    df = pd.read_csv(csv_file_path)

    # Beregn energi og stemning basert på eksisterende data
    df['Energy'] = df['BPM'].apply(calculate_energy)
    df['Mood'] = df['Key'].apply(estimate_mood)

    # Vis noen eksempler fra den oppdaterte spillelisten
    print("Noen eksempler fra den oppdaterte spillelisten med energi og stemning:")
    print(df[['Artist', 'Title', 'BPM', 'Key', 'Energy', 'Mood']].head())

    # Lagre oppdatert spilleliste til en ny CSV-fil
    df.to_csv(output_csv_path, index=False)
    print(f"Oppdatert spilleliste med energi- og stemningskolonner lagret til {output_csv_path}")

# Kjør oppdateringen
update_playlist_with_energy_and_mood(csv_file_path, output_csv_path)

import pandas as pd
import random

# Sti til den analyserte spillelisten
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/Analyzed_MIXXX_Test_Playlist.csv'

# Les inn spillelisten
playlist = pd.read_csv(csv_file_path)

# Funksjon for å simulere miksing av sanger
def simulate_mixing(playlist):
    print(f"Simulerer miksing av {len(playlist)} sanger.\n")

    for i in range(len(playlist) - 1):
        current_song = playlist.iloc[i]
        next_song = playlist.iloc[i + 1]

        # Beregn forskjell i BPM og energi
        bpm_diff = abs(current_song['BPM'] - next_song['BPM'])
        energy_diff = 0 if current_song['Energy'] == next_song['Energy'] else 1

        # Sett dynamisk crossfade-tid basert på BPM- og energi-forskjeller
        crossfade_time = max(5, 15 - int((bpm_diff + energy_diff) / 2))
        cue_point_start = random.randint(30, 60)  # Antatt startpunkt for miksen i sekunder
        cue_point_next = random.randint(0, 30)  # Antatt startpunkt for neste sang

        # Print informasjon om hver miks
        print(f"Mikser '{current_song['Title']}' av {current_song['Artist']} "
              f"(Energi: {current_song['Energy']}, Stemning: {current_song['Mood']}, BPM: {current_song['BPM']}) "
              f"med '{next_song['Title']}' av {next_song['Artist']} "
              f"(Energi: {next_song['Energy']}, Stemning: {next_song['Mood']}, BPM: {next_song['BPM']})")
        print(f" - Crossfade-tid: {crossfade_time} sekunder")
        print(f" - Cue-punkter: Start ved {cue_point_start}s i '{current_song['Title']}' og {cue_point_next}s i '{next_song['Title']}'\n")

# Kjør simuleringen
simulate_mixing(playlist)

import pandas as pd
import random

# Sti til den analyserte spillelisten
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/Analyzed_MIXXX_Test_Playlist.csv'

# Les inn spillelisten
playlist = pd.read_csv(csv_file_path)

# Funksjon for å simulere miksing av sanger
def simulate_mixing(playlist):
    print(f"Simulerer miksing av {len(playlist)} sanger.\n")

    for i in range(len(playlist) - 1):
        current_song = playlist.iloc[i]
        next_song = playlist.iloc[i + 1]

        # Beregn forskjell i BPM og energi
        bpm_diff = abs(current_song['BPM'] - next_song['BPM'])
        energy_diff = 0 if current_song['Energy'] == next_song['Energy'] else 1

        # Dynamisk justering av crossfade-tiden
        crossfade_time = max(5, 15 - int((bpm_diff + energy_diff) / 2))

        # Kortere crossfade-tid for identiske BPM-er
        if bpm_diff == 0:
            crossfade_time = 5

        cue_point_start = random.randint(30, 60)  # Antatt startpunkt for miksen i sekunder
        cue_point_next = random.randint(0, 30)  # Antatt startpunkt for neste sang

        # Print informasjon om hver miks
        print(f"Mikser '{current_song['Title']}' av {current_song['Artist']} "
              f"(Energi: {current_song['Energy']}, Stemning: {current_song['Mood']}, BPM: {current_song['BPM']}) "
              f"med '{next_song['Title']}' av {next_song['Artist']} "
              f"(Energi: {next_song['Energy']}, Stemning: {next_song['Mood']}, BPM: {next_song['BPM']})")
        print(f" - Crossfade-tid: {crossfade_time} sekunder")
        print(f" - Cue-punkter: Start ved {cue_point_start}s i '{current_song['Title']}' og {cue_point_next}s i '{next_song['Title']}'\n")

# Kjør simuleringen
simulate_mixing(playlist)

import pandas as pd
import re

# Funksjon for å lese cue-punkter fra MIXXX CSV-fil
def extract_cue_points_from_mixxx_csv(csv_file_path):
    df = pd.read_csv(csv_file_path)
    # Antar at cue-punkter ligger i en kolonne som heter 'Cue Points' eller lignende
    if 'Cue Points' in df.columns:
        return df[['Title', 'Artist', 'Cue Points']]
    else:
        print("Ingen 'Cue Points'-kolonne funnet i CSV-filen.")
        return None

# Funksjon for å lese cue-punkter fra MIXXX m3u8-fil
def extract_cue_points_from_m3u8(m3u8_file_path):
    with open(m3u8_file_path, 'r') as file:
        lines = file.readlines()
        cue_points = []
        for line in lines:
            if line.startswith('#EXTINF'):
                # Eksempel på linje: #EXTINF:221,Artist - Title
                match = re.search(r'#EXTINF:(\d+),(.+?) - (.+)', line)
                if match:
                    duration = int(match.group(1))
                    artist = match.group(2)
                    title = match.group(3)
                    # Simulerte cue-punkter for m3u8-format
                    cue_point = {'Title': title, 'Artist': artist, 'Cue Points': f'Start at {duration // 3}s'}
                    cue_points.append(cue_point)
        return pd.DataFrame(cue_points)

# Funksjon for å sammenligne cue-punkter med energianalyse
def compare_with_energy_analysis(cue_df, energy_df):
    # Sjekk om de nødvendige kolonnene finnes i cue-punkt-filen
    if 'Title' not in cue_df.columns or 'Artist' not in cue_df.columns:
        raise KeyError("Cue-punkt-filen mangler nødvendige kolonner: 'Title' og/eller 'Artist'.")

    if 'Title' not in energy_df.columns or 'Artist' not in energy_df.columns:
        raise KeyError("Energianalyse-filen mangler nødvendige kolonner: 'Title' og/eller 'Artist'.")

    # Slå sammen dataene basert på tittel og artist for å inkludere både cue-punkter og energianalyse
    merged_df = pd.merge(cue_df, energy_df, on=['Title', 'Artist'], how='inner')

    return merged_df

# Test funksjonene på cue-punktene og energianalysen
if cue_csv is not None:
    final_csv_comparison = compare_with_energy_analysis(cue_csv, energy_df)
if cue_m3u8 is not None:
    final_m3u8_comparison = compare_with_energy_analysis(cue_m3u8, energy_df)
if cue_pls is not None:
    final_pls_comparison = compare_with_energy_analysis(cue_pls, energy_df)

# Funksjon for å sammenligne cue-punkter med energianalyse
def compare_with_energy_analysis(cue_df, energy_df):
    # Kombinerer begge dataene på tittel og artist
    merged_df = pd.merge(cue_df, energy_df, on=['Title', 'Artist'], how='left')

    # Finn forskjeller i cue-punkter basert på energi
    for index, row in merged_df.iterrows():
        energy = row['Energy']
        cue_points = row['Cue Points']
        # Eksempel på tilpasning av cue-punkter basert på energinivå
        if energy == 'High' and 'Start at' in cue_points:
            suggested_cue_point = int(re.search(r'Start at (\d+)s', cue_points).group(1)) - 10
            print(f"Tilpasset cue-punkt for høy energi: {row['Title']} fra {cue_points} til Start at {suggested_cue_point}s")

    return merged_df

# Filstier
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/MIXXX Test playlist.csv'
m3u8_file_path = '/content/drive/MyDrive/SuperDJ_Project/MIXXX Test playlist.m3u8'
pls_file_path = '/content/drive/MyDrive/SuperDJ_Project/MIXXX Test playlist.pls'
energy_analysis_file_path = '/content/drive/MyDrive/SuperDJ_Project/Analyzed_Playlist.csv'

# Les cue-punkter fra de forskjellige MIXXX-spillelistene
cue_csv = extract_cue_points_from_mixxx_csv(csv_file_path)
cue_m3u8 = extract_cue_points_from_m3u8(m3u8_file_path)
cue_pls = extract_cue_points_from_pls(pls_file_path)

# Les energianalyse-filen
energy_df = pd.read_csv(energy_analysis_file_path)

# Kombiner cue-punkter og energianalyse
if cue_csv is not None:
    final_csv_comparison = compare_with_energy_analysis(cue_csv, energy_df)
if cue_m3u8 is not None:
    final_m3u8_comparison = compare_with_energy_analysis(cue_m3u8, energy_df)
if cue_pls is not None:
    final_pls_comparison = compare_with_energy_analysis(cue_pls, energy_df)

# Lagre resultatene til en ny fil
final_csv_comparison.to_csv('/content/drive/MyDrive/SuperDJ_Project/Final_Cuepoint_Analysis.csv', index=False)
print("Analyse av cue-punkter lagret.")

import pandas as pd
import re

# Sti til nødvendige filer
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/MIXXX Test playlist.csv'
m3u8_file_path = '/content/drive/MyDrive/SuperDJ_Project/MIXXX Test playlist.m3u8'
pls_file_path = '/content/drive/MyDrive/SuperDJ_Project/MIXXX Test playlist.pls'
energy_analysis_path = '/content/drive/MyDrive/SuperDJ_Project/Analyzed_MIXXX_Test_Playlist.csv'

# Funksjon for å beregne energi basert på BPM og andre data
def calculate_energy(bpm, key):
    if bpm > 150:
        return "High"
    elif bpm > 120:
        return "Medium"
    else:
        return "Low"

# Funksjon for å estimere stemning basert på tonart (key)
def estimate_mood(key):
    major_keys = ['C', 'D', 'E', 'F', 'G', 'A', 'B']
    minor_keys = ['Cm', 'Dm', 'Em', 'Fm', 'Gm', 'Am', 'Bm']

    if key in major_keys:
        return "Happy"
    elif key in minor_keys:
        return "Somber"
    else:
        return "Neutral"

# Funksjon for å oppdatere CSV-filen med energi og stemningsnivå
def update_csv_with_energy_and_mood(csv_file_path):
    df = pd.read_csv(csv_file_path)
    df['Energy'] = df.apply(lambda row: calculate_energy(row['BPM'], row['Key']), axis=1)
    df['Mood'] = df.apply(lambda row: estimate_mood(row['Key']), axis=1)
    df.to_csv(csv_file_path, index=False)
    print(f"CSV-fil oppdatert med energi- og stemningskolonner og lagret til {csv_file_path}")

# Kjør oppdateringen på energianalyse
update_csv_with_energy_and_mood(csv_file_path)

# Les inn energianalysen
energy_df = pd.read_csv(energy_analysis_path)

# Funksjoner for å trekke ut cue-punkter fra forskjellige filformater
def extract_cue_points_from_mixxx_csv(csv_file_path):
    df = pd.read_csv(csv_file_path)
    if 'Cue Points' not in df.columns:
        raise KeyError("Ingen 'Cue Points'-kolonne funnet i CSV-filen.")
    return df[['Title', 'Artist', 'Cue Points']]

def extract_cue_points_from_m3u8(m3u8_file_path):
    cue_points = []
    with open(m3u8_file_path, 'r') as file:
        for line in file:
            match = re.search(r"#EXTINF:\d+,(.+) - (.+)", line)
            if match:
                title, artist = match.groups()
                cue_point = {'Title': title, 'Artist': artist, 'Cue Points': 'No Cue Point Info'}
                cue_points.append(cue_point)
    return pd.DataFrame(cue_points)

def extract_cue_points_from_pls(pls_file_path):
    cue_points = []
    with open(pls_file_path, 'r') as file:
        for line in file:
            if line.startswith('File'):
                match = re.search(r'=(.+)', line)
                if match:
                    file_path = match.group(1).split('/')[-1]
                    if ' - ' in file_path:
                        title, artist = file_path.split(' - ')
                        cue_point = {'Title': title, 'Artist': artist, 'Cue Points': 'No Cue Point Info'}
                        cue_points.append(cue_point)
    return pd.DataFrame(cue_points)

# Funksjon for å sammenligne cue-punkter med energianalyse
def compare_with_energy_analysis(cue_df, energy_df):
    # Sjekk om de nødvendige kolonnene finnes i cue-punkt-filen
    if 'Title' not in cue_df.columns or 'Artist' not in cue_df.columns:
        raise KeyError("Cue-punkt-filen mangler nødvendige kolonner: 'Title' og/eller 'Artist'.")

    if 'Title' not in energy_df.columns or 'Artist' not in energy_df.columns:
        raise KeyError("Energianalyse-filen mangler nødvendige kolonner: 'Title' og/eller 'Artist'.")

    # Slå sammen dataene basert på tittel og artist for å inkludere både cue-punkter og energianalyse
    merged_df = pd.merge(cue_df, energy_df, on=['Title', 'Artist'], how='inner')

    return merged_df

# Test funksjonene på cue-punktene og energianalysen
cue_csv = None
cue_m3u8 = None
cue_pls = None

try:
    cue_csv = extract_cue_points_from_mixxx_csv(csv_file_path)
except Exception as e:
    print(f"Feil ved lesing av Cue-punkter fra CSV: {e}")

try:
    cue_m3u8 = extract_cue_points_from_m3u8(m3u8_file_path)
except Exception as e:
    print(f"Feil ved lesing av Cue-punkter fra M3U8: {e}")

try:
    cue_pls = extract_cue_points_from_pls(pls_file_path)
except Exception as e:
    print(f"Feil ved lesing av Cue-punkter fra PLS: {e}")

# Sammenlign cue-punkter med energianalysen
if cue_csv is not None:
    final_csv_comparison = compare_with_energy_analysis(cue_csv, energy_df)
if cue_m3u8 is not None:
    final_m3u8_comparison = compare_with_energy_analysis(cue_m3u8, energy_df)
if cue_pls is not None:
    final_pls_comparison = compare_with_energy_analysis(cue_pls, energy_df)

# Skriv ut resultater (du kan lagre dem til en fil også hvis ønskelig)
if cue_csv is not None:
    print("CSV Cue-punkter sammenligning:\n", final_csv_comparison.head())
if cue_m3u8 is not None:
    print("M3U8 Cue-punkter sammenligning:\n", final_m3u8_comparison.head())
if cue_pls is not None:
    print("PLS Cue-punkter sammenligning:\n", final_pls_comparison.head())

import pandas as pd
import re

# Sti til nødvendige filer
csv_file_path = '/content/drive/MyDrive/SuperDJ_Project/MIXXX Test playlist.csv'
m3u8_file_path = '/content/drive/MyDrive/SuperDJ_Project/MIXXX Test playlist.m3u8'
pls_file_path = '/content/drive/MyDrive/SuperDJ_Project/MIXXX Test playlist.pls'
energy_analysis_path = '/content/drive/MyDrive/SuperDJ_Project/Analyzed_MIXXX_Test_Playlist.csv'

# Funksjon for å beregne energi basert på BPM og andre data
def calculate_energy(bpm, key):
    if bpm > 150:
        return "High"
    elif bpm > 120:
        return "Medium"
    else:
        return "Low"

# Funksjon for å estimere stemning basert på tonart (key)
def estimate_mood(key):
    major_keys = ['C', 'D', 'E', 'F', 'G', 'A', 'B']
    minor_keys = ['Cm', 'Dm', 'Em', 'Fm', 'Gm', 'Am', 'Bm']

    if key in major_keys:
        return "Happy"
    elif key in minor_keys:
        return "Somber"
    else:
        return "Neutral"

# Funksjon for å oppdatere CSV-filen med energi og stemningsnivå
def update_csv_with_energy_and_mood(csv_file_path):
    df = pd.read_csv(csv_file_path)
    df['Energy'] = df.apply(lambda row: calculate_energy(row['BPM'], row['Key']), axis=1)
    df['Mood'] = df.apply(lambda row: estimate_mood(row['Key']), axis=1)
    df.to_csv(csv_file_path, index=False)
    print(f"CSV-fil oppdatert med energi- og stemningskolonner og lagret til {csv_file_path}")

# Kjør oppdateringen på energianalyse
update_csv_with_energy_and_mood(csv_file_path)

# Les inn energianalysen
energy_df = pd.read_csv(energy_analysis_path)

# Funksjoner for å trekke ut cue-punkter fra forskjellige filformater
def extract_cue_points_from_mixxx_csv(csv_file_path):
    df = pd.read_csv(csv_file_path)
    if 'Cue Points' not in df.columns:
        print("Ingen 'Cue Points'-kolonne funnet i CSV-filen.")
        return None
    return df[['Title', 'Artist', 'Cue Points']]

def extract_cue_points_from_m3u8(m3u8_file_path):
    cue_points = []
    with open(m3u8_file_path, 'r') as file:
        for line in file:
            match = re.search(r"#EXTINF:\d+,(.+) - (.+)", line)
            if match:
                title, artist = match.groups()
                cue_point = {'Title': title, 'Artist': artist, 'Cue Points': 'No Cue Point Info'}
                cue_points.append(cue_point)
    if len(cue_points) == 0:
        print("Ingen Cue-punkter funnet i M3U8-filen.")
        return None
    return pd.DataFrame(cue_points)

def extract_cue_points_from_pls(pls_file_path):
    cue_points = []
    with open(pls_file_path, 'r') as file:
        for line in file:
            if line.startswith('File'):
                match = re.search(r'=(.+)', line)
                if match:
                    file_path = match.group(1).split('/')[-1]
                    if ' - ' in file_path:
                        title, artist = file_path.split(' - ')
                        cue_point = {'Title': title, 'Artist': artist, 'Cue Points': 'No Cue Point Info'}
                        cue_points.append(cue_point)
    if len(cue_points) == 0:
        print("Ingen Cue-punkter funnet i PLS-filen.")
        return None
    return pd.DataFrame(cue_points)

# Funksjon for å sammenligne cue-punkter med energianalyse
def compare_with_energy_analysis(cue_df, energy_df):
    # Sjekk om de nødvendige kolonnene finnes i cue-punkt-filen
    if 'Title' not in cue_df.columns or 'Artist' not in cue_df.columns:
        raise KeyError("Cue-punkt-filen mangler nødvendige kolonner: 'Title' og/eller 'Artist'.")

    if 'Title' not in energy_df.columns or 'Artist' not in energy_df.columns:
        raise KeyError("Energianalyse-filen mangler nødvendige kolonner: 'Title' og/eller 'Artist'.")

    # Slå sammen dataene basert på tittel og artist for å inkludere både cue-punkter og energianalyse
    merged_df = pd.merge(cue_df, energy_df, on=['Title', 'Artist'], how='inner')

    return merged_df

# Test funksjonene på cue-punktene og energianalysen
cue_csv = None
cue_m3u8 = None
cue_pls = None

# Ekstraher cue-punkter fra forskjellige filformater
try:
    cue_csv = extract_cue_points_from_mixxx_csv(csv_file_path)
except Exception as e:
    print(f"Feil ved lesing av Cue-punkter fra CSV: {e}")

try:
    cue_m3u8 = extract_cue_points_from_m3u8(m3u8_file_path)
except Exception as e:
    print(f"Feil ved lesing av Cue-punkter fra M3U8: {e}")

try:
    cue_pls = extract_cue_points_from_pls(pls_file_path)
except Exception as e:
    print(f"Feil ved lesing av Cue-punkter fra PLS: {e}")

# Sammenlign cue-punkter med energianalysen hvis data er tilgjengelig
if cue_csv is not None:
    final_csv_comparison = compare_with_energy_analysis(cue_csv, energy_df)
if cue_m3u8 is not None:
    final_m3u8_comparison = compare_with_energy_analysis(cue_m3u8, energy_df)
if cue_pls is not None:
    final_pls_comparison = compare_with_energy_analysis(cue_pls, energy_df)

# Skriv ut resultater (eller lagre til en fil)
if cue_csv is not None:
    print("CSV Cue-punkter sammenligning:\n", final_csv_comparison.head())
if cue_m3u8 is not None:
    print("M3U8 Cue-punkter sammenligning:\n", final_m3u8_comparison.head())
if cue_pls is not None:
    print("PLS Cue-punkter sammenligning:\n", final_pls_comparison.head())

def inspect_m3u8(m3u8_file_path):
    with open(m3u8_file_path, 'r') as file:
        for line in file:
            print(line.strip())  # Skriv ut hver linje i filen for inspeksjon

inspect_m3u8(m3u8_file_path)

def inspect_pls(pls_file_path):
    with open(pls_file_path, 'r') as file:
        for line in file:
            print(line.strip())  # Skriv ut hver linje i filen for inspeksjon

inspect_pls(pls_file_path)



from google.colab import drive
drive.mount('/content/drive')

from google.colab import drive
import os

# Koble til Google Drive
drive.mount('/content/drive')

# Funksjon for å vise alle filer i en gitt mappe
def list_files_in_directory(directory):
    try:
        # Sjekk om mappen finnes
        if os.path.exists(directory):
            print(f'\nInnhold i mappen: {directory}')
            for file in os.listdir(directory):
                print(file)
        else:
            print(f'Mappen {directory} eksisterer ikke.')
    except Exception as e:
        print(f'Feil ved lesing av mappen {directory}: {e}')

# Definer sti til hovedmappen i Drive
main_directory = '/content/drive/MyDrive/Belling_Project/Colab_Notebooks'

# Mappene vi vil sjekke
directories_to_check = [
    os.path.join(main_directory, 'Mixxx_Integration'),
    os.path.join(main_directory, 'Music_Analysis'),
    os.path.join(main_directory, 'AI_Training')
]

# Gå gjennom hver mappe og list filer
for directory in directories_to_check:
    list_files_in_directory(directory)

import os

# Funksjon for å sjekke filer i en gitt mappe
def list_files_in_directory(directory):
    try:
        # Hent alle filnavn i mappen
        files = os.listdir(directory)
        print(f"Filer i {directory}:")
        if len(files) > 0:
            for file in files:
                print(f" - {file}")
        else:
            print("Ingen filer funnet.")
    except Exception as e:
        print(f"Kunne ikke åpne {directory}. Feilmelding: {str(e)}")

# Sti til Google Drive-prosjektmappen din
base_dir = '/content/drive/MyDrive/SuperDJ_Project/Belling_Project/Colab_Notebooks/'

# Definer undermapper
mixxx_integration_dir = os.path.join(base_dir, 'Mixxx_Integration')
music_analysis_dir = os.path.join(base_dir, 'Music_Analysis')
ai_training_dir = os.path.join(base_dir, 'AI_Training')

# Sjekk filer i hver mappe
list_files_in_directory(mixxx_integration_dir)
list_files_in_directory(music_analysis_dir)
list_files_in_directory(ai_training_dir)